import Decimal from "decimal.js";
import { PublicKey, SignedTransactionIntent } from "../models";
import { TransactionValidity } from "../wrapper/default";
import { TransactionSummary } from "../wrapper/lts";
import { RadixEngineToolkitWasmWrapper } from "../wrapper/wasm_wrapper";
import { Address, Amount, NotarySignatureSource } from "./builder_models";
export interface FungibleTransfer {
    resourceAddress: Address;
    toAccount: Address;
    amount: Amount;
}
export interface SimpleTransactionBuilderSettings {
    networkId: number;
    validFromEpoch: number;
    fromAccount: string;
    signerPublicKey: PublicKey.PublicKey;
}
export interface SimpleTransactionBuilderFreeXrdSettings {
    networkId: number;
    validFromEpoch: number;
    toAccount: string;
}
export declare class SimpleTransactionBuilder {
    private retWrapper;
    private _startEpoch;
    private _expiresAfterEpochs;
    private _networkId;
    private _nonce;
    private _tipPercentage;
    private _notaryPublicKey;
    private _fromAccount;
    private _feeAmount;
    private _actions;
    constructor(retWrapper: RadixEngineToolkitWasmWrapper, startEpoch: number, networkId: number, fromAccount: string, notaryPublicKey: PublicKey.PublicKey, nonce: number);
    static new(settings: SimpleTransactionBuilderSettings): Promise<SimpleTransactionBuilder>;
    static freeXrdFromFaucet(settings: SimpleTransactionBuilderFreeXrdSettings): Promise<CompiledNotarizedTransaction>;
    nonce(nonce: number): this;
    /**
     * Set the number of epochs this transaction is valid for (including the current epoch - which might nearly be over!)
     * Each epoch is approximately 5 minutes long.
     *
     * If `validFromEpoch` is set to the current epoch, then there are 0-5 minutes left of this first epoch.
     * So `expiresAfterEpochs(10)` would result in the transaction permanently rejecting after approximately 45-50 minutes.
     *
     * @param epochCount The number of epochs after with the transaction permanently rejects.
     * @returns the builder
     */
    permanentlyRejectAfterEpochs(epochCount: number): this;
    tipPercentage(tipPercentage: number): this;
    /**
     * @param amount The amount of fee to lock. If not set, it will be 5 XRD.
     * @returns the builder
     */
    lockedFee(amount: Amount): this;
    transferFungible(transfer: FungibleTransfer): this;
    /**
     * This compiles the "signed intent" without any additional signatures (other than the notary which will count as a signatory).
     * @returns the compiled intent, along with the `hashToNotarize` which needs to be signed.
     */
    compileIntent(): CompiledSignedTransactionIntent;
    private transition;
    private constructTransactionHeader;
    private constructTransactionManifest;
    private resolveActions;
    private resolveFeeAmount;
}
export declare class FungibleResourceTransferAction {
    from: string;
    to: string;
    resourceAddress: string;
    amount: Decimal;
    constructor(from: string, to: string, resourceAddress: string, amount: Decimal);
}
export declare class CompiledSignedTransactionIntent {
    private readonly retWrapper;
    private readonly signedIntent;
    readonly intentHash: Uint8Array;
    readonly compiledSignedIntent: Uint8Array;
    readonly signedIntentHash: Uint8Array;
    constructor(retWrapper: RadixEngineToolkitWasmWrapper, intentHash: Uint8Array, signedIntent: SignedTransactionIntent, compiledSignedIntent: Uint8Array, signedIntentHash: Uint8Array);
    /**
     * @returns The hash to notarize (the signed intent hash)
     */
    get hashToNotarize(): Uint8Array;
    /**
     * @returns The transaction identifier (also known as the intent hash) of the transaction.
     */
    get transactionId(): Uint8Array;
    toByteArray(): Uint8Array;
    compileNotarized(source: NotarySignatureSource): CompiledNotarizedTransaction;
    /**
     * @returns The transaction identifier (also known as the intent hash) of the transaction, encoded into hex.
     */
    intentHashHex(): string;
    /**
     * Decompiles and summarizes a compiled intent extracting information such as locked fees,
     * deposits, and withdrawals.
     */
    summarizeTransaction(): Promise<TransactionSummary>;
}
export declare class CompiledNotarizedTransaction {
    private readonly retWrapper;
    readonly compiled: Uint8Array;
    readonly intentHash: Uint8Array;
    readonly notarizedPayloadHash: Uint8Array;
    constructor(retWrapper: RadixEngineToolkitWasmWrapper, intentHash: Uint8Array, compiled: Uint8Array, notarizedPayloadHash: Uint8Array);
    /**
     * @returns The transaction identifier (also known as the intent hash) of the transaction.
     */
    get transactionId(): Uint8Array;
    toByteArray(): Uint8Array;
    toHex(): string;
    /**
     * @returns The transaction identifier (also known as the intent hash) of the transaction, encoded into hex.
     */
    intentHashHex(): string;
    /**
     * @returns The transaction identifier (also known as the intent hash) of the transaction, encoded into hex.
     */
    transactionIdHex(): string;
    /**
     * @returns The (notarized) payload hash, encoded into hex.
     */
    notarizedPayloadHashHex(): string;
    staticallyValidate(networkId: number): Promise<TransactionValidity>;
    /**
     * Decompiles and summarizes a compiled intent extracting information such as locked fees,
     * deposits, and withdrawals.
     */
    summarizeTransaction(): Promise<TransactionSummary>;
}
