import { ManifestAstValue } from "../../models/value";
export declare abstract class Instruction {
    readonly instruction: Kind;
    constructor(instruction: Kind);
    abstract toString(): string;
}
export declare enum Kind {
    CallFunction = "CALL_FUNCTION",
    CallMethod = "CALL_METHOD",
    CallRoyaltyMethod = "CALL_ROYALTY_METHOD",
    CallMetadataMethod = "CALL_METADATA_METHOD",
    CallAccessRulesMethod = "CALL_ACCESS_RULES_METHOD",
    TakeAllFromWorktop = "TAKE_ALL_FROM_WORKTOP",
    TakeFromWorktop = "TAKE_FROM_WORKTOP",
    TakeNonFungiblesFromWorktop = "TAKE_NON_FUNGIBLES_FROM_WORKTOP",
    ReturnToWorktop = "RETURN_TO_WORKTOP",
    AssertWorktopContains = "ASSERT_WORKTOP_CONTAINS",
    AssertWorktopContainsNonFungibles = "ASSERT_WORKTOP_CONTAINS_NON_FUNGIBLES",
    PopFromAuthZone = "POP_FROM_AUTH_ZONE",
    PushToAuthZone = "PUSH_TO_AUTH_ZONE",
    ClearAuthZone = "CLEAR_AUTH_ZONE",
    ClearSignatureProofs = "CLEAR_SIGNATURE_PROOFS",
    CreateProofFromAuthZone = "CREATE_PROOF_FROM_AUTH_ZONE",
    CreateProofFromAuthZoneOfAll = "CREATE_PROOF_FROM_AUTH_ZONE_OF_ALL",
    CreateProofFromAuthZoneOfAmount = "CREATE_PROOF_FROM_AUTH_ZONE_OF_AMOUNT",
    CreateProofFromAuthZoneOfNonFungibles = "CREATE_PROOF_FROM_AUTH_ZONE_OF_NON_FUNGIBLES",
    CreateProofFromBucket = "CREATE_PROOF_FROM_BUCKET",
    CreateProofFromBucketOfAll = "CREATE_PROOF_FROM_BUCKET_OF_ALL",
    CreateProofFromBucketOfAmount = "CREATE_PROOF_FROM_BUCKET_OF_AMOUNT",
    CreateProofFromBucketOfNonFungibles = "CREATE_PROOF_FROM_BUCKET_OF_NON_FUNGIBLES",
    CloneProof = "CLONE_PROOF",
    DropProof = "DROP_PROOF",
    DropAllProofs = "DROP_ALL_PROOFS",
    PublishPackage = "PUBLISH_PACKAGE",
    PublishPackageAdvanced = "PUBLISH_PACKAGE_ADVANCED",
    BurnResource = "BURN_RESOURCE",
    RecallFromVault = "RECALL_RESOURCE",
    SetMetadata = "SET_METADATA",
    RemoveMetadata = "REMOVE_METADATA",
    SetPackageRoyaltyConfig = "SET_PACKAGE_ROYALTY_CONFIG",
    SetComponentRoyaltyConfig = "SET_COMPONENT_ROYALTY_CONFIG",
    ClaimPackageRoyalty = "CLAIM_PACKAGE_ROYALTY",
    ClaimComponentRoyalty = "CLAIM_COMPONENT_ROYALTY",
    SetAuthorityAccessRule = "SET_AUTHORITY_ACCESS_RULE",
    SetAuthorityMutability = "SET_AUTHORITY_MUTABILITY",
    MintFungible = "MINT_FUNGIBLE",
    MintNonFungible = "MINT_NON_FUNGIBLE",
    MintUuidNonFungible = "MINT_UUID_NON_FUNGIBLE",
    CreateFungibleResource = "CREATE_FUNGIBLE_RESOURCE",
    CreateFungibleResourceWithInitialSupply = "CREATE_FUNGIBLE_RESOURCE_WITH_INITIAL_SUPPLY",
    CreateNonFungibleResource = "CREATE_NON_FUNGIBLE_RESOURCE",
    CreateNonFungibleResourceWithInitialSupply = "CREATE_NON_FUNGIBLE_RESOURCE_WITH_INITIAL_SUPPLY",
    CreateAccessController = "CREATE_ACCESS_CONTROLLER",
    CreateIdentity = "CREATE_IDENTITY",
    CreateIdentityAdvanced = "CREATE_IDENTITY_ADVANCED",
    CreateValidator = "CREATE_VALIDATOR",
    CreateAccount = "CREATE_ACCOUNT",
    CreateAccountAdvanced = "CREATE_ACCOUNT_ADVANCED",
    FreezeVault = "FREEZE_VAULT",
    RecallNonFungiblesFromVault = "RECALL_NON_FUNGIBLES_FROM_VAULT",
    UnfreezeVault = "UNFREEZE_VAULT",
    UpdateRole = "UPDATE_ROLE",
    AllocateGlobalAddress = "ALLOCATE_GLOBAL_ADDRESS"
}
/**
 * An instruction to call a function with the given list of arguments on the given package address
 * and blueprint name.
 */
export declare class CallFunction extends Instruction {
    packageAddress: ManifestAstValue.Address;
    blueprintName: ManifestAstValue.String;
    functionName: ManifestAstValue.String;
    arguments: Array<ManifestAstValue.Value>;
    constructor(packageAddress: ManifestAstValue.Address, blueprintName: ManifestAstValue.String, functionName: ManifestAstValue.String, args: Array<ManifestAstValue.Value>);
    toString(): string;
    toObject(): Record<string, any>;
}
/**
 * An instruction to call a method with a given name on a given component address with the given
 * list of arguments.
 */
export declare class CallMethod extends Instruction {
    componentAddress: ManifestAstValue.Address;
    methodName: ManifestAstValue.String;
    arguments: Array<ManifestAstValue.Value>;
    constructor(componentAddress: ManifestAstValue.Address, methodName: ManifestAstValue.String, args: Array<ManifestAstValue.Value>);
    toString(): string;
    toObject(): Record<string, any>;
}
/**
 * An instruction to call a method with a given name on a given component address with the given
 * list of arguments.
 */
export declare class CallRoyaltyMethod extends Instruction {
    componentAddress: ManifestAstValue.Address;
    methodName: ManifestAstValue.String;
    arguments: Array<ManifestAstValue.Value> | null;
    constructor(componentAddress: ManifestAstValue.Address, methodName: ManifestAstValue.String, args: Array<ManifestAstValue.Value>);
    toString(): string;
    toObject(): Record<string, any>;
}
/**
 * An instruction to call a method with a given name on a given component address with the given
 * list of arguments.
 */
export declare class CallMetadataMethod extends Instruction {
    componentAddress: ManifestAstValue.Address;
    methodName: ManifestAstValue.String;
    arguments: Array<ManifestAstValue.Value> | null;
    constructor(componentAddress: ManifestAstValue.Address, methodName: ManifestAstValue.String, args: Array<ManifestAstValue.Value>);
    toString(): string;
    toObject(): Record<string, any>;
}
/**
 * An instruction to call a method with a given name on a given component address with the given
 * list of arguments.
 */
export declare class CallAccessRulesMethod extends Instruction {
    componentAddress: ManifestAstValue.Address;
    methodName: ManifestAstValue.String;
    arguments: Array<ManifestAstValue.Value> | null;
    constructor(componentAddress: ManifestAstValue.Address, methodName: ManifestAstValue.String, args: Array<ManifestAstValue.Value>);
    toString(): string;
    toObject(): Record<string, any>;
}
/**
 * An instruction to take the entire amount of a given resource address from the worktop and put it
 * in a bucket.
 */
export declare class TakeAllFromWorktop extends Instruction {
    resourceAddress: ManifestAstValue.Address;
    intoBucket: ManifestAstValue.Bucket;
    constructor(resourceAddress: ManifestAstValue.Address, intoBucket: ManifestAstValue.Bucket);
    toString(): string;
    toObject(): Record<string, any>;
}
/**
 * An instruction to take the an amount of a given resource address from the worktop and put it in a
 * bucket.
 */
export declare class TakeFromWorktop extends Instruction {
    resourceAddress: ManifestAstValue.Address;
    amount: ManifestAstValue.Decimal;
    intoBucket: ManifestAstValue.Bucket;
    constructor(resourceAddress: ManifestAstValue.Address, amount: ManifestAstValue.Decimal, intoBucket: ManifestAstValue.Bucket);
    toString(): string;
    toObject(): Record<string, any>;
}
/**
 * An instruction to take the a set of non-fungible ids of a given resource address from the worktop
 * and put it in a bucket.
 */
export declare class TakeNonFungiblesFromWorktop extends Instruction {
    resourceAddress: ManifestAstValue.Address;
    ids: Array<ManifestAstValue.NonFungibleLocalId>;
    intoBucket: ManifestAstValue.Bucket;
    constructor(resourceAddress: ManifestAstValue.Address, ids: Array<ManifestAstValue.NonFungibleLocalId>, intoBucket: ManifestAstValue.Bucket);
    toString(): string;
    toObject(): Record<string, any>;
}
/**
 * Returns a bucket of tokens to the worktop.
 */
export declare class ReturnToWorktop extends Instruction {
    bucket: ManifestAstValue.Bucket;
    constructor(bucket: ManifestAstValue.Bucket);
    toString(): string;
    toObject(): Record<string, any>;
}
/**
 * An instruction to assert that a specific amount of a specific resource address exists in the
 * worktop.
 */
export declare class AssertWorktopContains extends Instruction {
    resourceAddress: ManifestAstValue.Address;
    amount: ManifestAstValue.Decimal;
    constructor(resourceAddress: ManifestAstValue.Address, amount: ManifestAstValue.Decimal);
    toString(): string;
    toObject(): Record<string, any>;
}
export declare class AssertWorktopContainsAny extends Instruction {
    resourceAddress: ManifestAstValue.Address;
    constructor(resourceAddress: ManifestAstValue.Address);
    toString(): string;
    toObject(): Record<string, any>;
}
/**
 * An instruction to assert that a set ids of a specific resource address exists in the worktop.
 */
export declare class AssertWorktopContainsNonFungibles extends Instruction {
    resourceAddress: ManifestAstValue.Address;
    ids: Array<ManifestAstValue.NonFungibleLocalId>;
    constructor(resourceAddress: ManifestAstValue.Address, ids: Array<ManifestAstValue.NonFungibleLocalId>);
    toString(): string;
    toObject(): Record<string, any>;
}
/**
 * An instruction which pops a proof from the AuthZone stack and into an identifiable proof
 */
export declare class PopFromAuthZone extends Instruction {
    intoProof: ManifestAstValue.Proof;
    constructor(intoProof: ManifestAstValue.Proof);
    toString(): string;
    toObject(): Record<string, any>;
}
/**
 * An instruction that pushes a proof to the auth zone stack.
 */
export declare class PushToAuthZone extends Instruction {
    proof: ManifestAstValue.Proof;
    constructor(proof: ManifestAstValue.Proof);
    toString(): string;
    toObject(): Record<string, any>;
}
/**
 * An instruction which clears the auth zone stack by dropping all of the proofs in that stack.
 */
export declare class ClearAuthZone extends Instruction {
    constructor();
    toString(): string;
    toObject(): Record<string, any>;
}
/**
 * Clears all the proofs of signature virtual badges.
 */
export declare class ClearSignatureProofs extends Instruction {
    constructor();
    toString(): string;
    toObject(): Record<string, any>;
}
/**
 * An instruction to create a proof of the entire amount of a given resource address from the auth
 * zone.
 */
export declare class CreateProofFromAuthZoneOfAll extends Instruction {
    resourceAddress: ManifestAstValue.Address;
    intoProof: ManifestAstValue.Proof;
    constructor(resourceAddress: ManifestAstValue.Address, intoProof: ManifestAstValue.Proof);
    toString(): string;
    toObject(): Record<string, any>;
}
/**
 * An instruction to create a proof of the an amount of a given resource address from the auth zone.
 */
export declare class CreateProofFromAuthZoneOfAmount extends Instruction {
    resourceAddress: ManifestAstValue.Address;
    amount: ManifestAstValue.Decimal;
    intoProof: ManifestAstValue.Proof;
    constructor(resourceAddress: ManifestAstValue.Address, amount: ManifestAstValue.Decimal, intoProof: ManifestAstValue.Proof);
    toString(): string;
    toObject(): Record<string, any>;
}
/**
 * An instruction to create a proof of the a set of non-fungible ids of a given resource address
 * from the auth zone.
 */
export declare class CreateProofFromAuthZoneOfNonFungibles extends Instruction {
    resourceAddress: ManifestAstValue.Address;
    ids: Array<ManifestAstValue.NonFungibleLocalId>;
    intoProof: ManifestAstValue.Proof;
    constructor(resourceAddress: ManifestAstValue.Address, ids: Array<ManifestAstValue.NonFungibleLocalId>, intoProof: ManifestAstValue.Proof);
    toString(): string;
    toObject(): Record<string, any>;
}
/**
 * An instruction to create a proof of the an amount from a bucket.
 */
export declare class CreateProofFromBucketOfAmount extends Instruction {
    bucket: ManifestAstValue.Bucket;
    amount: ManifestAstValue.Decimal;
    intoProof: ManifestAstValue.Proof;
    constructor(bucket: ManifestAstValue.Bucket, amount: ManifestAstValue.Decimal, intoProof: ManifestAstValue.Proof);
    toString(): string;
    toObject(): Record<string, any>;
}
/**
 * An instruction to create a proof of the a set of non-fungible ids
 * from a bucket.
 */
export declare class CreateProofFromBucketOfNonFungibles extends Instruction {
    bucket: ManifestAstValue.Bucket;
    ids: Array<ManifestAstValue.NonFungibleLocalId>;
    intoProof: ManifestAstValue.Proof;
    constructor(bucket: ManifestAstValue.Bucket, ids: Array<ManifestAstValue.NonFungibleLocalId>, intoProof: ManifestAstValue.Proof);
    toString(): string;
    toObject(): Record<string, any>;
}
/**
 * An instruction to create a proof given a bucket of some resources
 */
export declare class CreateProofFromBucket extends Instruction {
    bucket: ManifestAstValue.Bucket;
    intoProof: ManifestAstValue.Proof;
    constructor(bucket: ManifestAstValue.Bucket, intoProof: ManifestAstValue.Proof);
    toString(): string;
    toObject(): Record<string, any>;
}
/**
 * An instruction to clone a proof creating a second proof identical to the original
 */
export declare class CloneProof extends Instruction {
    proof: ManifestAstValue.Proof;
    intoProof: ManifestAstValue.Proof;
    constructor(proof: ManifestAstValue.Proof, intoProof: ManifestAstValue.Proof);
    toString(): string;
    toObject(): Record<string, any>;
}
/**
 * An instruction to drop a proof.
 */
export declare class DropProof extends Instruction {
    proof: ManifestAstValue.Proof;
    constructor(proof: ManifestAstValue.Proof);
    toString(): string;
    toObject(): Record<string, any>;
}
/**
 * An instruction to drop all proofs currently present in the transaction context.
 */
export declare class DropAllProofs extends Instruction {
    constructor();
    toString(): string;
    toObject(): Record<string, any>;
}
/**
 * An instruction to publish a package and set it's associated royalty configs, metadata, and access
 * rules.
 */
export declare class PublishPackage extends Instruction {
    code: ManifestAstValue.Blob;
    schema: ManifestAstValue.Bytes;
    metadata: ManifestAstValue.Map;
    constructor(code: ManifestAstValue.Blob, schema: ManifestAstValue.Bytes, metadata: ManifestAstValue.Map);
    toString(): string;
    toObject(): Record<string, any>;
}
/**
 * An instruction to publish a package and set it's associated royalty configs, metadata, and access
 * rules.
 */
export declare class PublishPackageAdvanced extends Instruction {
    address: ManifestAstValue.Enum;
    code: ManifestAstValue.Blob;
    schema: ManifestAstValue.Bytes;
    metadata: ManifestAstValue.Map;
    authorityRules: ManifestAstValue.Value;
    constructor(address: ManifestAstValue.Enum, code: ManifestAstValue.Blob, schema: ManifestAstValue.Bytes, metadata: ManifestAstValue.Map, authorityRules: ManifestAstValue.Value);
    toString(): string;
    toObject(): Record<string, any>;
}
/**
 * An instruction to burn a bucket of tokens.
 */
export declare class BurnResource extends Instruction {
    bucket: ManifestAstValue.Bucket;
    constructor(bucket: ManifestAstValue.Bucket);
    toString(): string;
    toObject(): Record<string, any>;
}
/**
 * An instruction ot recall resources from a known vault.
 */
export declare class RecallFromVault extends Instruction {
    vaultId: ManifestAstValue.Address;
    amount: ManifestAstValue.Decimal;
    constructor(vaultId: ManifestAstValue.Address, amount: ManifestAstValue.Decimal);
    toString(): string;
    toObject(): Record<string, any>;
}
export declare class FreezeVault extends Instruction {
    vaultId: ManifestAstValue.Address;
    args: Array<ManifestAstValue.Value>;
    constructor(vaultId: ManifestAstValue.Address, args: Array<ManifestAstValue.Value>);
    toString(): string;
    toObject(): Record<string, any>;
}
export declare class RecallNonFungiblesFromVault extends Instruction {
    vaultId: ManifestAstValue.Address;
    args: Array<ManifestAstValue.Value>;
    constructor(vaultId: ManifestAstValue.Address, args: Array<ManifestAstValue.Value>);
    toString(): string;
    toObject(): Record<string, any>;
}
export declare class UnfreezeVault extends Instruction {
    vaultId: ManifestAstValue.Address;
    args: Array<ManifestAstValue.Value>;
    constructor(vaultId: ManifestAstValue.Address, args: Array<ManifestAstValue.Value>);
    toString(): string;
    toObject(): Record<string, any>;
}
export declare class UpdateRole extends Instruction {
    address: ManifestAstValue.Address;
    args: Array<ManifestAstValue.Value>;
    constructor(address: ManifestAstValue.Address, args: Array<ManifestAstValue.Value>);
    toString(): string;
    toObject(): Record<string, any>;
}
/**
 * An instruction to set the metadata on an entity.
 */
export declare class SetMetadata extends Instruction {
    entityAddress: ManifestAstValue.Address;
    key: ManifestAstValue.String;
    value: ManifestAstValue.Enum;
    constructor(entityAddress: ManifestAstValue.Address, key: ManifestAstValue.String, value: ManifestAstValue.Enum);
    toString(): string;
    toObject(): Record<string, any>;
}
/**
 * An instruction to set the metadata on an entity.
 */
export declare class RemoveMetadata extends Instruction {
    entityAddress: ManifestAstValue.Address;
    key: ManifestAstValue.String;
    constructor(entityAddress: ManifestAstValue.Address, key: ManifestAstValue.String);
    toString(): string;
    toObject(): Record<string, any>;
}
/**
 * An instruction to modify the royalties on a component
 */
export declare class SetComponentRoyaltyConfig extends Instruction {
    componentAddress: ManifestAstValue.Address;
    methodName: ManifestAstValue.String;
    royaltyConfig: ManifestAstValue.Tuple;
    constructor(componentAddress: ManifestAstValue.Address, methodName: ManifestAstValue.String, royaltyConfig: ManifestAstValue.Tuple);
    toString(): string;
    toObject(): Record<string, any>;
}
/**
 * An instruction to claim royalties of a package
 */
export declare class ClaimPackageRoyalty extends Instruction {
    packageAddress: ManifestAstValue.Address;
    constructor(packageAddress: ManifestAstValue.Address);
    toString(): string;
    toObject(): Record<string, any>;
}
/**
 * An instruction to claim royalties of a component
 */
export declare class ClaimComponentRoyalty extends Instruction {
    componentAddress: ManifestAstValue.Address;
    constructor(componentAddress: ManifestAstValue.Address);
    toString(): string;
    toObject(): Record<string, any>;
}
/**
 * An instruction to mint fungible resources
 */
export declare class MintFungible extends Instruction {
    resourceAddress: ManifestAstValue.Address;
    amount: ManifestAstValue.Decimal;
    constructor(resourceAddress: ManifestAstValue.Address, amount: ManifestAstValue.Decimal);
    toString(): string;
    toObject(): Record<string, any>;
}
/**
 * An instruction to mint non-fungibles of a resource
 */
export declare class MintNonFungible extends Instruction {
    resourceAddress: ManifestAstValue.Address;
    entries: ManifestAstValue.Map;
    constructor(resourceAddress: ManifestAstValue.Address, entries: ManifestAstValue.Map);
    toString(): string;
    toObject(): Record<string, any>;
}
/**
 * An instruction to mint non-fungibles of a non-fungible resource that uses UUID as the type id and
 * perform auto incrimination of ID.
 */
export declare class MintUuidNonFungible extends Instruction {
    resourceAddress: ManifestAstValue.Address;
    entries: ManifestAstValue.Array;
    constructor(resourceAddress: ManifestAstValue.Address, entries: ManifestAstValue.Array);
    toString(): string;
    toObject(): Record<string, any>;
}
/**
 * An instruction to create a new fungible resource.
 */
export declare class CreateFungibleResource extends Instruction {
    isSupplyTracked: ManifestAstValue.Bool;
    divisibility: ManifestAstValue.U8;
    metadata: ManifestAstValue.Map;
    accessRules: ManifestAstValue.Map;
    constructor(isSupplyTracked: ManifestAstValue.Bool, divisibility: ManifestAstValue.U8, metadata: ManifestAstValue.Map, accessRules: ManifestAstValue.Map);
    toString(): string;
    toObject(): Record<string, any>;
}
/**
 * An instruction to create a fungible resource with initial supply
 */
export declare class CreateFungibleResourceWithInitialSupply extends Instruction {
    isSupplyTracked: ManifestAstValue.Bool;
    divisibility: ManifestAstValue.U8;
    metadata: ManifestAstValue.Map;
    accessRules: ManifestAstValue.Map;
    initialSupply: ManifestAstValue.Decimal;
    constructor(isSupplyTracked: ManifestAstValue.Bool, divisibility: ManifestAstValue.U8, metadata: ManifestAstValue.Map, accessRules: ManifestAstValue.Map, initialSupply: ManifestAstValue.Decimal);
    toString(): string;
    toObject(): Record<string, any>;
}
/**
 * An instruction to create a new non-fungible resource.
 */
export declare class CreateNonFungibleResource extends Instruction {
    isSupplyTracked: ManifestAstValue.Bool;
    idType: ManifestAstValue.Enum;
    schema: ManifestAstValue.Tuple;
    metadata: ManifestAstValue.Map;
    accessRules: ManifestAstValue.Map;
    constructor(isSupplyTracked: ManifestAstValue.Bool, idType: ManifestAstValue.Enum, schema: ManifestAstValue.Tuple, metadata: ManifestAstValue.Map, accessRules: ManifestAstValue.Map);
    toString(): string;
    toObject(): Record<string, any>;
}
/**
 * An instruction to create a non-fungible resource with an initial supply
 */
export declare class CreateNonFungibleResourceWithInitialSupply extends Instruction {
    isSupplyTracked: ManifestAstValue.Bool;
    idType: ManifestAstValue.Enum;
    schema: ManifestAstValue.Tuple;
    metadata: ManifestAstValue.Map;
    accessRules: ManifestAstValue.Map;
    initialSupply: ManifestAstValue.Value;
    constructor(isSupplyTracked: ManifestAstValue.Bool, idType: ManifestAstValue.Enum, schema: ManifestAstValue.Tuple, metadata: ManifestAstValue.Map, accessRules: ManifestAstValue.Map, initialSupply: ManifestAstValue.Value);
    toString(): string;
    toObject(): Record<string, any>;
}
/**
 * Creates a new access controller native component with the passed set of rules as the current
 * active rule set and the specified timed recovery delay in minutes.
 */
export declare class CreateAccessController extends Instruction {
    controlledAsset: ManifestAstValue.Bucket;
    ruleSet: ManifestAstValue.Tuple;
    timedRecoveryDelayInMinutes: ManifestAstValue.Some | ManifestAstValue.None | ManifestAstValue.Enum;
    /**
     * The set of rules to use for the access controller's primary, confirmation, and recovery roles.
     */
    /**
     * The set of rules to use for the access controller's primary, confirmation, and recovery roles.
     */
    constructor(controlledAsset: ManifestAstValue.Bucket, ruleSet: ManifestAstValue.Tuple, timedRecoveryDelayInMinutes: ManifestAstValue.Some | ManifestAstValue.None | ManifestAstValue.Enum);
    toString(): string;
    toObject(): Record<string, any>;
}
/**
 * Creates a new identity native component with the passed access rule.
 */
export declare class CreateIdentity extends Instruction {
    constructor();
    toString(): string;
    toObject(): Record<string, any>;
}
/**
 * Creates a new identity native component with the passed access rule.
 */
export declare class CreateIdentityAdvanced extends Instruction {
    config: ManifestAstValue.Tuple;
    constructor(config: ManifestAstValue.Tuple);
    toString(): string;
    toObject(): Record<string, any>;
}
/**
 * Creates a validator given the public key of the owner who controls it
 */
export declare class CreateValidator extends Instruction {
    key: ManifestAstValue.Bytes;
    feeFactor: ManifestAstValue.Decimal;
    constructor(key: ManifestAstValue.Bytes, feeFactor: ManifestAstValue.Decimal);
    toString(): string;
    toObject(): Record<string, any>;
}
/**
 * Creates a new global account component which has the withdraw rule seen in the rule.
 */
export declare class CreateAccount extends Instruction {
    constructor();
    toString(): string;
    toObject(): Record<string, any>;
}
/**
 * Creates a new global account component which has the withdraw rule seen in the rule.
 */
export declare class CreateAccountAdvanced extends Instruction {
    config: ManifestAstValue.Tuple;
    constructor(config: ManifestAstValue.Tuple);
    toString(): string;
    toObject(): Record<string, any>;
}
export declare class AllocateGlobalAddress extends Instruction {
    packageAddress: ManifestAstValue.Address;
    blueprintName: ManifestAstValue.String;
    addressReservation: ManifestAstValue.AddressReservation;
    namedAddress: ManifestAstValue.NamedAddress;
    constructor(packageAddress: ManifestAstValue.Address, blueprintName: ManifestAstValue.String, addressReservation: ManifestAstValue.AddressReservation, namedAddress: ManifestAstValue.NamedAddress);
    toString(): string;
    toObject(): Record<string, any>;
}
