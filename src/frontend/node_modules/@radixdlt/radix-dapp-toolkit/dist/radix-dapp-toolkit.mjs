var Pa = function(e, t) {
  return Pa = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n, r) {
    n.__proto__ = r;
  } || function(n, r) {
    for (var a in r)
      Object.prototype.hasOwnProperty.call(r, a) && (n[a] = r[a]);
  }, Pa(e, t);
};
function ot(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
  Pa(e, t);
  function n() {
    this.constructor = e;
  }
  e.prototype = t === null ? Object.create(t) : (n.prototype = t.prototype, new n());
}
function ml(e, t, n, r) {
  function a(s) {
    return s instanceof n ? s : new n(function(i) {
      i(s);
    });
  }
  return new (n || (n = Promise))(function(s, i) {
    function o(d) {
      try {
        u(r.next(d));
      } catch (h) {
        i(h);
      }
    }
    function c(d) {
      try {
        u(r.throw(d));
      } catch (h) {
        i(h);
      }
    }
    function u(d) {
      d.done ? s(d.value) : a(d.value).then(o, c);
    }
    u((r = r.apply(e, t || [])).next());
  });
}
function co(e, t) {
  var n = { label: 0, sent: function() {
    if (s[0] & 1)
      throw s[1];
    return s[1];
  }, trys: [], ops: [] }, r, a, s, i;
  return i = { next: o(0), throw: o(1), return: o(2) }, typeof Symbol == "function" && (i[Symbol.iterator] = function() {
    return this;
  }), i;
  function o(u) {
    return function(d) {
      return c([u, d]);
    };
  }
  function c(u) {
    if (r)
      throw new TypeError("Generator is already executing.");
    for (; i && (i = 0, u[0] && (n = 0)), n; )
      try {
        if (r = 1, a && (s = u[0] & 2 ? a.return : u[0] ? a.throw || ((s = a.return) && s.call(a), 0) : a.next) && !(s = s.call(a, u[1])).done)
          return s;
        switch (a = 0, s && (u = [u[0] & 2, s.value]), u[0]) {
          case 0:
          case 1:
            s = u;
            break;
          case 4:
            return n.label++, { value: u[1], done: !1 };
          case 5:
            n.label++, a = u[1], u = [0];
            continue;
          case 7:
            u = n.ops.pop(), n.trys.pop();
            continue;
          default:
            if (s = n.trys, !(s = s.length > 0 && s[s.length - 1]) && (u[0] === 6 || u[0] === 2)) {
              n = 0;
              continue;
            }
            if (u[0] === 3 && (!s || u[1] > s[0] && u[1] < s[3])) {
              n.label = u[1];
              break;
            }
            if (u[0] === 6 && n.label < s[1]) {
              n.label = s[1], s = u;
              break;
            }
            if (s && n.label < s[2]) {
              n.label = s[2], n.ops.push(u);
              break;
            }
            s[2] && n.ops.pop(), n.trys.pop();
            continue;
        }
        u = t.call(e, n);
      } catch (d) {
        u = [6, d], a = 0;
      } finally {
        r = s = 0;
      }
    if (u[0] & 5)
      throw u[1];
    return { value: u[0] ? u[1] : void 0, done: !0 };
  }
}
function vn(e) {
  var t = typeof Symbol == "function" && Symbol.iterator, n = t && e[t], r = 0;
  if (n)
    return n.call(e);
  if (e && typeof e.length == "number")
    return {
      next: function() {
        return e && r >= e.length && (e = void 0), { value: e && e[r++], done: !e };
      }
    };
  throw new TypeError(t ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function st(e, t) {
  var n = typeof Symbol == "function" && e[Symbol.iterator];
  if (!n)
    return e;
  var r = n.call(e), a, s = [], i;
  try {
    for (; (t === void 0 || t-- > 0) && !(a = r.next()).done; )
      s.push(a.value);
  } catch (o) {
    i = { error: o };
  } finally {
    try {
      a && !a.done && (n = r.return) && n.call(r);
    } finally {
      if (i)
        throw i.error;
    }
  }
  return s;
}
function gt(e, t, n) {
  if (n || arguments.length === 2)
    for (var r = 0, a = t.length, s; r < a; r++)
      (s || !(r in t)) && (s || (s = Array.prototype.slice.call(t, 0, r)), s[r] = t[r]);
  return e.concat(s || Array.prototype.slice.call(t));
}
function pn(e) {
  return this instanceof pn ? (this.v = e, this) : new pn(e);
}
function yl(e, t, n) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var r = n.apply(e, t || []), a, s = [];
  return a = {}, i("next"), i("throw"), i("return"), a[Symbol.asyncIterator] = function() {
    return this;
  }, a;
  function i(p) {
    r[p] && (a[p] = function(v) {
      return new Promise(function(T, g) {
        s.push([p, v, T, g]) > 1 || o(p, v);
      });
    });
  }
  function o(p, v) {
    try {
      c(r[p](v));
    } catch (T) {
      h(s[0][3], T);
    }
  }
  function c(p) {
    p.value instanceof pn ? Promise.resolve(p.value.v).then(u, d) : h(s[0][2], p);
  }
  function u(p) {
    o("next", p);
  }
  function d(p) {
    o("throw", p);
  }
  function h(p, v) {
    p(v), s.shift(), s.length && o(s[0][0], s[0][1]);
  }
}
function vl(e) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var t = e[Symbol.asyncIterator], n;
  return t ? t.call(e) : (e = typeof vn == "function" ? vn(e) : e[Symbol.iterator](), n = {}, r("next"), r("throw"), r("return"), n[Symbol.asyncIterator] = function() {
    return this;
  }, n);
  function r(s) {
    n[s] = e[s] && function(i) {
      return new Promise(function(o, c) {
        i = e[s](i), a(o, c, i.done, i.value);
      });
    };
  }
  function a(s, i, o, c) {
    Promise.resolve(c).then(function(u) {
      s({ value: u, done: o });
    }, i);
  }
}
function ee(e) {
  return typeof e == "function";
}
function xs(e) {
  var t = function(r) {
    Error.call(r), r.stack = new Error().stack;
  }, n = e(t);
  return n.prototype = Object.create(Error.prototype), n.prototype.constructor = n, n;
}
var ca = xs(function(e) {
  return function(n) {
    e(this), this.message = n ? n.length + ` errors occurred during unsubscription:
` + n.map(function(r, a) {
      return a + 1 + ") " + r.toString();
    }).join(`
  `) : "", this.name = "UnsubscriptionError", this.errors = n;
  };
});
function pr(e, t) {
  if (e) {
    var n = e.indexOf(t);
    0 <= n && e.splice(n, 1);
  }
}
var ut = function() {
  function e(t) {
    this.initialTeardown = t, this.closed = !1, this._parentage = null, this._finalizers = null;
  }
  return e.prototype.unsubscribe = function() {
    var t, n, r, a, s;
    if (!this.closed) {
      this.closed = !0;
      var i = this._parentage;
      if (i)
        if (this._parentage = null, Array.isArray(i))
          try {
            for (var o = vn(i), c = o.next(); !c.done; c = o.next()) {
              var u = c.value;
              u.remove(this);
            }
          } catch (g) {
            t = { error: g };
          } finally {
            try {
              c && !c.done && (n = o.return) && n.call(o);
            } finally {
              if (t)
                throw t.error;
            }
          }
        else
          i.remove(this);
      var d = this.initialTeardown;
      if (ee(d))
        try {
          d();
        } catch (g) {
          s = g instanceof ca ? g.errors : [g];
        }
      var h = this._finalizers;
      if (h) {
        this._finalizers = null;
        try {
          for (var p = vn(h), v = p.next(); !v.done; v = p.next()) {
            var T = v.value;
            try {
              fi(T);
            } catch (g) {
              s = s ?? [], g instanceof ca ? s = gt(gt([], st(s)), st(g.errors)) : s.push(g);
            }
          }
        } catch (g) {
          r = { error: g };
        } finally {
          try {
            v && !v.done && (a = p.return) && a.call(p);
          } finally {
            if (r)
              throw r.error;
          }
        }
      }
      if (s)
        throw new ca(s);
    }
  }, e.prototype.add = function(t) {
    var n;
    if (t && t !== this)
      if (this.closed)
        fi(t);
      else {
        if (t instanceof e) {
          if (t.closed || t._hasParent(this))
            return;
          t._addParent(this);
        }
        (this._finalizers = (n = this._finalizers) !== null && n !== void 0 ? n : []).push(t);
      }
  }, e.prototype._hasParent = function(t) {
    var n = this._parentage;
    return n === t || Array.isArray(n) && n.includes(t);
  }, e.prototype._addParent = function(t) {
    var n = this._parentage;
    this._parentage = Array.isArray(n) ? (n.push(t), n) : n ? [n, t] : t;
  }, e.prototype._removeParent = function(t) {
    var n = this._parentage;
    n === t ? this._parentage = null : Array.isArray(n) && pr(n, t);
  }, e.prototype.remove = function(t) {
    var n = this._finalizers;
    n && pr(n, t), t instanceof e && t._removeParent(this);
  }, e.EMPTY = function() {
    var t = new e();
    return t.closed = !0, t;
  }(), e;
}(), lo = ut.EMPTY;
function fo(e) {
  return e instanceof ut || e && "closed" in e && ee(e.remove) && ee(e.add) && ee(e.unsubscribe);
}
function fi(e) {
  ee(e) ? e() : e.unsubscribe();
}
var ho = {
  onUnhandledError: null,
  onStoppedNotification: null,
  Promise: void 0,
  useDeprecatedSynchronousErrorHandling: !1,
  useDeprecatedNextContext: !1
}, Oa = {
  setTimeout: function(e, t) {
    for (var n = [], r = 2; r < arguments.length; r++)
      n[r - 2] = arguments[r];
    var a = Oa.delegate;
    return a != null && a.setTimeout ? a.setTimeout.apply(a, gt([e, t], st(n))) : setTimeout.apply(void 0, gt([e, t], st(n)));
  },
  clearTimeout: function(e) {
    var t = Oa.delegate;
    return ((t == null ? void 0 : t.clearTimeout) || clearTimeout)(e);
  },
  delegate: void 0
};
function po(e) {
  Oa.setTimeout(function() {
    throw e;
  });
}
function Ea() {
}
function dr(e) {
  e();
}
var ks = function(e) {
  ot(t, e);
  function t(n) {
    var r = e.call(this) || this;
    return r.isStopped = !1, n ? (r.destination = n, fo(n) && n.add(r)) : r.destination = wl, r;
  }
  return t.create = function(n, r, a) {
    return new mr(n, r, a);
  }, t.prototype.next = function(n) {
    this.isStopped || this._next(n);
  }, t.prototype.error = function(n) {
    this.isStopped || (this.isStopped = !0, this._error(n));
  }, t.prototype.complete = function() {
    this.isStopped || (this.isStopped = !0, this._complete());
  }, t.prototype.unsubscribe = function() {
    this.closed || (this.isStopped = !0, e.prototype.unsubscribe.call(this), this.destination = null);
  }, t.prototype._next = function(n) {
    this.destination.next(n);
  }, t.prototype._error = function(n) {
    try {
      this.destination.error(n);
    } finally {
      this.unsubscribe();
    }
  }, t.prototype._complete = function() {
    try {
      this.destination.complete();
    } finally {
      this.unsubscribe();
    }
  }, t;
}(ut), gl = Function.prototype.bind;
function la(e, t) {
  return gl.call(e, t);
}
var _l = function() {
  function e(t) {
    this.partialObserver = t;
  }
  return e.prototype.next = function(t) {
    var n = this.partialObserver;
    if (n.next)
      try {
        n.next(t);
      } catch (r) {
        sr(r);
      }
  }, e.prototype.error = function(t) {
    var n = this.partialObserver;
    if (n.error)
      try {
        n.error(t);
      } catch (r) {
        sr(r);
      }
    else
      sr(t);
  }, e.prototype.complete = function() {
    var t = this.partialObserver;
    if (t.complete)
      try {
        t.complete();
      } catch (n) {
        sr(n);
      }
  }, e;
}(), mr = function(e) {
  ot(t, e);
  function t(n, r, a) {
    var s = e.call(this) || this, i;
    if (ee(n) || !n)
      i = {
        next: n ?? void 0,
        error: r ?? void 0,
        complete: a ?? void 0
      };
    else {
      var o;
      s && ho.useDeprecatedNextContext ? (o = Object.create(n), o.unsubscribe = function() {
        return s.unsubscribe();
      }, i = {
        next: n.next && la(n.next, o),
        error: n.error && la(n.error, o),
        complete: n.complete && la(n.complete, o)
      }) : i = n;
    }
    return s.destination = new _l(i), s;
  }
  return t;
}(ks);
function sr(e) {
  po(e);
}
function bl(e) {
  throw e;
}
var wl = {
  closed: !0,
  next: Ea,
  error: bl,
  complete: Ea
}, Ss = function() {
  return typeof Symbol == "function" && Symbol.observable || "@@observable";
}();
function sn(e) {
  return e;
}
function xl(e) {
  return e.length === 0 ? sn : e.length === 1 ? e[0] : function(n) {
    return e.reduce(function(r, a) {
      return a(r);
    }, n);
  };
}
var we = function() {
  function e(t) {
    t && (this._subscribe = t);
  }
  return e.prototype.lift = function(t) {
    var n = new e();
    return n.source = this, n.operator = t, n;
  }, e.prototype.subscribe = function(t, n, r) {
    var a = this, s = Sl(t) ? t : new mr(t, n, r);
    return dr(function() {
      var i = a, o = i.operator, c = i.source;
      s.add(o ? o.call(s, c) : c ? a._subscribe(s) : a._trySubscribe(s));
    }), s;
  }, e.prototype._trySubscribe = function(t) {
    try {
      return this._subscribe(t);
    } catch (n) {
      t.error(n);
    }
  }, e.prototype.forEach = function(t, n) {
    var r = this;
    return n = hi(n), new n(function(a, s) {
      var i = new mr({
        next: function(o) {
          try {
            t(o);
          } catch (c) {
            s(c), i.unsubscribe();
          }
        },
        error: s,
        complete: a
      });
      r.subscribe(i);
    });
  }, e.prototype._subscribe = function(t) {
    var n;
    return (n = this.source) === null || n === void 0 ? void 0 : n.subscribe(t);
  }, e.prototype[Ss] = function() {
    return this;
  }, e.prototype.pipe = function() {
    for (var t = [], n = 0; n < arguments.length; n++)
      t[n] = arguments[n];
    return xl(t)(this);
  }, e.prototype.toPromise = function(t) {
    var n = this;
    return t = hi(t), new t(function(r, a) {
      var s;
      n.subscribe(function(i) {
        return s = i;
      }, function(i) {
        return a(i);
      }, function() {
        return r(s);
      });
    });
  }, e.create = function(t) {
    return new e(t);
  }, e;
}();
function hi(e) {
  var t;
  return (t = e ?? ho.Promise) !== null && t !== void 0 ? t : Promise;
}
function kl(e) {
  return e && ee(e.next) && ee(e.error) && ee(e.complete);
}
function Sl(e) {
  return e && e instanceof ks || kl(e) && fo(e);
}
function Tl(e) {
  return ee(e == null ? void 0 : e.lift);
}
function ze(e) {
  return function(t) {
    if (Tl(t))
      return t.lift(function(n) {
        try {
          return e(n, this);
        } catch (r) {
          this.error(r);
        }
      });
    throw new TypeError("Unable to lift unknown Observable type");
  };
}
function xe(e, t, n, r, a) {
  return new Pl(e, t, n, r, a);
}
var Pl = function(e) {
  ot(t, e);
  function t(n, r, a, s, i, o) {
    var c = e.call(this, n) || this;
    return c.onFinalize = i, c.shouldUnsubscribe = o, c._next = r ? function(u) {
      try {
        r(u);
      } catch (d) {
        n.error(d);
      }
    } : e.prototype._next, c._error = s ? function(u) {
      try {
        s(u);
      } catch (d) {
        n.error(d);
      } finally {
        this.unsubscribe();
      }
    } : e.prototype._error, c._complete = a ? function() {
      try {
        a();
      } catch (u) {
        n.error(u);
      } finally {
        this.unsubscribe();
      }
    } : e.prototype._complete, c;
  }
  return t.prototype.unsubscribe = function() {
    var n;
    if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) {
      var r = this.closed;
      e.prototype.unsubscribe.call(this), !r && ((n = this.onFinalize) === null || n === void 0 || n.call(this));
    }
  }, t;
}(ks), Ol = xs(function(e) {
  return function() {
    e(this), this.name = "ObjectUnsubscribedError", this.message = "object unsubscribed";
  };
}), Ze = function(e) {
  ot(t, e);
  function t() {
    var n = e.call(this) || this;
    return n.closed = !1, n.currentObservers = null, n.observers = [], n.isStopped = !1, n.hasError = !1, n.thrownError = null, n;
  }
  return t.prototype.lift = function(n) {
    var r = new pi(this, this);
    return r.operator = n, r;
  }, t.prototype._throwIfClosed = function() {
    if (this.closed)
      throw new Ol();
  }, t.prototype.next = function(n) {
    var r = this;
    dr(function() {
      var a, s;
      if (r._throwIfClosed(), !r.isStopped) {
        r.currentObservers || (r.currentObservers = Array.from(r.observers));
        try {
          for (var i = vn(r.currentObservers), o = i.next(); !o.done; o = i.next()) {
            var c = o.value;
            c.next(n);
          }
        } catch (u) {
          a = { error: u };
        } finally {
          try {
            o && !o.done && (s = i.return) && s.call(i);
          } finally {
            if (a)
              throw a.error;
          }
        }
      }
    });
  }, t.prototype.error = function(n) {
    var r = this;
    dr(function() {
      if (r._throwIfClosed(), !r.isStopped) {
        r.hasError = r.isStopped = !0, r.thrownError = n;
        for (var a = r.observers; a.length; )
          a.shift().error(n);
      }
    });
  }, t.prototype.complete = function() {
    var n = this;
    dr(function() {
      if (n._throwIfClosed(), !n.isStopped) {
        n.isStopped = !0;
        for (var r = n.observers; r.length; )
          r.shift().complete();
      }
    });
  }, t.prototype.unsubscribe = function() {
    this.isStopped = this.closed = !0, this.observers = this.currentObservers = null;
  }, Object.defineProperty(t.prototype, "observed", {
    get: function() {
      var n;
      return ((n = this.observers) === null || n === void 0 ? void 0 : n.length) > 0;
    },
    enumerable: !1,
    configurable: !0
  }), t.prototype._trySubscribe = function(n) {
    return this._throwIfClosed(), e.prototype._trySubscribe.call(this, n);
  }, t.prototype._subscribe = function(n) {
    return this._throwIfClosed(), this._checkFinalizedStatuses(n), this._innerSubscribe(n);
  }, t.prototype._innerSubscribe = function(n) {
    var r = this, a = this, s = a.hasError, i = a.isStopped, o = a.observers;
    return s || i ? lo : (this.currentObservers = null, o.push(n), new ut(function() {
      r.currentObservers = null, pr(o, n);
    }));
  }, t.prototype._checkFinalizedStatuses = function(n) {
    var r = this, a = r.hasError, s = r.thrownError, i = r.isStopped;
    a ? n.error(s) : i && n.complete();
  }, t.prototype.asObservable = function() {
    var n = new we();
    return n.source = this, n;
  }, t.create = function(n, r) {
    return new pi(n, r);
  }, t;
}(we), pi = function(e) {
  ot(t, e);
  function t(n, r) {
    var a = e.call(this) || this;
    return a.destination = n, a.source = r, a;
  }
  return t.prototype.next = function(n) {
    var r, a;
    (a = (r = this.destination) === null || r === void 0 ? void 0 : r.next) === null || a === void 0 || a.call(r, n);
  }, t.prototype.error = function(n) {
    var r, a;
    (a = (r = this.destination) === null || r === void 0 ? void 0 : r.error) === null || a === void 0 || a.call(r, n);
  }, t.prototype.complete = function() {
    var n, r;
    (r = (n = this.destination) === null || n === void 0 ? void 0 : n.complete) === null || r === void 0 || r.call(n);
  }, t.prototype._subscribe = function(n) {
    var r, a;
    return (a = (r = this.source) === null || r === void 0 ? void 0 : r.subscribe(n)) !== null && a !== void 0 ? a : lo;
  }, t;
}(Ze), se = function(e) {
  ot(t, e);
  function t(n) {
    var r = e.call(this) || this;
    return r._value = n, r;
  }
  return Object.defineProperty(t.prototype, "value", {
    get: function() {
      return this.getValue();
    },
    enumerable: !1,
    configurable: !0
  }), t.prototype._subscribe = function(n) {
    var r = e.prototype._subscribe.call(this, n);
    return !r.closed && n.next(this._value), r;
  }, t.prototype.getValue = function() {
    var n = this, r = n.hasError, a = n.thrownError, s = n._value;
    if (r)
      throw a;
    return this._throwIfClosed(), s;
  }, t.prototype.next = function(n) {
    e.prototype.next.call(this, this._value = n);
  }, t;
}(Ze), Ts = {
  now: function() {
    return (Ts.delegate || Date).now();
  },
  delegate: void 0
}, El = function(e) {
  ot(t, e);
  function t(n, r, a) {
    n === void 0 && (n = 1 / 0), r === void 0 && (r = 1 / 0), a === void 0 && (a = Ts);
    var s = e.call(this) || this;
    return s._bufferSize = n, s._windowTime = r, s._timestampProvider = a, s._buffer = [], s._infiniteTimeWindow = !0, s._infiniteTimeWindow = r === 1 / 0, s._bufferSize = Math.max(1, n), s._windowTime = Math.max(1, r), s;
  }
  return t.prototype.next = function(n) {
    var r = this, a = r.isStopped, s = r._buffer, i = r._infiniteTimeWindow, o = r._timestampProvider, c = r._windowTime;
    a || (s.push(n), !i && s.push(o.now() + c)), this._trimBuffer(), e.prototype.next.call(this, n);
  }, t.prototype._subscribe = function(n) {
    this._throwIfClosed(), this._trimBuffer();
    for (var r = this._innerSubscribe(n), a = this, s = a._infiniteTimeWindow, i = a._buffer, o = i.slice(), c = 0; c < o.length && !n.closed; c += s ? 1 : 2)
      n.next(o[c]);
    return this._checkFinalizedStatuses(n), r;
  }, t.prototype._trimBuffer = function() {
    var n = this, r = n._bufferSize, a = n._timestampProvider, s = n._buffer, i = n._infiniteTimeWindow, o = (i ? 1 : 2) * r;
    if (r < 1 / 0 && o < s.length && s.splice(0, s.length - o), !i) {
      for (var c = a.now(), u = 0, d = 1; d < s.length && s[d] <= c; d += 2)
        u = d;
      u && s.splice(0, u + 1);
    }
  }, t;
}(Ze), Cl = function(e) {
  ot(t, e);
  function t(n, r) {
    return e.call(this) || this;
  }
  return t.prototype.schedule = function(n, r) {
    return this;
  }, t;
}(ut), yr = {
  setInterval: function(e, t) {
    for (var n = [], r = 2; r < arguments.length; r++)
      n[r - 2] = arguments[r];
    var a = yr.delegate;
    return a != null && a.setInterval ? a.setInterval.apply(a, gt([e, t], st(n))) : setInterval.apply(void 0, gt([e, t], st(n)));
  },
  clearInterval: function(e) {
    var t = yr.delegate;
    return ((t == null ? void 0 : t.clearInterval) || clearInterval)(e);
  },
  delegate: void 0
}, Al = function(e) {
  ot(t, e);
  function t(n, r) {
    var a = e.call(this, n, r) || this;
    return a.scheduler = n, a.work = r, a.pending = !1, a;
  }
  return t.prototype.schedule = function(n, r) {
    var a;
    if (r === void 0 && (r = 0), this.closed)
      return this;
    this.state = n;
    var s = this.id, i = this.scheduler;
    return s != null && (this.id = this.recycleAsyncId(i, s, r)), this.pending = !0, this.delay = r, this.id = (a = this.id) !== null && a !== void 0 ? a : this.requestAsyncId(i, this.id, r), this;
  }, t.prototype.requestAsyncId = function(n, r, a) {
    return a === void 0 && (a = 0), yr.setInterval(n.flush.bind(n, this), a);
  }, t.prototype.recycleAsyncId = function(n, r, a) {
    if (a === void 0 && (a = 0), a != null && this.delay === a && this.pending === !1)
      return r;
    r != null && yr.clearInterval(r);
  }, t.prototype.execute = function(n, r) {
    if (this.closed)
      return new Error("executing a cancelled action");
    this.pending = !1;
    var a = this._execute(n, r);
    if (a)
      return a;
    this.pending === !1 && this.id != null && (this.id = this.recycleAsyncId(this.scheduler, this.id, null));
  }, t.prototype._execute = function(n, r) {
    var a = !1, s;
    try {
      this.work(n);
    } catch (i) {
      a = !0, s = i || new Error("Scheduled action threw falsy error");
    }
    if (a)
      return this.unsubscribe(), s;
  }, t.prototype.unsubscribe = function() {
    if (!this.closed) {
      var n = this, r = n.id, a = n.scheduler, s = a.actions;
      this.work = this.state = this.scheduler = null, this.pending = !1, pr(s, this), r != null && (this.id = this.recycleAsyncId(a, r, null)), this.delay = null, e.prototype.unsubscribe.call(this);
    }
  }, t;
}(Cl), mi = function() {
  function e(t, n) {
    n === void 0 && (n = e.now), this.schedulerActionCtor = t, this.now = n;
  }
  return e.prototype.schedule = function(t, n, r) {
    return n === void 0 && (n = 0), new this.schedulerActionCtor(this, t).schedule(r, n);
  }, e.now = Ts.now, e;
}(), Il = function(e) {
  ot(t, e);
  function t(n, r) {
    r === void 0 && (r = mi.now);
    var a = e.call(this, n, r) || this;
    return a.actions = [], a._active = !1, a;
  }
  return t.prototype.flush = function(n) {
    var r = this.actions;
    if (this._active) {
      r.push(n);
      return;
    }
    var a;
    this._active = !0;
    do
      if (a = n.execute(n.state, n.delay))
        break;
    while (n = r.shift());
    if (this._active = !1, a) {
      for (; n = r.shift(); )
        n.unsubscribe();
      throw a;
    }
  }, t;
}(mi), mo = new Il(Al), Rl = mo, yo = new we(function(e) {
  return e.complete();
});
function vo(e) {
  return e && ee(e.schedule);
}
function Ps(e) {
  return e[e.length - 1];
}
function go(e) {
  return ee(Ps(e)) ? e.pop() : void 0;
}
function Os(e) {
  return vo(Ps(e)) ? e.pop() : void 0;
}
function Nl(e, t) {
  return typeof Ps(e) == "number" ? e.pop() : t;
}
var Es = function(e) {
  return e && typeof e.length == "number" && typeof e != "function";
};
function _o(e) {
  return ee(e == null ? void 0 : e.then);
}
function bo(e) {
  return ee(e[Ss]);
}
function wo(e) {
  return Symbol.asyncIterator && ee(e == null ? void 0 : e[Symbol.asyncIterator]);
}
function xo(e) {
  return new TypeError("You provided " + (e !== null && typeof e == "object" ? "an invalid object" : "'" + e + "'") + " where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.");
}
function Dl() {
  return typeof Symbol != "function" || !Symbol.iterator ? "@@iterator" : Symbol.iterator;
}
var ko = Dl();
function So(e) {
  return ee(e == null ? void 0 : e[ko]);
}
function To(e) {
  return yl(this, arguments, function() {
    var n, r, a, s;
    return co(this, function(i) {
      switch (i.label) {
        case 0:
          n = e.getReader(), i.label = 1;
        case 1:
          i.trys.push([1, , 9, 10]), i.label = 2;
        case 2:
          return [4, pn(n.read())];
        case 3:
          return r = i.sent(), a = r.value, s = r.done, s ? [4, pn(void 0)] : [3, 5];
        case 4:
          return [2, i.sent()];
        case 5:
          return [4, pn(a)];
        case 6:
          return [4, i.sent()];
        case 7:
          return i.sent(), [3, 2];
        case 8:
          return [3, 10];
        case 9:
          return n.releaseLock(), [7];
        case 10:
          return [2];
      }
    });
  });
}
function Po(e) {
  return ee(e == null ? void 0 : e.getReader);
}
function xt(e) {
  if (e instanceof we)
    return e;
  if (e != null) {
    if (bo(e))
      return jl(e);
    if (Es(e))
      return ql(e);
    if (_o(e))
      return $l(e);
    if (wo(e))
      return Oo(e);
    if (So(e))
      return Ll(e);
    if (Po(e))
      return Ml(e);
  }
  throw xo(e);
}
function jl(e) {
  return new we(function(t) {
    var n = e[Ss]();
    if (ee(n.subscribe))
      return n.subscribe(t);
    throw new TypeError("Provided object does not correctly implement Symbol.observable");
  });
}
function ql(e) {
  return new we(function(t) {
    for (var n = 0; n < e.length && !t.closed; n++)
      t.next(e[n]);
    t.complete();
  });
}
function $l(e) {
  return new we(function(t) {
    e.then(function(n) {
      t.closed || (t.next(n), t.complete());
    }, function(n) {
      return t.error(n);
    }).then(null, po);
  });
}
function Ll(e) {
  return new we(function(t) {
    var n, r;
    try {
      for (var a = vn(e), s = a.next(); !s.done; s = a.next()) {
        var i = s.value;
        if (t.next(i), t.closed)
          return;
      }
    } catch (o) {
      n = { error: o };
    } finally {
      try {
        s && !s.done && (r = a.return) && r.call(a);
      } finally {
        if (n)
          throw n.error;
      }
    }
    t.complete();
  });
}
function Oo(e) {
  return new we(function(t) {
    Zl(e, t).catch(function(n) {
      return t.error(n);
    });
  });
}
function Ml(e) {
  return Oo(To(e));
}
function Zl(e, t) {
  var n, r, a, s;
  return ml(this, void 0, void 0, function() {
    var i, o;
    return co(this, function(c) {
      switch (c.label) {
        case 0:
          c.trys.push([0, 5, 6, 11]), n = vl(e), c.label = 1;
        case 1:
          return [4, n.next()];
        case 2:
          if (r = c.sent(), !!r.done)
            return [3, 4];
          if (i = r.value, t.next(i), t.closed)
            return [2];
          c.label = 3;
        case 3:
          return [3, 1];
        case 4:
          return [3, 11];
        case 5:
          return o = c.sent(), a = { error: o }, [3, 11];
        case 6:
          return c.trys.push([6, , 9, 10]), r && !r.done && (s = n.return) ? [4, s.call(n)] : [3, 8];
        case 7:
          c.sent(), c.label = 8;
        case 8:
          return [3, 10];
        case 9:
          if (a)
            throw a.error;
          return [7];
        case 10:
          return [7];
        case 11:
          return t.complete(), [2];
      }
    });
  });
}
function mt(e, t, n, r, a) {
  r === void 0 && (r = 0), a === void 0 && (a = !1);
  var s = t.schedule(function() {
    n(), a ? e.add(this.schedule(null, r)) : this.unsubscribe();
  }, r);
  if (e.add(s), !a)
    return s;
}
function Eo(e, t) {
  return t === void 0 && (t = 0), ze(function(n, r) {
    n.subscribe(xe(r, function(a) {
      return mt(r, e, function() {
        return r.next(a);
      }, t);
    }, function() {
      return mt(r, e, function() {
        return r.complete();
      }, t);
    }, function(a) {
      return mt(r, e, function() {
        return r.error(a);
      }, t);
    }));
  });
}
function Co(e, t) {
  return t === void 0 && (t = 0), ze(function(n, r) {
    r.add(e.schedule(function() {
      return n.subscribe(r);
    }, t));
  });
}
function Fl(e, t) {
  return xt(e).pipe(Co(t), Eo(t));
}
function zl(e, t) {
  return xt(e).pipe(Co(t), Eo(t));
}
function Ul(e, t) {
  return new we(function(n) {
    var r = 0;
    return t.schedule(function() {
      r === e.length ? n.complete() : (n.next(e[r++]), n.closed || this.schedule());
    });
  });
}
function Vl(e, t) {
  return new we(function(n) {
    var r;
    return mt(n, t, function() {
      r = e[ko](), mt(n, t, function() {
        var a, s, i;
        try {
          a = r.next(), s = a.value, i = a.done;
        } catch (o) {
          n.error(o);
          return;
        }
        i ? n.complete() : n.next(s);
      }, 0, !0);
    }), function() {
      return ee(r == null ? void 0 : r.return) && r.return();
    };
  });
}
function Ao(e, t) {
  if (!e)
    throw new Error("Iterable cannot be null");
  return new we(function(n) {
    mt(n, t, function() {
      var r = e[Symbol.asyncIterator]();
      mt(n, t, function() {
        r.next().then(function(a) {
          a.done ? n.complete() : n.next(a.value);
        });
      }, 0, !0);
    });
  });
}
function Wl(e, t) {
  return Ao(To(e), t);
}
function Bl(e, t) {
  if (e != null) {
    if (bo(e))
      return Fl(e, t);
    if (Es(e))
      return Ul(e, t);
    if (_o(e))
      return zl(e, t);
    if (wo(e))
      return Ao(e, t);
    if (So(e))
      return Vl(e, t);
    if (Po(e))
      return Wl(e, t);
  }
  throw xo(e);
}
function Fr(e, t) {
  return t ? Bl(e, t) : xt(e);
}
function Io() {
  for (var e = [], t = 0; t < arguments.length; t++)
    e[t] = arguments[t];
  var n = Os(e);
  return Fr(e, n);
}
var Cs = xs(function(e) {
  return function() {
    e(this), this.name = "EmptyError", this.message = "no elements in sequence";
  };
});
function Ca(e, t) {
  var n = typeof t == "object";
  return new Promise(function(r, a) {
    var s = new mr({
      next: function(i) {
        r(i), s.unsubscribe();
      },
      error: a,
      complete: function() {
        n ? r(t.defaultValue) : a(new Cs());
      }
    });
    e.subscribe(s);
  });
}
function Kl(e) {
  return e instanceof Date && !isNaN(e);
}
function Qe(e, t) {
  return ze(function(n, r) {
    var a = 0;
    n.subscribe(xe(r, function(s) {
      r.next(e.call(t, s, a++));
    }));
  });
}
var Gl = Array.isArray;
function Hl(e, t) {
  return Gl(t) ? e.apply(void 0, gt([], st(t))) : e(t);
}
function Ro(e) {
  return Qe(function(t) {
    return Hl(e, t);
  });
}
var Jl = Array.isArray, Yl = Object.getPrototypeOf, Xl = Object.prototype, Ql = Object.keys;
function ed(e) {
  if (e.length === 1) {
    var t = e[0];
    if (Jl(t))
      return { args: t, keys: null };
    if (td(t)) {
      var n = Ql(t);
      return {
        args: n.map(function(r) {
          return t[r];
        }),
        keys: n
      };
    }
  }
  return { args: e, keys: null };
}
function td(e) {
  return e && typeof e == "object" && Yl(e) === Xl;
}
function nd(e, t) {
  return e.reduce(function(n, r, a) {
    return n[r] = t[a], n;
  }, {});
}
function yi() {
  for (var e = [], t = 0; t < arguments.length; t++)
    e[t] = arguments[t];
  var n = Os(e), r = go(e), a = ed(e), s = a.args, i = a.keys;
  if (s.length === 0)
    return Fr([], n);
  var o = new we(rd(s, n, i ? function(c) {
    return nd(i, c);
  } : sn));
  return r ? o.pipe(Ro(r)) : o;
}
function rd(e, t, n) {
  return n === void 0 && (n = sn), function(r) {
    vi(t, function() {
      for (var a = e.length, s = new Array(a), i = a, o = a, c = function(d) {
        vi(t, function() {
          var h = Fr(e[d], t), p = !1;
          h.subscribe(xe(r, function(v) {
            s[d] = v, p || (p = !0, o--), o || r.next(n(s.slice()));
          }, function() {
            --i || r.complete();
          }));
        }, r);
      }, u = 0; u < a; u++)
        c(u);
    }, r);
  };
}
function vi(e, t, n) {
  e ? mt(n, e, t) : t();
}
function ad(e, t, n, r, a, s, i, o) {
  var c = [], u = 0, d = 0, h = !1, p = function() {
    h && !c.length && !u && t.complete();
  }, v = function(g) {
    return u < r ? T(g) : c.push(g);
  }, T = function(g) {
    s && t.next(g), u++;
    var D = !1;
    xt(n(g, d++)).subscribe(xe(t, function(j) {
      a == null || a(j), s ? v(j) : t.next(j);
    }, function() {
      D = !0;
    }, void 0, function() {
      if (D)
        try {
          u--;
          for (var j = function() {
            var I = c.shift();
            i ? mt(t, i, function() {
              return T(I);
            }) : T(I);
          }; c.length && u < r; )
            j();
          p();
        } catch (I) {
          t.error(I);
        }
    }));
  };
  return e.subscribe(xe(t, v, function() {
    h = !0, p();
  })), function() {
    o == null || o();
  };
}
function zr(e, t, n) {
  return n === void 0 && (n = 1 / 0), ee(t) ? zr(function(r, a) {
    return Qe(function(s, i) {
      return t(r, s, a, i);
    })(xt(e(r, a)));
  }, n) : (typeof t == "number" && (n = t), ze(function(r, a) {
    return ad(r, a, e, n);
  }));
}
function sd(e) {
  return e === void 0 && (e = 1 / 0), zr(sn, e);
}
var id = ["addListener", "removeListener"], od = ["addEventListener", "removeEventListener"], ud = ["on", "off"];
function Je(e, t, n, r) {
  if (ee(n) && (r = n, n = void 0), r)
    return Je(e, t, n).pipe(Ro(r));
  var a = st(dd(e) ? od.map(function(o) {
    return function(c) {
      return e[o](t, c, n);
    };
  }) : cd(e) ? id.map(gi(e, t)) : ld(e) ? ud.map(gi(e, t)) : [], 2), s = a[0], i = a[1];
  if (!s && Es(e))
    return zr(function(o) {
      return Je(o, t, n);
    })(xt(e));
  if (!s)
    throw new TypeError("Invalid event target");
  return new we(function(o) {
    var c = function() {
      for (var u = [], d = 0; d < arguments.length; d++)
        u[d] = arguments[d];
      return o.next(1 < u.length ? u : u[0]);
    };
    return s(c), function() {
      return i(c);
    };
  });
}
function gi(e, t) {
  return function(n) {
    return function(r) {
      return e[n](t, r);
    };
  };
}
function cd(e) {
  return ee(e.addListener) && ee(e.removeListener);
}
function ld(e) {
  return ee(e.on) && ee(e.off);
}
function dd(e) {
  return ee(e.addEventListener) && ee(e.removeEventListener);
}
function Aa(e, t, n) {
  e === void 0 && (e = 0), n === void 0 && (n = Rl);
  var r = -1;
  return t != null && (vo(t) ? n = t : r = t), new we(function(a) {
    var s = Kl(e) ? +e - n.now() : e;
    s < 0 && (s = 0);
    var i = 0;
    return n.schedule(function() {
      a.closed || (a.next(i++), 0 <= r ? this.schedule(void 0, r) : a.complete());
    }, s);
  });
}
function vr() {
  for (var e = [], t = 0; t < arguments.length; t++)
    e[t] = arguments[t];
  var n = Os(e), r = Nl(e, 1 / 0), a = e;
  return a.length ? a.length === 1 ? xt(a[0]) : sd(r)(Fr(a, n)) : yo;
}
function _t(e, t) {
  return ze(function(n, r) {
    var a = 0;
    n.subscribe(xe(r, function(s) {
      return e.call(t, s, a++) && r.next(s);
    }));
  });
}
function fd(e, t) {
  return t === void 0 && (t = mo), ze(function(n, r) {
    var a = null, s = null, i = null, o = function() {
      if (a) {
        a.unsubscribe(), a = null;
        var u = s;
        s = null, r.next(u);
      }
    };
    function c() {
      var u = i + e, d = t.now();
      if (d < u) {
        a = this.schedule(void 0, u - d), r.add(a);
        return;
      }
      o();
    }
    n.subscribe(xe(r, function(u) {
      s = u, i = t.now(), a || (a = t.schedule(c, e), r.add(a));
    }, function() {
      o(), r.complete();
    }, void 0, function() {
      s = a = null;
    }));
  });
}
function hd(e) {
  return ze(function(t, n) {
    var r = !1;
    t.subscribe(xe(n, function(a) {
      r = !0, n.next(a);
    }, function() {
      r || n.next(e), n.complete();
    }));
  });
}
function pd(e) {
  return e <= 0 ? function() {
    return yo;
  } : ze(function(t, n) {
    var r = 0;
    t.subscribe(xe(n, function(a) {
      ++r <= e && (n.next(a), e <= r && n.complete());
    }));
  });
}
function md(e) {
  return e === void 0 && (e = yd), ze(function(t, n) {
    var r = !1;
    t.subscribe(xe(n, function(a) {
      r = !0, n.next(a);
    }, function() {
      return r ? n.complete() : n.error(e());
    }));
  });
}
function yd() {
  return new Cs();
}
function No(e, t) {
  var n = arguments.length >= 2;
  return function(r) {
    return r.pipe(e ? _t(function(a, s) {
      return e(a, s, r);
    }) : sn, pd(1), n ? hd(t) : md(function() {
      return new Cs();
    }));
  };
}
function vd(e) {
  return _t(function(t, n) {
    return e <= n;
  });
}
function yt(e, t) {
  return ze(function(n, r) {
    var a = null, s = 0, i = !1, o = function() {
      return i && !a && r.complete();
    };
    n.subscribe(xe(r, function(c) {
      a == null || a.unsubscribe();
      var u = 0, d = s++;
      xt(e(c, d)).subscribe(a = xe(r, function(h) {
        return r.next(t ? t(c, h, d, u++) : h);
      }, function() {
        a = null, o();
      }));
    }, function() {
      i = !0, o();
    }));
  });
}
function B(e, t, n) {
  var r = ee(e) || t || n ? { next: e, error: t, complete: n } : e;
  return r ? ze(function(a, s) {
    var i;
    (i = r.subscribe) === null || i === void 0 || i.call(r);
    var o = !0;
    a.subscribe(xe(s, function(c) {
      var u;
      (u = r.next) === null || u === void 0 || u.call(r, c), s.next(c);
    }, function() {
      var c;
      o = !1, (c = r.complete) === null || c === void 0 || c.call(r), s.complete();
    }, function(c) {
      var u;
      o = !1, (u = r.error) === null || u === void 0 || u.call(r, c), s.error(c);
    }, function() {
      var c, u;
      o && ((c = r.unsubscribe) === null || c === void 0 || c.call(r)), (u = r.finalize) === null || u === void 0 || u.call(r);
    }));
  }) : sn;
}
function da() {
  for (var e = [], t = 0; t < arguments.length; t++)
    e[t] = arguments[t];
  var n = go(e);
  return ze(function(r, a) {
    for (var s = e.length, i = new Array(s), o = e.map(function() {
      return !1;
    }), c = !1, u = function(h) {
      xt(e[h]).subscribe(xe(a, function(p) {
        i[h] = p, !c && !o[h] && (o[h] = !0, (c = o.every(sn)) && (o = null));
      }, Ea));
    }, d = 0; d < s; d++)
      u(d);
    r.subscribe(xe(a, function(h) {
      if (c) {
        var p = gt([h], st(i));
        a.next(n ? n.apply(void 0, gt([], st(p))) : p);
      }
    }));
  });
}
function fa(e, t, n, r) {
  function a(s) {
    return s instanceof n ? s : new n(function(i) {
      i(s);
    });
  }
  return new (n || (n = Promise))(function(s, i) {
    function o(d) {
      try {
        u(r.next(d));
      } catch (h) {
        i(h);
      }
    }
    function c(d) {
      try {
        u(r.throw(d));
      } catch (h) {
        i(h);
      }
    }
    function u(d) {
      d.done ? s(d.value) : a(d.value).then(o, c);
    }
    u((r = r.apply(e, t || [])).next());
  });
}
function ha(e, t) {
  var n = { label: 0, sent: function() {
    if (s[0] & 1)
      throw s[1];
    return s[1];
  }, trys: [], ops: [] }, r, a, s, i;
  return i = { next: o(0), throw: o(1), return: o(2) }, typeof Symbol == "function" && (i[Symbol.iterator] = function() {
    return this;
  }), i;
  function o(u) {
    return function(d) {
      return c([u, d]);
    };
  }
  function c(u) {
    if (r)
      throw new TypeError("Generator is already executing.");
    for (; n; )
      try {
        if (r = 1, a && (s = u[0] & 2 ? a.return : u[0] ? a.throw || ((s = a.return) && s.call(a), 0) : a.next) && !(s = s.call(a, u[1])).done)
          return s;
        switch (a = 0, s && (u = [u[0] & 2, s.value]), u[0]) {
          case 0:
          case 1:
            s = u;
            break;
          case 4:
            return n.label++, { value: u[1], done: !1 };
          case 5:
            n.label++, a = u[1], u = [0];
            continue;
          case 7:
            u = n.ops.pop(), n.trys.pop();
            continue;
          default:
            if (s = n.trys, !(s = s.length > 0 && s[s.length - 1]) && (u[0] === 6 || u[0] === 2)) {
              n = 0;
              continue;
            }
            if (u[0] === 3 && (!s || u[1] > s[0] && u[1] < s[3])) {
              n.label = u[1];
              break;
            }
            if (u[0] === 6 && n.label < s[1]) {
              n.label = s[1], s = u;
              break;
            }
            if (s && n.label < s[2]) {
              n.label = s[2], n.ops.push(u);
              break;
            }
            s[2] && n.ops.pop(), n.trys.pop();
            continue;
        }
        u = t.call(e, n);
      } catch (d) {
        u = [6, d], a = 0;
      } finally {
        r = s = 0;
      }
    if (u[0] & 5)
      throw u[1];
    return { value: u[0] ? u[1] : void 0, done: !0 };
  }
}
function gr(e, t) {
  var n = typeof Symbol == "function" && e[Symbol.iterator];
  if (!n)
    return e;
  var r = n.call(e), a, s = [], i;
  try {
    for (; (t === void 0 || t-- > 0) && !(a = r.next()).done; )
      s.push(a.value);
  } catch (o) {
    i = { error: o };
  } finally {
    try {
      a && !a.done && (n = r.return) && n.call(r);
    } finally {
      if (i)
        throw i.error;
    }
  }
  return s;
}
function Ht(e, t, n) {
  if (n || arguments.length === 2)
    for (var r = 0, a = t.length, s; r < a; r++)
      (s || !(r in t)) && (s || (s = Array.prototype.slice.call(t, 0, r)), s[r] = t[r]);
  return e.concat(s || Array.prototype.slice.call(t));
}
var gd = {
  withStackTrace: !1
}, Do = function(e, t, n) {
  n === void 0 && (n = gd);
  var r = t.isOk() ? { type: "Ok", value: t.value } : { type: "Err", value: t.error }, a = n.withStackTrace ? new Error().stack : void 0;
  return {
    data: r,
    message: e,
    stack: a
  };
}, ct = (
  /** @class */
  function() {
    function e(t) {
      this._promise = t;
    }
    return e.fromSafePromise = function(t) {
      var n = t.then(function(r) {
        return new Zt(r);
      });
      return new e(n);
    }, e.fromPromise = function(t, n) {
      var r = t.then(function(a) {
        return new Zt(a);
      }).catch(function(a) {
        return new Wt(n(a));
      });
      return new e(r);
    }, e.combine = function(t) {
      return bd(t);
    }, e.combineWithAllErrors = function(t) {
      return wd(t);
    }, e.prototype.map = function(t) {
      var n = this;
      return new e(this._promise.then(function(r) {
        return fa(n, void 0, void 0, function() {
          var a;
          return ha(this, function(s) {
            switch (s.label) {
              case 0:
                return r.isErr() ? [2, new Wt(r.error)] : (a = Zt.bind, [4, t(r.value)]);
              case 1:
                return [2, new (a.apply(Zt, [void 0, s.sent()]))()];
            }
          });
        });
      }));
    }, e.prototype.mapErr = function(t) {
      var n = this;
      return new e(this._promise.then(function(r) {
        return fa(n, void 0, void 0, function() {
          var a;
          return ha(this, function(s) {
            switch (s.label) {
              case 0:
                return r.isOk() ? [2, new Zt(r.value)] : (a = Wt.bind, [4, t(r.error)]);
              case 1:
                return [2, new (a.apply(Wt, [void 0, s.sent()]))()];
            }
          });
        });
      }));
    }, e.prototype.andThen = function(t) {
      return new e(this._promise.then(function(n) {
        if (n.isErr())
          return new Wt(n.error);
        var r = t(n.value);
        return r instanceof e ? r._promise : r;
      }));
    }, e.prototype.orElse = function(t) {
      var n = this;
      return new e(this._promise.then(function(r) {
        return fa(n, void 0, void 0, function() {
          return ha(this, function(a) {
            return r.isErr() ? [2, t(r.error)] : [2, new Zt(r.value)];
          });
        });
      }));
    }, e.prototype.match = function(t, n) {
      return this._promise.then(function(r) {
        return r.match(t, n);
      });
    }, e.prototype.unwrapOr = function(t) {
      return this._promise.then(function(n) {
        return n.unwrapOr(t);
      });
    }, e.prototype.then = function(t, n) {
      return this._promise.then(t, n);
    }, e;
  }()
), _i = function(e) {
  return new ct(Promise.resolve(new Wt(e)));
};
ct.fromPromise;
ct.fromSafePromise;
var _d = function(e) {
  return function(t) {
    return Ht(Ht([], gr(t), !1), [e], !1);
  };
}, jo = function(e) {
  return e.reduce(function(t, n) {
    return t.isOk() ? n.isErr() ? Fe(n.error) : t.map(_d(n.value)) : t;
  }, et([]));
}, bd = function(e) {
  return ct.fromSafePromise(Promise.all(e)).andThen(jo);
}, qo = function(e) {
  return e.reduce(function(t, n) {
    return n.isErr() ? t.isErr() ? Fe(Ht(Ht([], gr(t.error), !1), [n.error], !1)) : Fe([n.error]) : t.isErr() ? t : et(Ht(Ht([], gr(t.value), !1), [n.value], !1));
  }, et([]));
}, wd = function(e) {
  return ct.fromSafePromise(Promise.all(e)).andThen(qo);
}, Ia;
(function(e) {
  function t(a, s) {
    return function() {
      for (var i = [], o = 0; o < arguments.length; o++)
        i[o] = arguments[o];
      try {
        var c = a.apply(void 0, Ht([], gr(i), !1));
        return et(c);
      } catch (u) {
        return Fe(s ? s(u) : u);
      }
    };
  }
  e.fromThrowable = t;
  function n(a) {
    return jo(a);
  }
  e.combine = n;
  function r(a) {
    return qo(a);
  }
  e.combineWithAllErrors = r;
})(Ia || (Ia = {}));
var et = function(e) {
  return new Zt(e);
}, Fe = function(e) {
  return new Wt(e);
}, Zt = (
  /** @class */
  function() {
    function e(t) {
      this.value = t;
    }
    return e.prototype.isOk = function() {
      return !0;
    }, e.prototype.isErr = function() {
      return !this.isOk();
    }, e.prototype.map = function(t) {
      return et(t(this.value));
    }, e.prototype.mapErr = function(t) {
      return et(this.value);
    }, e.prototype.andThen = function(t) {
      return t(this.value);
    }, e.prototype.orElse = function(t) {
      return et(this.value);
    }, e.prototype.asyncAndThen = function(t) {
      return t(this.value);
    }, e.prototype.asyncMap = function(t) {
      return ct.fromSafePromise(t(this.value));
    }, e.prototype.unwrapOr = function(t) {
      return this.value;
    }, e.prototype.match = function(t, n) {
      return t(this.value);
    }, e.prototype._unsafeUnwrap = function(t) {
      return this.value;
    }, e.prototype._unsafeUnwrapErr = function(t) {
      throw Do("Called `_unsafeUnwrapErr` on an Ok", this, t);
    }, e;
  }()
), Wt = (
  /** @class */
  function() {
    function e(t) {
      this.error = t;
    }
    return e.prototype.isOk = function() {
      return !1;
    }, e.prototype.isErr = function() {
      return !this.isOk();
    }, e.prototype.map = function(t) {
      return Fe(this.error);
    }, e.prototype.mapErr = function(t) {
      return Fe(t(this.error));
    }, e.prototype.andThen = function(t) {
      return Fe(this.error);
    }, e.prototype.orElse = function(t) {
      return t(this.error);
    }, e.prototype.asyncAndThen = function(t) {
      return _i(this.error);
    }, e.prototype.asyncMap = function(t) {
      return _i(this.error);
    }, e.prototype.unwrapOr = function(t) {
      return t;
    }, e.prototype.match = function(t, n) {
      return n(this.error);
    }, e.prototype._unsafeUnwrap = function(t) {
      throw Do("Called `_unsafeUnwrap` on an Err", this, t);
    }, e.prototype._unsafeUnwrapErr = function(t) {
      return this.error;
    }, e;
  }()
);
Ia.fromThrowable;
var H;
(function(e) {
  e.assertEqual = (a) => a;
  function t(a) {
  }
  e.assertIs = t;
  function n(a) {
    throw new Error();
  }
  e.assertNever = n, e.arrayToEnum = (a) => {
    const s = {};
    for (const i of a)
      s[i] = i;
    return s;
  }, e.getValidEnumValues = (a) => {
    const s = e.objectKeys(a).filter((o) => typeof a[a[o]] != "number"), i = {};
    for (const o of s)
      i[o] = a[o];
    return e.objectValues(i);
  }, e.objectValues = (a) => e.objectKeys(a).map(function(s) {
    return a[s];
  }), e.objectKeys = typeof Object.keys == "function" ? (a) => Object.keys(a) : (a) => {
    const s = [];
    for (const i in a)
      Object.prototype.hasOwnProperty.call(a, i) && s.push(i);
    return s;
  }, e.find = (a, s) => {
    for (const i of a)
      if (s(i))
        return i;
  }, e.isInteger = typeof Number.isInteger == "function" ? (a) => Number.isInteger(a) : (a) => typeof a == "number" && isFinite(a) && Math.floor(a) === a;
  function r(a, s = " | ") {
    return a.map((i) => typeof i == "string" ? `'${i}'` : i).join(s);
  }
  e.joinValues = r, e.jsonStringifyReplacer = (a, s) => typeof s == "bigint" ? s.toString() : s;
})(H || (H = {}));
var bi;
(function(e) {
  e.mergeShapes = (t, n) => ({
    ...t,
    ...n
    // second overwrites first
  });
})(bi || (bi = {}));
const O = H.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]), Bt = (e) => {
  switch (typeof e) {
    case "undefined":
      return O.undefined;
    case "string":
      return O.string;
    case "number":
      return isNaN(e) ? O.nan : O.number;
    case "boolean":
      return O.boolean;
    case "function":
      return O.function;
    case "bigint":
      return O.bigint;
    case "symbol":
      return O.symbol;
    case "object":
      return Array.isArray(e) ? O.array : e === null ? O.null : e.then && typeof e.then == "function" && e.catch && typeof e.catch == "function" ? O.promise : typeof Map < "u" && e instanceof Map ? O.map : typeof Set < "u" && e instanceof Set ? O.set : typeof Date < "u" && e instanceof Date ? O.date : O.object;
    default:
      return O.unknown;
  }
}, w = H.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]);
let Qt = class extends Error {
  constructor(t) {
    super(), this.issues = [], this.addIssue = (r) => {
      this.issues = [...this.issues, r];
    }, this.addIssues = (r = []) => {
      this.issues = [...this.issues, ...r];
    };
    const n = new.target.prototype;
    Object.setPrototypeOf ? Object.setPrototypeOf(this, n) : this.__proto__ = n, this.name = "ZodError", this.issues = t;
  }
  get errors() {
    return this.issues;
  }
  format(t) {
    const n = t || function(s) {
      return s.message;
    }, r = { _errors: [] }, a = (s) => {
      for (const i of s.issues)
        if (i.code === "invalid_union")
          i.unionErrors.map(a);
        else if (i.code === "invalid_return_type")
          a(i.returnTypeError);
        else if (i.code === "invalid_arguments")
          a(i.argumentsError);
        else if (i.path.length === 0)
          r._errors.push(n(i));
        else {
          let o = r, c = 0;
          for (; c < i.path.length; ) {
            const u = i.path[c];
            c === i.path.length - 1 ? (o[u] = o[u] || { _errors: [] }, o[u]._errors.push(n(i))) : o[u] = o[u] || { _errors: [] }, o = o[u], c++;
          }
        }
    };
    return a(this), r;
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, H.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(t = (n) => n.message) {
    const n = {}, r = [];
    for (const a of this.issues)
      a.path.length > 0 ? (n[a.path[0]] = n[a.path[0]] || [], n[a.path[0]].push(t(a))) : r.push(t(a));
    return { formErrors: r, fieldErrors: n };
  }
  get formErrors() {
    return this.flatten();
  }
};
Qt.create = (e) => new Qt(e);
const $o = (e, t) => {
  let n;
  switch (e.code) {
    case w.invalid_type:
      e.received === O.undefined ? n = "Required" : n = `Expected ${e.expected}, received ${e.received}`;
      break;
    case w.invalid_literal:
      n = `Invalid literal value, expected ${JSON.stringify(e.expected, H.jsonStringifyReplacer)}`;
      break;
    case w.unrecognized_keys:
      n = `Unrecognized key(s) in object: ${H.joinValues(e.keys, ", ")}`;
      break;
    case w.invalid_union:
      n = "Invalid input";
      break;
    case w.invalid_union_discriminator:
      n = `Invalid discriminator value. Expected ${H.joinValues(e.options)}`;
      break;
    case w.invalid_enum_value:
      n = `Invalid enum value. Expected ${H.joinValues(e.options)}, received '${e.received}'`;
      break;
    case w.invalid_arguments:
      n = "Invalid function arguments";
      break;
    case w.invalid_return_type:
      n = "Invalid function return type";
      break;
    case w.invalid_date:
      n = "Invalid date";
      break;
    case w.invalid_string:
      typeof e.validation == "object" ? "includes" in e.validation ? (n = `Invalid input: must include "${e.validation.includes}"`, typeof e.validation.position == "number" && (n = `${n} at one or more positions greater than or equal to ${e.validation.position}`)) : "startsWith" in e.validation ? n = `Invalid input: must start with "${e.validation.startsWith}"` : "endsWith" in e.validation ? n = `Invalid input: must end with "${e.validation.endsWith}"` : H.assertNever(e.validation) : e.validation !== "regex" ? n = `Invalid ${e.validation}` : n = "Invalid";
      break;
    case w.too_small:
      e.type === "array" ? n = `Array must contain ${e.exact ? "exactly" : e.inclusive ? "at least" : "more than"} ${e.minimum} element(s)` : e.type === "string" ? n = `String must contain ${e.exact ? "exactly" : e.inclusive ? "at least" : "over"} ${e.minimum} character(s)` : e.type === "number" ? n = `Number must be ${e.exact ? "exactly equal to " : e.inclusive ? "greater than or equal to " : "greater than "}${e.minimum}` : e.type === "date" ? n = `Date must be ${e.exact ? "exactly equal to " : e.inclusive ? "greater than or equal to " : "greater than "}${new Date(Number(e.minimum))}` : n = "Invalid input";
      break;
    case w.too_big:
      e.type === "array" ? n = `Array must contain ${e.exact ? "exactly" : e.inclusive ? "at most" : "less than"} ${e.maximum} element(s)` : e.type === "string" ? n = `String must contain ${e.exact ? "exactly" : e.inclusive ? "at most" : "under"} ${e.maximum} character(s)` : e.type === "number" ? n = `Number must be ${e.exact ? "exactly" : e.inclusive ? "less than or equal to" : "less than"} ${e.maximum}` : e.type === "bigint" ? n = `BigInt must be ${e.exact ? "exactly" : e.inclusive ? "less than or equal to" : "less than"} ${e.maximum}` : e.type === "date" ? n = `Date must be ${e.exact ? "exactly" : e.inclusive ? "smaller than or equal to" : "smaller than"} ${new Date(Number(e.maximum))}` : n = "Invalid input";
      break;
    case w.custom:
      n = "Invalid input";
      break;
    case w.invalid_intersection_types:
      n = "Intersection results could not be merged";
      break;
    case w.not_multiple_of:
      n = `Number must be a multiple of ${e.multipleOf}`;
      break;
    case w.not_finite:
      n = "Number must be finite";
      break;
    default:
      n = t.defaultError, H.assertNever(e);
  }
  return { message: n };
};
let xd = $o;
function kd() {
  return xd;
}
const Sd = (e) => {
  const { data: t, path: n, errorMaps: r, issueData: a } = e, s = [...n, ...a.path || []], i = {
    ...a,
    path: s
  };
  let o = "";
  const c = r.filter((u) => !!u).slice().reverse();
  for (const u of c)
    o = u(i, { data: t, defaultError: o }).message;
  return {
    ...a,
    path: s,
    message: a.message || o
  };
};
function P(e, t) {
  const n = Sd({
    issueData: t,
    data: e.data,
    path: e.path,
    errorMaps: [
      e.common.contextualErrorMap,
      e.schemaErrorMap,
      kd(),
      $o
      // then global default map
    ].filter((r) => !!r)
  });
  e.common.issues.push(n);
}
class Ie {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    this.value === "valid" && (this.value = "dirty");
  }
  abort() {
    this.value !== "aborted" && (this.value = "aborted");
  }
  static mergeArray(t, n) {
    const r = [];
    for (const a of n) {
      if (a.status === "aborted")
        return U;
      a.status === "dirty" && t.dirty(), r.push(a.value);
    }
    return { status: t.value, value: r };
  }
  static async mergeObjectAsync(t, n) {
    const r = [];
    for (const a of n)
      r.push({
        key: await a.key,
        value: await a.value
      });
    return Ie.mergeObjectSync(t, r);
  }
  static mergeObjectSync(t, n) {
    const r = {};
    for (const a of n) {
      const { key: s, value: i } = a;
      if (s.status === "aborted" || i.status === "aborted")
        return U;
      s.status === "dirty" && t.dirty(), i.status === "dirty" && t.dirty(), (typeof i.value < "u" || a.alwaysSet) && (r[s.value] = i.value);
    }
    return { status: t.value, value: r };
  }
}
const U = Object.freeze({
  status: "aborted"
}), Td = (e) => ({ status: "dirty", value: e }), Ue = (e) => ({ status: "valid", value: e }), wi = (e) => e.status === "aborted", xi = (e) => e.status === "dirty", Ra = (e) => e.status === "valid", Na = (e) => typeof Promise < "u" && e instanceof Promise;
var E;
(function(e) {
  e.errToObj = (t) => typeof t == "string" ? { message: t } : t || {}, e.toString = (t) => typeof t == "string" ? t : t == null ? void 0 : t.message;
})(E || (E = {}));
let At = class {
  constructor(t, n, r, a) {
    this._cachedPath = [], this.parent = t, this.data = n, this._path = r, this._key = a;
  }
  get path() {
    return this._cachedPath.length || (this._key instanceof Array ? this._cachedPath.push(...this._path, ...this._key) : this._cachedPath.push(...this._path, this._key)), this._cachedPath;
  }
};
const ki = (e, t) => {
  if (Ra(t))
    return { success: !0, data: t.value };
  if (!e.common.issues.length)
    throw new Error("Validation failed but no issues detected.");
  return {
    success: !1,
    get error() {
      if (this._error)
        return this._error;
      const n = new Qt(e.common.issues);
      return this._error = n, this._error;
    }
  };
};
function z(e) {
  if (!e)
    return {};
  const { errorMap: t, invalid_type_error: n, required_error: r, description: a } = e;
  if (t && (n || r))
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  return t ? { errorMap: t, description: a } : { errorMap: (s, i) => s.code !== "invalid_type" ? { message: i.defaultError } : typeof i.data > "u" ? { message: r ?? i.defaultError } : { message: n ?? i.defaultError }, description: a };
}
let G = class {
  constructor(t) {
    this.spa = this.safeParseAsync, this._def = t, this.parse = this.parse.bind(this), this.safeParse = this.safeParse.bind(this), this.parseAsync = this.parseAsync.bind(this), this.safeParseAsync = this.safeParseAsync.bind(this), this.spa = this.spa.bind(this), this.refine = this.refine.bind(this), this.refinement = this.refinement.bind(this), this.superRefine = this.superRefine.bind(this), this.optional = this.optional.bind(this), this.nullable = this.nullable.bind(this), this.nullish = this.nullish.bind(this), this.array = this.array.bind(this), this.promise = this.promise.bind(this), this.or = this.or.bind(this), this.and = this.and.bind(this), this.transform = this.transform.bind(this), this.brand = this.brand.bind(this), this.default = this.default.bind(this), this.catch = this.catch.bind(this), this.describe = this.describe.bind(this), this.pipe = this.pipe.bind(this), this.isNullable = this.isNullable.bind(this), this.isOptional = this.isOptional.bind(this);
  }
  get description() {
    return this._def.description;
  }
  _getType(t) {
    return Bt(t.data);
  }
  _getOrReturnCtx(t, n) {
    return n || {
      common: t.parent.common,
      data: t.data,
      parsedType: Bt(t.data),
      schemaErrorMap: this._def.errorMap,
      path: t.path,
      parent: t.parent
    };
  }
  _processInputParams(t) {
    return {
      status: new Ie(),
      ctx: {
        common: t.parent.common,
        data: t.data,
        parsedType: Bt(t.data),
        schemaErrorMap: this._def.errorMap,
        path: t.path,
        parent: t.parent
      }
    };
  }
  _parseSync(t) {
    const n = this._parse(t);
    if (Na(n))
      throw new Error("Synchronous parse encountered promise.");
    return n;
  }
  _parseAsync(t) {
    const n = this._parse(t);
    return Promise.resolve(n);
  }
  parse(t, n) {
    const r = this.safeParse(t, n);
    if (r.success)
      return r.data;
    throw r.error;
  }
  safeParse(t, n) {
    var r;
    const a = {
      common: {
        issues: [],
        async: (r = n == null ? void 0 : n.async) !== null && r !== void 0 ? r : !1,
        contextualErrorMap: n == null ? void 0 : n.errorMap
      },
      path: (n == null ? void 0 : n.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: t,
      parsedType: Bt(t)
    }, s = this._parseSync({ data: t, path: a.path, parent: a });
    return ki(a, s);
  }
  async parseAsync(t, n) {
    const r = await this.safeParseAsync(t, n);
    if (r.success)
      return r.data;
    throw r.error;
  }
  async safeParseAsync(t, n) {
    const r = {
      common: {
        issues: [],
        contextualErrorMap: n == null ? void 0 : n.errorMap,
        async: !0
      },
      path: (n == null ? void 0 : n.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: t,
      parsedType: Bt(t)
    }, a = this._parse({ data: t, path: r.path, parent: r }), s = await (Na(a) ? a : Promise.resolve(a));
    return ki(r, s);
  }
  refine(t, n) {
    const r = (a) => typeof n == "string" || typeof n > "u" ? { message: n } : typeof n == "function" ? n(a) : n;
    return this._refinement((a, s) => {
      const i = t(a), o = () => s.addIssue({
        code: w.custom,
        ...r(a)
      });
      return typeof Promise < "u" && i instanceof Promise ? i.then((c) => c ? !0 : (o(), !1)) : i ? !0 : (o(), !1);
    });
  }
  refinement(t, n) {
    return this._refinement((r, a) => t(r) ? !0 : (a.addIssue(typeof n == "function" ? n(r, a) : n), !1));
  }
  _refinement(t) {
    return new gn({
      schema: this,
      typeName: q.ZodEffects,
      effect: { type: "refinement", refinement: t }
    });
  }
  superRefine(t) {
    return this._refinement(t);
  }
  optional() {
    return Ot.create(this, this._def);
  }
  nullable() {
    return _n.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return tt.create(this, this._def);
  }
  promise() {
    return wr.create(this, this._def);
  }
  or(t) {
    return _r.create([this, t], this._def);
  }
  and(t) {
    return br.create(this, t, this._def);
  }
  transform(t) {
    return new gn({
      ...z(this._def),
      schema: this,
      typeName: q.ZodEffects,
      effect: { type: "transform", transform: t }
    });
  }
  default(t) {
    const n = typeof t == "function" ? t : () => t;
    return new Ua({
      ...z(this._def),
      innerType: this,
      defaultValue: n,
      typeName: q.ZodDefault
    });
  }
  brand() {
    return new $d({
      typeName: q.ZodBranded,
      type: this,
      ...z(this._def)
    });
  }
  catch(t) {
    const n = typeof t == "function" ? t : () => t;
    return new Va({
      ...z(this._def),
      innerType: this,
      catchValue: n,
      typeName: q.ZodCatch
    });
  }
  describe(t) {
    const n = this.constructor;
    return new n({
      ...this._def,
      description: t
    });
  }
  pipe(t) {
    return Ld.create(this, t);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
};
const Pd = /^c[^\s-]{8,}$/i, Od = /^[a-z][a-z0-9]*$/, Ed = /[0-9A-HJKMNP-TV-Z]{26}/, Cd = /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[a-f0-9]{4}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i, Ad = /^(([^<>()[\]\\.,;:\s@\"]+(\.[^<>()[\]\\.,;:\s@\"]+)*)|(\".+\"))@((\[(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\])|(\[IPv6:(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))\])|([A-Za-z0-9]([A-Za-z0-9-]*[A-Za-z0-9])*(\.[A-Za-z]{2,})+))$/, Id = /^(\p{Extended_Pictographic}|\p{Emoji_Component})+$/u, Rd = /^(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))$/, Nd = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/, Dd = (e) => e.precision ? e.offset ? new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${e.precision}}(([+-]\\d{2}(:?\\d{2})?)|Z)$`) : new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${e.precision}}Z$`) : e.precision === 0 ? e.offset ? new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(([+-]\\d{2}(:?\\d{2})?)|Z)$") : new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}Z$") : e.offset ? new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(([+-]\\d{2}(:?\\d{2})?)|Z)$") : new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?Z$");
function jd(e, t) {
  return !!((t === "v4" || !t) && Rd.test(e) || (t === "v6" || !t) && Nd.test(e));
}
let Da = class qn extends G {
  constructor() {
    super(...arguments), this._regex = (t, n, r) => this.refinement((a) => t.test(a), {
      validation: n,
      code: w.invalid_string,
      ...E.errToObj(r)
    }), this.nonempty = (t) => this.min(1, E.errToObj(t)), this.trim = () => new qn({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    }), this.toLowerCase = () => new qn({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    }), this.toUpperCase = () => new qn({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  _parse(t) {
    if (this._def.coerce && (t.data = String(t.data)), this._getType(t) !== O.string) {
      const a = this._getOrReturnCtx(t);
      return P(
        a,
        {
          code: w.invalid_type,
          expected: O.string,
          received: a.parsedType
        }
        //
      ), U;
    }
    const n = new Ie();
    let r;
    for (const a of this._def.checks)
      if (a.kind === "min")
        t.data.length < a.value && (r = this._getOrReturnCtx(t, r), P(r, {
          code: w.too_small,
          minimum: a.value,
          type: "string",
          inclusive: !0,
          exact: !1,
          message: a.message
        }), n.dirty());
      else if (a.kind === "max")
        t.data.length > a.value && (r = this._getOrReturnCtx(t, r), P(r, {
          code: w.too_big,
          maximum: a.value,
          type: "string",
          inclusive: !0,
          exact: !1,
          message: a.message
        }), n.dirty());
      else if (a.kind === "length") {
        const s = t.data.length > a.value, i = t.data.length < a.value;
        (s || i) && (r = this._getOrReturnCtx(t, r), s ? P(r, {
          code: w.too_big,
          maximum: a.value,
          type: "string",
          inclusive: !0,
          exact: !0,
          message: a.message
        }) : i && P(r, {
          code: w.too_small,
          minimum: a.value,
          type: "string",
          inclusive: !0,
          exact: !0,
          message: a.message
        }), n.dirty());
      } else if (a.kind === "email")
        Ad.test(t.data) || (r = this._getOrReturnCtx(t, r), P(r, {
          validation: "email",
          code: w.invalid_string,
          message: a.message
        }), n.dirty());
      else if (a.kind === "emoji")
        Id.test(t.data) || (r = this._getOrReturnCtx(t, r), P(r, {
          validation: "emoji",
          code: w.invalid_string,
          message: a.message
        }), n.dirty());
      else if (a.kind === "uuid")
        Cd.test(t.data) || (r = this._getOrReturnCtx(t, r), P(r, {
          validation: "uuid",
          code: w.invalid_string,
          message: a.message
        }), n.dirty());
      else if (a.kind === "cuid")
        Pd.test(t.data) || (r = this._getOrReturnCtx(t, r), P(r, {
          validation: "cuid",
          code: w.invalid_string,
          message: a.message
        }), n.dirty());
      else if (a.kind === "cuid2")
        Od.test(t.data) || (r = this._getOrReturnCtx(t, r), P(r, {
          validation: "cuid2",
          code: w.invalid_string,
          message: a.message
        }), n.dirty());
      else if (a.kind === "ulid")
        Ed.test(t.data) || (r = this._getOrReturnCtx(t, r), P(r, {
          validation: "ulid",
          code: w.invalid_string,
          message: a.message
        }), n.dirty());
      else if (a.kind === "url")
        try {
          new URL(t.data);
        } catch {
          r = this._getOrReturnCtx(t, r), P(r, {
            validation: "url",
            code: w.invalid_string,
            message: a.message
          }), n.dirty();
        }
      else
        a.kind === "regex" ? (a.regex.lastIndex = 0, a.regex.test(t.data) || (r = this._getOrReturnCtx(t, r), P(r, {
          validation: "regex",
          code: w.invalid_string,
          message: a.message
        }), n.dirty())) : a.kind === "trim" ? t.data = t.data.trim() : a.kind === "includes" ? t.data.includes(a.value, a.position) || (r = this._getOrReturnCtx(t, r), P(r, {
          code: w.invalid_string,
          validation: { includes: a.value, position: a.position },
          message: a.message
        }), n.dirty()) : a.kind === "toLowerCase" ? t.data = t.data.toLowerCase() : a.kind === "toUpperCase" ? t.data = t.data.toUpperCase() : a.kind === "startsWith" ? t.data.startsWith(a.value) || (r = this._getOrReturnCtx(t, r), P(r, {
          code: w.invalid_string,
          validation: { startsWith: a.value },
          message: a.message
        }), n.dirty()) : a.kind === "endsWith" ? t.data.endsWith(a.value) || (r = this._getOrReturnCtx(t, r), P(r, {
          code: w.invalid_string,
          validation: { endsWith: a.value },
          message: a.message
        }), n.dirty()) : a.kind === "datetime" ? Dd(a).test(t.data) || (r = this._getOrReturnCtx(t, r), P(r, {
          code: w.invalid_string,
          validation: "datetime",
          message: a.message
        }), n.dirty()) : a.kind === "ip" ? jd(t.data, a.version) || (r = this._getOrReturnCtx(t, r), P(r, {
          validation: "ip",
          code: w.invalid_string,
          message: a.message
        }), n.dirty()) : H.assertNever(a);
    return { status: n.value, value: t.data };
  }
  _addCheck(t) {
    return new qn({
      ...this._def,
      checks: [...this._def.checks, t]
    });
  }
  email(t) {
    return this._addCheck({ kind: "email", ...E.errToObj(t) });
  }
  url(t) {
    return this._addCheck({ kind: "url", ...E.errToObj(t) });
  }
  emoji(t) {
    return this._addCheck({ kind: "emoji", ...E.errToObj(t) });
  }
  uuid(t) {
    return this._addCheck({ kind: "uuid", ...E.errToObj(t) });
  }
  cuid(t) {
    return this._addCheck({ kind: "cuid", ...E.errToObj(t) });
  }
  cuid2(t) {
    return this._addCheck({ kind: "cuid2", ...E.errToObj(t) });
  }
  ulid(t) {
    return this._addCheck({ kind: "ulid", ...E.errToObj(t) });
  }
  ip(t) {
    return this._addCheck({ kind: "ip", ...E.errToObj(t) });
  }
  datetime(t) {
    var n;
    return typeof t == "string" ? this._addCheck({
      kind: "datetime",
      precision: null,
      offset: !1,
      message: t
    }) : this._addCheck({
      kind: "datetime",
      precision: typeof (t == null ? void 0 : t.precision) > "u" ? null : t == null ? void 0 : t.precision,
      offset: (n = t == null ? void 0 : t.offset) !== null && n !== void 0 ? n : !1,
      ...E.errToObj(t == null ? void 0 : t.message)
    });
  }
  regex(t, n) {
    return this._addCheck({
      kind: "regex",
      regex: t,
      ...E.errToObj(n)
    });
  }
  includes(t, n) {
    return this._addCheck({
      kind: "includes",
      value: t,
      position: n == null ? void 0 : n.position,
      ...E.errToObj(n == null ? void 0 : n.message)
    });
  }
  startsWith(t, n) {
    return this._addCheck({
      kind: "startsWith",
      value: t,
      ...E.errToObj(n)
    });
  }
  endsWith(t, n) {
    return this._addCheck({
      kind: "endsWith",
      value: t,
      ...E.errToObj(n)
    });
  }
  min(t, n) {
    return this._addCheck({
      kind: "min",
      value: t,
      ...E.errToObj(n)
    });
  }
  max(t, n) {
    return this._addCheck({
      kind: "max",
      value: t,
      ...E.errToObj(n)
    });
  }
  length(t, n) {
    return this._addCheck({
      kind: "length",
      value: t,
      ...E.errToObj(n)
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((t) => t.kind === "datetime");
  }
  get isEmail() {
    return !!this._def.checks.find((t) => t.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((t) => t.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((t) => t.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((t) => t.kind === "uuid");
  }
  get isCUID() {
    return !!this._def.checks.find((t) => t.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((t) => t.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((t) => t.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((t) => t.kind === "ip");
  }
  get minLength() {
    let t = null;
    for (const n of this._def.checks)
      n.kind === "min" && (t === null || n.value > t) && (t = n.value);
    return t;
  }
  get maxLength() {
    let t = null;
    for (const n of this._def.checks)
      n.kind === "max" && (t === null || n.value < t) && (t = n.value);
    return t;
  }
};
Da.create = (e) => {
  var t;
  return new Da({
    checks: [],
    typeName: q.ZodString,
    coerce: (t = e == null ? void 0 : e.coerce) !== null && t !== void 0 ? t : !1,
    ...z(e)
  });
};
function qd(e, t) {
  const n = (e.toString().split(".")[1] || "").length, r = (t.toString().split(".")[1] || "").length, a = n > r ? n : r, s = parseInt(e.toFixed(a).replace(".", "")), i = parseInt(t.toFixed(a).replace(".", ""));
  return s % i / Math.pow(10, a);
}
let ja = class qa extends G {
  constructor() {
    super(...arguments), this.min = this.gte, this.max = this.lte, this.step = this.multipleOf;
  }
  _parse(t) {
    if (this._def.coerce && (t.data = Number(t.data)), this._getType(t) !== O.number) {
      const a = this._getOrReturnCtx(t);
      return P(a, {
        code: w.invalid_type,
        expected: O.number,
        received: a.parsedType
      }), U;
    }
    let n;
    const r = new Ie();
    for (const a of this._def.checks)
      a.kind === "int" ? H.isInteger(t.data) || (n = this._getOrReturnCtx(t, n), P(n, {
        code: w.invalid_type,
        expected: "integer",
        received: "float",
        message: a.message
      }), r.dirty()) : a.kind === "min" ? (a.inclusive ? t.data < a.value : t.data <= a.value) && (n = this._getOrReturnCtx(t, n), P(n, {
        code: w.too_small,
        minimum: a.value,
        type: "number",
        inclusive: a.inclusive,
        exact: !1,
        message: a.message
      }), r.dirty()) : a.kind === "max" ? (a.inclusive ? t.data > a.value : t.data >= a.value) && (n = this._getOrReturnCtx(t, n), P(n, {
        code: w.too_big,
        maximum: a.value,
        type: "number",
        inclusive: a.inclusive,
        exact: !1,
        message: a.message
      }), r.dirty()) : a.kind === "multipleOf" ? qd(t.data, a.value) !== 0 && (n = this._getOrReturnCtx(t, n), P(n, {
        code: w.not_multiple_of,
        multipleOf: a.value,
        message: a.message
      }), r.dirty()) : a.kind === "finite" ? Number.isFinite(t.data) || (n = this._getOrReturnCtx(t, n), P(n, {
        code: w.not_finite,
        message: a.message
      }), r.dirty()) : H.assertNever(a);
    return { status: r.value, value: t.data };
  }
  gte(t, n) {
    return this.setLimit("min", t, !0, E.toString(n));
  }
  gt(t, n) {
    return this.setLimit("min", t, !1, E.toString(n));
  }
  lte(t, n) {
    return this.setLimit("max", t, !0, E.toString(n));
  }
  lt(t, n) {
    return this.setLimit("max", t, !1, E.toString(n));
  }
  setLimit(t, n, r, a) {
    return new qa({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind: t,
          value: n,
          inclusive: r,
          message: E.toString(a)
        }
      ]
    });
  }
  _addCheck(t) {
    return new qa({
      ...this._def,
      checks: [...this._def.checks, t]
    });
  }
  int(t) {
    return this._addCheck({
      kind: "int",
      message: E.toString(t)
    });
  }
  positive(t) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: !1,
      message: E.toString(t)
    });
  }
  negative(t) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: !1,
      message: E.toString(t)
    });
  }
  nonpositive(t) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: !0,
      message: E.toString(t)
    });
  }
  nonnegative(t) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: !0,
      message: E.toString(t)
    });
  }
  multipleOf(t, n) {
    return this._addCheck({
      kind: "multipleOf",
      value: t,
      message: E.toString(n)
    });
  }
  finite(t) {
    return this._addCheck({
      kind: "finite",
      message: E.toString(t)
    });
  }
  safe(t) {
    return this._addCheck({
      kind: "min",
      inclusive: !0,
      value: Number.MIN_SAFE_INTEGER,
      message: E.toString(t)
    })._addCheck({
      kind: "max",
      inclusive: !0,
      value: Number.MAX_SAFE_INTEGER,
      message: E.toString(t)
    });
  }
  get minValue() {
    let t = null;
    for (const n of this._def.checks)
      n.kind === "min" && (t === null || n.value > t) && (t = n.value);
    return t;
  }
  get maxValue() {
    let t = null;
    for (const n of this._def.checks)
      n.kind === "max" && (t === null || n.value < t) && (t = n.value);
    return t;
  }
  get isInt() {
    return !!this._def.checks.find((t) => t.kind === "int" || t.kind === "multipleOf" && H.isInteger(t.value));
  }
  get isFinite() {
    let t = null, n = null;
    for (const r of this._def.checks) {
      if (r.kind === "finite" || r.kind === "int" || r.kind === "multipleOf")
        return !0;
      r.kind === "min" ? (n === null || r.value > n) && (n = r.value) : r.kind === "max" && (t === null || r.value < t) && (t = r.value);
    }
    return Number.isFinite(n) && Number.isFinite(t);
  }
};
ja.create = (e) => new ja({
  checks: [],
  typeName: q.ZodNumber,
  coerce: (e == null ? void 0 : e.coerce) || !1,
  ...z(e)
});
let Si = class $a extends G {
  constructor() {
    super(...arguments), this.min = this.gte, this.max = this.lte;
  }
  _parse(t) {
    if (this._def.coerce && (t.data = BigInt(t.data)), this._getType(t) !== O.bigint) {
      const a = this._getOrReturnCtx(t);
      return P(a, {
        code: w.invalid_type,
        expected: O.bigint,
        received: a.parsedType
      }), U;
    }
    let n;
    const r = new Ie();
    for (const a of this._def.checks)
      a.kind === "min" ? (a.inclusive ? t.data < a.value : t.data <= a.value) && (n = this._getOrReturnCtx(t, n), P(n, {
        code: w.too_small,
        type: "bigint",
        minimum: a.value,
        inclusive: a.inclusive,
        message: a.message
      }), r.dirty()) : a.kind === "max" ? (a.inclusive ? t.data > a.value : t.data >= a.value) && (n = this._getOrReturnCtx(t, n), P(n, {
        code: w.too_big,
        type: "bigint",
        maximum: a.value,
        inclusive: a.inclusive,
        message: a.message
      }), r.dirty()) : a.kind === "multipleOf" ? t.data % a.value !== BigInt(0) && (n = this._getOrReturnCtx(t, n), P(n, {
        code: w.not_multiple_of,
        multipleOf: a.value,
        message: a.message
      }), r.dirty()) : H.assertNever(a);
    return { status: r.value, value: t.data };
  }
  gte(t, n) {
    return this.setLimit("min", t, !0, E.toString(n));
  }
  gt(t, n) {
    return this.setLimit("min", t, !1, E.toString(n));
  }
  lte(t, n) {
    return this.setLimit("max", t, !0, E.toString(n));
  }
  lt(t, n) {
    return this.setLimit("max", t, !1, E.toString(n));
  }
  setLimit(t, n, r, a) {
    return new $a({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind: t,
          value: n,
          inclusive: r,
          message: E.toString(a)
        }
      ]
    });
  }
  _addCheck(t) {
    return new $a({
      ...this._def,
      checks: [...this._def.checks, t]
    });
  }
  positive(t) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: !1,
      message: E.toString(t)
    });
  }
  negative(t) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: !1,
      message: E.toString(t)
    });
  }
  nonpositive(t) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: !0,
      message: E.toString(t)
    });
  }
  nonnegative(t) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: !0,
      message: E.toString(t)
    });
  }
  multipleOf(t, n) {
    return this._addCheck({
      kind: "multipleOf",
      value: t,
      message: E.toString(n)
    });
  }
  get minValue() {
    let t = null;
    for (const n of this._def.checks)
      n.kind === "min" && (t === null || n.value > t) && (t = n.value);
    return t;
  }
  get maxValue() {
    let t = null;
    for (const n of this._def.checks)
      n.kind === "max" && (t === null || n.value < t) && (t = n.value);
    return t;
  }
};
Si.create = (e) => {
  var t;
  return new Si({
    checks: [],
    typeName: q.ZodBigInt,
    coerce: (t = e == null ? void 0 : e.coerce) !== null && t !== void 0 ? t : !1,
    ...z(e)
  });
};
class La extends G {
  _parse(t) {
    if (this._def.coerce && (t.data = !!t.data), this._getType(t) !== O.boolean) {
      const n = this._getOrReturnCtx(t);
      return P(n, {
        code: w.invalid_type,
        expected: O.boolean,
        received: n.parsedType
      }), U;
    }
    return Ue(t.data);
  }
}
La.create = (e) => new La({
  typeName: q.ZodBoolean,
  coerce: (e == null ? void 0 : e.coerce) || !1,
  ...z(e)
});
let Ti = class Lo extends G {
  _parse(t) {
    if (this._def.coerce && (t.data = new Date(t.data)), this._getType(t) !== O.date) {
      const a = this._getOrReturnCtx(t);
      return P(a, {
        code: w.invalid_type,
        expected: O.date,
        received: a.parsedType
      }), U;
    }
    if (isNaN(t.data.getTime())) {
      const a = this._getOrReturnCtx(t);
      return P(a, {
        code: w.invalid_date
      }), U;
    }
    const n = new Ie();
    let r;
    for (const a of this._def.checks)
      a.kind === "min" ? t.data.getTime() < a.value && (r = this._getOrReturnCtx(t, r), P(r, {
        code: w.too_small,
        message: a.message,
        inclusive: !0,
        exact: !1,
        minimum: a.value,
        type: "date"
      }), n.dirty()) : a.kind === "max" ? t.data.getTime() > a.value && (r = this._getOrReturnCtx(t, r), P(r, {
        code: w.too_big,
        message: a.message,
        inclusive: !0,
        exact: !1,
        maximum: a.value,
        type: "date"
      }), n.dirty()) : H.assertNever(a);
    return {
      status: n.value,
      value: new Date(t.data.getTime())
    };
  }
  _addCheck(t) {
    return new Lo({
      ...this._def,
      checks: [...this._def.checks, t]
    });
  }
  min(t, n) {
    return this._addCheck({
      kind: "min",
      value: t.getTime(),
      message: E.toString(n)
    });
  }
  max(t, n) {
    return this._addCheck({
      kind: "max",
      value: t.getTime(),
      message: E.toString(n)
    });
  }
  get minDate() {
    let t = null;
    for (const n of this._def.checks)
      n.kind === "min" && (t === null || n.value > t) && (t = n.value);
    return t != null ? new Date(t) : null;
  }
  get maxDate() {
    let t = null;
    for (const n of this._def.checks)
      n.kind === "max" && (t === null || n.value < t) && (t = n.value);
    return t != null ? new Date(t) : null;
  }
};
Ti.create = (e) => new Ti({
  checks: [],
  coerce: (e == null ? void 0 : e.coerce) || !1,
  typeName: q.ZodDate,
  ...z(e)
});
class Pi extends G {
  _parse(t) {
    if (this._getType(t) !== O.symbol) {
      const n = this._getOrReturnCtx(t);
      return P(n, {
        code: w.invalid_type,
        expected: O.symbol,
        received: n.parsedType
      }), U;
    }
    return Ue(t.data);
  }
}
Pi.create = (e) => new Pi({
  typeName: q.ZodSymbol,
  ...z(e)
});
class Oi extends G {
  _parse(t) {
    if (this._getType(t) !== O.undefined) {
      const n = this._getOrReturnCtx(t);
      return P(n, {
        code: w.invalid_type,
        expected: O.undefined,
        received: n.parsedType
      }), U;
    }
    return Ue(t.data);
  }
}
Oi.create = (e) => new Oi({
  typeName: q.ZodUndefined,
  ...z(e)
});
let Ei = class extends G {
  _parse(t) {
    if (this._getType(t) !== O.null) {
      const n = this._getOrReturnCtx(t);
      return P(n, {
        code: w.invalid_type,
        expected: O.null,
        received: n.parsedType
      }), U;
    }
    return Ue(t.data);
  }
};
Ei.create = (e) => new Ei({
  typeName: q.ZodNull,
  ...z(e)
});
let Ci = class extends G {
  constructor() {
    super(...arguments), this._any = !0;
  }
  _parse(t) {
    return Ue(t.data);
  }
};
Ci.create = (e) => new Ci({
  typeName: q.ZodAny,
  ...z(e)
});
let Ai = class extends G {
  constructor() {
    super(...arguments), this._unknown = !0;
  }
  _parse(t) {
    return Ue(t.data);
  }
};
Ai.create = (e) => new Ai({
  typeName: q.ZodUnknown,
  ...z(e)
});
let It = class extends G {
  _parse(t) {
    const n = this._getOrReturnCtx(t);
    return P(n, {
      code: w.invalid_type,
      expected: O.never,
      received: n.parsedType
    }), U;
  }
};
It.create = (e) => new It({
  typeName: q.ZodNever,
  ...z(e)
});
class Ii extends G {
  _parse(t) {
    if (this._getType(t) !== O.undefined) {
      const n = this._getOrReturnCtx(t);
      return P(n, {
        code: w.invalid_type,
        expected: O.void,
        received: n.parsedType
      }), U;
    }
    return Ue(t.data);
  }
}
Ii.create = (e) => new Ii({
  typeName: q.ZodVoid,
  ...z(e)
});
class tt extends G {
  _parse(t) {
    const { ctx: n, status: r } = this._processInputParams(t), a = this._def;
    if (n.parsedType !== O.array)
      return P(n, {
        code: w.invalid_type,
        expected: O.array,
        received: n.parsedType
      }), U;
    if (a.exactLength !== null) {
      const i = n.data.length > a.exactLength.value, o = n.data.length < a.exactLength.value;
      (i || o) && (P(n, {
        code: i ? w.too_big : w.too_small,
        minimum: o ? a.exactLength.value : void 0,
        maximum: i ? a.exactLength.value : void 0,
        type: "array",
        inclusive: !0,
        exact: !0,
        message: a.exactLength.message
      }), r.dirty());
    }
    if (a.minLength !== null && n.data.length < a.minLength.value && (P(n, {
      code: w.too_small,
      minimum: a.minLength.value,
      type: "array",
      inclusive: !0,
      exact: !1,
      message: a.minLength.message
    }), r.dirty()), a.maxLength !== null && n.data.length > a.maxLength.value && (P(n, {
      code: w.too_big,
      maximum: a.maxLength.value,
      type: "array",
      inclusive: !0,
      exact: !1,
      message: a.maxLength.message
    }), r.dirty()), n.common.async)
      return Promise.all([...n.data].map((i, o) => a.type._parseAsync(new At(n, i, n.path, o)))).then((i) => Ie.mergeArray(r, i));
    const s = [...n.data].map((i, o) => a.type._parseSync(new At(n, i, n.path, o)));
    return Ie.mergeArray(r, s);
  }
  get element() {
    return this._def.type;
  }
  min(t, n) {
    return new tt({
      ...this._def,
      minLength: { value: t, message: E.toString(n) }
    });
  }
  max(t, n) {
    return new tt({
      ...this._def,
      maxLength: { value: t, message: E.toString(n) }
    });
  }
  length(t, n) {
    return new tt({
      ...this._def,
      exactLength: { value: t, message: E.toString(n) }
    });
  }
  nonempty(t) {
    return this.min(1, t);
  }
}
tt.create = (e, t) => new tt({
  type: e,
  minLength: null,
  maxLength: null,
  exactLength: null,
  typeName: q.ZodArray,
  ...z(t)
});
function cn(e) {
  if (e instanceof ue) {
    const t = {};
    for (const n in e.shape) {
      const r = e.shape[n];
      t[n] = Ot.create(cn(r));
    }
    return new ue({
      ...e._def,
      shape: () => t
    });
  } else
    return e instanceof tt ? new tt({
      ...e._def,
      type: cn(e.element)
    }) : e instanceof Ot ? Ot.create(cn(e.unwrap())) : e instanceof _n ? _n.create(cn(e.unwrap())) : e instanceof en ? en.create(e.items.map((t) => cn(t))) : e;
}
class ue extends G {
  constructor() {
    super(...arguments), this._cached = null, this.nonstrict = this.passthrough, this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const t = this._def.shape(), n = H.objectKeys(t);
    return this._cached = { shape: t, keys: n };
  }
  _parse(t) {
    if (this._getType(t) !== O.object) {
      const c = this._getOrReturnCtx(t);
      return P(c, {
        code: w.invalid_type,
        expected: O.object,
        received: c.parsedType
      }), U;
    }
    const { status: n, ctx: r } = this._processInputParams(t), { shape: a, keys: s } = this._getCached(), i = [];
    if (!(this._def.catchall instanceof It && this._def.unknownKeys === "strip"))
      for (const c in r.data)
        s.includes(c) || i.push(c);
    const o = [];
    for (const c of s) {
      const u = a[c], d = r.data[c];
      o.push({
        key: { status: "valid", value: c },
        value: u._parse(new At(r, d, r.path, c)),
        alwaysSet: c in r.data
      });
    }
    if (this._def.catchall instanceof It) {
      const c = this._def.unknownKeys;
      if (c === "passthrough")
        for (const u of i)
          o.push({
            key: { status: "valid", value: u },
            value: { status: "valid", value: r.data[u] }
          });
      else if (c === "strict")
        i.length > 0 && (P(r, {
          code: w.unrecognized_keys,
          keys: i
        }), n.dirty());
      else if (c !== "strip")
        throw new Error("Internal ZodObject error: invalid unknownKeys value.");
    } else {
      const c = this._def.catchall;
      for (const u of i) {
        const d = r.data[u];
        o.push({
          key: { status: "valid", value: u },
          value: c._parse(
            new At(r, d, r.path, u)
            //, ctx.child(key), value, getParsedType(value)
          ),
          alwaysSet: u in r.data
        });
      }
    }
    return r.common.async ? Promise.resolve().then(async () => {
      const c = [];
      for (const u of o) {
        const d = await u.key;
        c.push({
          key: d,
          value: await u.value,
          alwaysSet: u.alwaysSet
        });
      }
      return c;
    }).then((c) => Ie.mergeObjectSync(n, c)) : Ie.mergeObjectSync(n, o);
  }
  get shape() {
    return this._def.shape();
  }
  strict(t) {
    return E.errToObj, new ue({
      ...this._def,
      unknownKeys: "strict",
      ...t !== void 0 ? {
        errorMap: (n, r) => {
          var a, s, i, o;
          const c = (i = (s = (a = this._def).errorMap) === null || s === void 0 ? void 0 : s.call(a, n, r).message) !== null && i !== void 0 ? i : r.defaultError;
          return n.code === "unrecognized_keys" ? {
            message: (o = E.errToObj(t).message) !== null && o !== void 0 ? o : c
          } : {
            message: c
          };
        }
      } : {}
    });
  }
  strip() {
    return new ue({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new ue({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  // const AugmentFactory =
  //   <Def extends ZodObjectDef>(def: Def) =>
  //   <Augmentation extends ZodRawShape>(
  //     augmentation: Augmentation
  //   ): ZodObject<
  //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
  //     Def["unknownKeys"],
  //     Def["catchall"]
  //   > => {
  //     return new ZodObject({
  //       ...def,
  //       shape: () => ({
  //         ...def.shape(),
  //         ...augmentation,
  //       }),
  //     }) as any;
  //   };
  extend(t) {
    return new ue({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...t
      })
    });
  }
  /**
   * Prior to zod@1.0.12 there was a bug in the
   * inferred type of merged objects. Please
   * upgrade if you are experiencing issues.
   */
  merge(t) {
    return new ue({
      unknownKeys: t._def.unknownKeys,
      catchall: t._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...t._def.shape()
      }),
      typeName: q.ZodObject
    });
  }
  // merge<
  //   Incoming extends AnyZodObject,
  //   Augmentation extends Incoming["shape"],
  //   NewOutput extends {
  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
  //       ? Augmentation[k]["_output"]
  //       : k extends keyof Output
  //       ? Output[k]
  //       : never;
  //   },
  //   NewInput extends {
  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
  //       ? Augmentation[k]["_input"]
  //       : k extends keyof Input
  //       ? Input[k]
  //       : never;
  //   }
  // >(
  //   merging: Incoming
  // ): ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"],
  //   NewOutput,
  //   NewInput
  // > {
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  setKey(t, n) {
    return this.augment({ [t]: n });
  }
  // merge<Incoming extends AnyZodObject>(
  //   merging: Incoming
  // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
  // ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"]
  // > {
  //   // const mergedShape = objectUtil.mergeShapes(
  //   //   this._def.shape(),
  //   //   merging._def.shape()
  //   // );
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  catchall(t) {
    return new ue({
      ...this._def,
      catchall: t
    });
  }
  pick(t) {
    const n = {};
    return H.objectKeys(t).forEach((r) => {
      t[r] && this.shape[r] && (n[r] = this.shape[r]);
    }), new ue({
      ...this._def,
      shape: () => n
    });
  }
  omit(t) {
    const n = {};
    return H.objectKeys(this.shape).forEach((r) => {
      t[r] || (n[r] = this.shape[r]);
    }), new ue({
      ...this._def,
      shape: () => n
    });
  }
  /**
   * @deprecated
   */
  deepPartial() {
    return cn(this);
  }
  partial(t) {
    const n = {};
    return H.objectKeys(this.shape).forEach((r) => {
      const a = this.shape[r];
      t && !t[r] ? n[r] = a : n[r] = a.optional();
    }), new ue({
      ...this._def,
      shape: () => n
    });
  }
  required(t) {
    const n = {};
    return H.objectKeys(this.shape).forEach((r) => {
      if (t && !t[r])
        n[r] = this.shape[r];
      else {
        let a = this.shape[r];
        for (; a instanceof Ot; )
          a = a._def.innerType;
        n[r] = a;
      }
    }), new ue({
      ...this._def,
      shape: () => n
    });
  }
  keyof() {
    return Mo(H.objectKeys(this.shape));
  }
}
ue.create = (e, t) => new ue({
  shape: () => e,
  unknownKeys: "strip",
  catchall: It.create(),
  typeName: q.ZodObject,
  ...z(t)
});
ue.strictCreate = (e, t) => new ue({
  shape: () => e,
  unknownKeys: "strict",
  catchall: It.create(),
  typeName: q.ZodObject,
  ...z(t)
});
ue.lazycreate = (e, t) => new ue({
  shape: e,
  unknownKeys: "strip",
  catchall: It.create(),
  typeName: q.ZodObject,
  ...z(t)
});
class _r extends G {
  _parse(t) {
    const { ctx: n } = this._processInputParams(t), r = this._def.options;
    function a(s) {
      for (const o of s)
        if (o.result.status === "valid")
          return o.result;
      for (const o of s)
        if (o.result.status === "dirty")
          return n.common.issues.push(...o.ctx.common.issues), o.result;
      const i = s.map((o) => new Qt(o.ctx.common.issues));
      return P(n, {
        code: w.invalid_union,
        unionErrors: i
      }), U;
    }
    if (n.common.async)
      return Promise.all(r.map(async (s) => {
        const i = {
          ...n,
          common: {
            ...n.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await s._parseAsync({
            data: n.data,
            path: n.path,
            parent: i
          }),
          ctx: i
        };
      })).then(a);
    {
      let s;
      const i = [];
      for (const c of r) {
        const u = {
          ...n,
          common: {
            ...n.common,
            issues: []
          },
          parent: null
        }, d = c._parseSync({
          data: n.data,
          path: n.path,
          parent: u
        });
        if (d.status === "valid")
          return d;
        d.status === "dirty" && !s && (s = { result: d, ctx: u }), u.common.issues.length && i.push(u.common.issues);
      }
      if (s)
        return n.common.issues.push(...s.ctx.common.issues), s.result;
      const o = i.map((c) => new Qt(c));
      return P(n, {
        code: w.invalid_union,
        unionErrors: o
      }), U;
    }
  }
  get options() {
    return this._def.options;
  }
}
_r.create = (e, t) => new _r({
  options: e,
  typeName: q.ZodUnion,
  ...z(t)
});
function Ma(e, t) {
  const n = Bt(e), r = Bt(t);
  if (e === t)
    return { valid: !0, data: e };
  if (n === O.object && r === O.object) {
    const a = H.objectKeys(t), s = H.objectKeys(e).filter((o) => a.indexOf(o) !== -1), i = { ...e, ...t };
    for (const o of s) {
      const c = Ma(e[o], t[o]);
      if (!c.valid)
        return { valid: !1 };
      i[o] = c.data;
    }
    return { valid: !0, data: i };
  } else if (n === O.array && r === O.array) {
    if (e.length !== t.length)
      return { valid: !1 };
    const a = [];
    for (let s = 0; s < e.length; s++) {
      const i = e[s], o = t[s], c = Ma(i, o);
      if (!c.valid)
        return { valid: !1 };
      a.push(c.data);
    }
    return { valid: !0, data: a };
  } else
    return n === O.date && r === O.date && +e == +t ? { valid: !0, data: e } : { valid: !1 };
}
let br = class extends G {
  _parse(t) {
    const { status: n, ctx: r } = this._processInputParams(t), a = (s, i) => {
      if (wi(s) || wi(i))
        return U;
      const o = Ma(s.value, i.value);
      return o.valid ? ((xi(s) || xi(i)) && n.dirty(), { status: n.value, value: o.data }) : (P(r, {
        code: w.invalid_intersection_types
      }), U);
    };
    return r.common.async ? Promise.all([
      this._def.left._parseAsync({
        data: r.data,
        path: r.path,
        parent: r
      }),
      this._def.right._parseAsync({
        data: r.data,
        path: r.path,
        parent: r
      })
    ]).then(([s, i]) => a(s, i)) : a(this._def.left._parseSync({
      data: r.data,
      path: r.path,
      parent: r
    }), this._def.right._parseSync({
      data: r.data,
      path: r.path,
      parent: r
    }));
  }
};
br.create = (e, t, n) => new br({
  left: e,
  right: t,
  typeName: q.ZodIntersection,
  ...z(n)
});
class en extends G {
  _parse(t) {
    const { status: n, ctx: r } = this._processInputParams(t);
    if (r.parsedType !== O.array)
      return P(r, {
        code: w.invalid_type,
        expected: O.array,
        received: r.parsedType
      }), U;
    if (r.data.length < this._def.items.length)
      return P(r, {
        code: w.too_small,
        minimum: this._def.items.length,
        inclusive: !0,
        exact: !1,
        type: "array"
      }), U;
    !this._def.rest && r.data.length > this._def.items.length && (P(r, {
      code: w.too_big,
      maximum: this._def.items.length,
      inclusive: !0,
      exact: !1,
      type: "array"
    }), n.dirty());
    const a = [...r.data].map((s, i) => {
      const o = this._def.items[i] || this._def.rest;
      return o ? o._parse(new At(r, s, r.path, i)) : null;
    }).filter((s) => !!s);
    return r.common.async ? Promise.all(a).then((s) => Ie.mergeArray(n, s)) : Ie.mergeArray(n, a);
  }
  get items() {
    return this._def.items;
  }
  rest(t) {
    return new en({
      ...this._def,
      rest: t
    });
  }
}
en.create = (e, t) => {
  if (!Array.isArray(e))
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  return new en({
    items: e,
    typeName: q.ZodTuple,
    rest: null,
    ...z(t)
  });
};
class Ri extends G {
  _parse(t) {
    const { status: n, ctx: r } = this._processInputParams(t);
    if (r.parsedType !== O.map)
      return P(r, {
        code: w.invalid_type,
        expected: O.map,
        received: r.parsedType
      }), U;
    const a = this._def.keyType, s = this._def.valueType, i = [...r.data.entries()].map(([o, c], u) => ({
      key: a._parse(new At(r, o, r.path, [u, "key"])),
      value: s._parse(new At(r, c, r.path, [u, "value"]))
    }));
    if (r.common.async) {
      const o = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (const c of i) {
          const u = await c.key, d = await c.value;
          if (u.status === "aborted" || d.status === "aborted")
            return U;
          (u.status === "dirty" || d.status === "dirty") && n.dirty(), o.set(u.value, d.value);
        }
        return { status: n.value, value: o };
      });
    } else {
      const o = /* @__PURE__ */ new Map();
      for (const c of i) {
        const u = c.key, d = c.value;
        if (u.status === "aborted" || d.status === "aborted")
          return U;
        (u.status === "dirty" || d.status === "dirty") && n.dirty(), o.set(u.value, d.value);
      }
      return { status: n.value, value: o };
    }
  }
}
Ri.create = (e, t, n) => new Ri({
  valueType: t,
  keyType: e,
  typeName: q.ZodMap,
  ...z(n)
});
let Ni = class Za extends G {
  _parse(t) {
    const { status: n, ctx: r } = this._processInputParams(t);
    if (r.parsedType !== O.set)
      return P(r, {
        code: w.invalid_type,
        expected: O.set,
        received: r.parsedType
      }), U;
    const a = this._def;
    a.minSize !== null && r.data.size < a.minSize.value && (P(r, {
      code: w.too_small,
      minimum: a.minSize.value,
      type: "set",
      inclusive: !0,
      exact: !1,
      message: a.minSize.message
    }), n.dirty()), a.maxSize !== null && r.data.size > a.maxSize.value && (P(r, {
      code: w.too_big,
      maximum: a.maxSize.value,
      type: "set",
      inclusive: !0,
      exact: !1,
      message: a.maxSize.message
    }), n.dirty());
    const s = this._def.valueType;
    function i(c) {
      const u = /* @__PURE__ */ new Set();
      for (const d of c) {
        if (d.status === "aborted")
          return U;
        d.status === "dirty" && n.dirty(), u.add(d.value);
      }
      return { status: n.value, value: u };
    }
    const o = [...r.data.values()].map((c, u) => s._parse(new At(r, c, r.path, u)));
    return r.common.async ? Promise.all(o).then((c) => i(c)) : i(o);
  }
  min(t, n) {
    return new Za({
      ...this._def,
      minSize: { value: t, message: E.toString(n) }
    });
  }
  max(t, n) {
    return new Za({
      ...this._def,
      maxSize: { value: t, message: E.toString(n) }
    });
  }
  size(t, n) {
    return this.min(t, n).max(t, n);
  }
  nonempty(t) {
    return this.min(1, t);
  }
};
Ni.create = (e, t) => new Ni({
  valueType: e,
  minSize: null,
  maxSize: null,
  typeName: q.ZodSet,
  ...z(t)
});
class Di extends G {
  get schema() {
    return this._def.getter();
  }
  _parse(t) {
    const { ctx: n } = this._processInputParams(t);
    return this._def.getter()._parse({ data: n.data, path: n.path, parent: n });
  }
}
Di.create = (e, t) => new Di({
  getter: e,
  typeName: q.ZodLazy,
  ...z(t)
});
let Fa = class extends G {
  _parse(t) {
    if (t.data !== this._def.value) {
      const n = this._getOrReturnCtx(t);
      return P(n, {
        received: n.data,
        code: w.invalid_literal,
        expected: this._def.value
      }), U;
    }
    return { status: "valid", value: t.data };
  }
  get value() {
    return this._def.value;
  }
};
Fa.create = (e, t) => new Fa({
  value: e,
  typeName: q.ZodLiteral,
  ...z(t)
});
function Mo(e, t) {
  return new As({
    values: e,
    typeName: q.ZodEnum,
    ...z(t)
  });
}
let As = class za extends G {
  _parse(t) {
    if (typeof t.data != "string") {
      const n = this._getOrReturnCtx(t), r = this._def.values;
      return P(n, {
        expected: H.joinValues(r),
        received: n.parsedType,
        code: w.invalid_type
      }), U;
    }
    if (this._def.values.indexOf(t.data) === -1) {
      const n = this._getOrReturnCtx(t), r = this._def.values;
      return P(n, {
        received: n.data,
        code: w.invalid_enum_value,
        options: r
      }), U;
    }
    return Ue(t.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const t = {};
    for (const n of this._def.values)
      t[n] = n;
    return t;
  }
  get Values() {
    const t = {};
    for (const n of this._def.values)
      t[n] = n;
    return t;
  }
  get Enum() {
    const t = {};
    for (const n of this._def.values)
      t[n] = n;
    return t;
  }
  extract(t) {
    return za.create(t);
  }
  exclude(t) {
    return za.create(this.options.filter((n) => !t.includes(n)));
  }
};
As.create = Mo;
let ji = class extends G {
  _parse(t) {
    const n = H.getValidEnumValues(this._def.values), r = this._getOrReturnCtx(t);
    if (r.parsedType !== O.string && r.parsedType !== O.number) {
      const a = H.objectValues(n);
      return P(r, {
        expected: H.joinValues(a),
        received: r.parsedType,
        code: w.invalid_type
      }), U;
    }
    if (n.indexOf(t.data) === -1) {
      const a = H.objectValues(n);
      return P(r, {
        received: r.data,
        code: w.invalid_enum_value,
        options: a
      }), U;
    }
    return Ue(t.data);
  }
  get enum() {
    return this._def.values;
  }
};
ji.create = (e, t) => new ji({
  values: e,
  typeName: q.ZodNativeEnum,
  ...z(t)
});
let wr = class extends G {
  unwrap() {
    return this._def.type;
  }
  _parse(t) {
    const { ctx: n } = this._processInputParams(t);
    if (n.parsedType !== O.promise && n.common.async === !1)
      return P(n, {
        code: w.invalid_type,
        expected: O.promise,
        received: n.parsedType
      }), U;
    const r = n.parsedType === O.promise ? n.data : Promise.resolve(n.data);
    return Ue(r.then((a) => this._def.type.parseAsync(a, {
      path: n.path,
      errorMap: n.common.contextualErrorMap
    })));
  }
};
wr.create = (e, t) => new wr({
  type: e,
  typeName: q.ZodPromise,
  ...z(t)
});
let gn = class extends G {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === q.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(t) {
    const { status: n, ctx: r } = this._processInputParams(t), a = this._def.effect || null;
    if (a.type === "preprocess") {
      const i = a.transform(r.data);
      return r.common.async ? Promise.resolve(i).then((o) => this._def.schema._parseAsync({
        data: o,
        path: r.path,
        parent: r
      })) : this._def.schema._parseSync({
        data: i,
        path: r.path,
        parent: r
      });
    }
    const s = {
      addIssue: (i) => {
        P(r, i), i.fatal ? n.abort() : n.dirty();
      },
      get path() {
        return r.path;
      }
    };
    if (s.addIssue = s.addIssue.bind(s), a.type === "refinement") {
      const i = (o) => {
        const c = a.refinement(o, s);
        if (r.common.async)
          return Promise.resolve(c);
        if (c instanceof Promise)
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        return o;
      };
      if (r.common.async === !1) {
        const o = this._def.schema._parseSync({
          data: r.data,
          path: r.path,
          parent: r
        });
        return o.status === "aborted" ? U : (o.status === "dirty" && n.dirty(), i(o.value), { status: n.value, value: o.value });
      } else
        return this._def.schema._parseAsync({ data: r.data, path: r.path, parent: r }).then((o) => o.status === "aborted" ? U : (o.status === "dirty" && n.dirty(), i(o.value).then(() => ({ status: n.value, value: o.value }))));
    }
    if (a.type === "transform")
      if (r.common.async === !1) {
        const i = this._def.schema._parseSync({
          data: r.data,
          path: r.path,
          parent: r
        });
        if (!Ra(i))
          return i;
        const o = a.transform(i.value, s);
        if (o instanceof Promise)
          throw new Error("Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.");
        return { status: n.value, value: o };
      } else
        return this._def.schema._parseAsync({ data: r.data, path: r.path, parent: r }).then((i) => Ra(i) ? Promise.resolve(a.transform(i.value, s)).then((o) => ({ status: n.value, value: o })) : i);
    H.assertNever(a);
  }
};
gn.create = (e, t, n) => new gn({
  schema: e,
  typeName: q.ZodEffects,
  effect: t,
  ...z(n)
});
gn.createWithPreprocess = (e, t, n) => new gn({
  schema: t,
  effect: { type: "preprocess", transform: e },
  typeName: q.ZodEffects,
  ...z(n)
});
let Ot = class extends G {
  _parse(t) {
    return this._getType(t) === O.undefined ? Ue(void 0) : this._def.innerType._parse(t);
  }
  unwrap() {
    return this._def.innerType;
  }
};
Ot.create = (e, t) => new Ot({
  innerType: e,
  typeName: q.ZodOptional,
  ...z(t)
});
let _n = class extends G {
  _parse(t) {
    return this._getType(t) === O.null ? Ue(null) : this._def.innerType._parse(t);
  }
  unwrap() {
    return this._def.innerType;
  }
};
_n.create = (e, t) => new _n({
  innerType: e,
  typeName: q.ZodNullable,
  ...z(t)
});
class Ua extends G {
  _parse(t) {
    const { ctx: n } = this._processInputParams(t);
    let r = n.data;
    return n.parsedType === O.undefined && (r = this._def.defaultValue()), this._def.innerType._parse({
      data: r,
      path: n.path,
      parent: n
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
}
Ua.create = (e, t) => new Ua({
  innerType: e,
  typeName: q.ZodDefault,
  defaultValue: typeof t.default == "function" ? t.default : () => t.default,
  ...z(t)
});
let Va = class extends G {
  _parse(t) {
    const { ctx: n } = this._processInputParams(t), r = {
      ...n,
      common: {
        ...n.common,
        issues: []
      }
    }, a = this._def.innerType._parse({
      data: r.data,
      path: r.path,
      parent: {
        ...r
      }
    });
    return Na(a) ? a.then((s) => ({
      status: "valid",
      value: s.status === "valid" ? s.value : this._def.catchValue({
        get error() {
          return new Qt(r.common.issues);
        },
        input: r.data
      })
    })) : {
      status: "valid",
      value: a.status === "valid" ? a.value : this._def.catchValue({
        get error() {
          return new Qt(r.common.issues);
        },
        input: r.data
      })
    };
  }
  removeCatch() {
    return this._def.innerType;
  }
};
Va.create = (e, t) => new Va({
  innerType: e,
  typeName: q.ZodCatch,
  catchValue: typeof t.catch == "function" ? t.catch : () => t.catch,
  ...z(t)
});
let qi = class extends G {
  _parse(t) {
    if (this._getType(t) !== O.nan) {
      const n = this._getOrReturnCtx(t);
      return P(n, {
        code: w.invalid_type,
        expected: O.nan,
        received: n.parsedType
      }), U;
    }
    return { status: "valid", value: t.data };
  }
};
qi.create = (e) => new qi({
  typeName: q.ZodNaN,
  ...z(e)
});
class $d extends G {
  _parse(t) {
    const { ctx: n } = this._processInputParams(t), r = n.data;
    return this._def.type._parse({
      data: r,
      path: n.path,
      parent: n
    });
  }
  unwrap() {
    return this._def.type;
  }
}
let Ld = class Zo extends G {
  _parse(t) {
    const { status: n, ctx: r } = this._processInputParams(t);
    if (r.common.async)
      return (async () => {
        const a = await this._def.in._parseAsync({
          data: r.data,
          path: r.path,
          parent: r
        });
        return a.status === "aborted" ? U : a.status === "dirty" ? (n.dirty(), Td(a.value)) : this._def.out._parseAsync({
          data: a.value,
          path: r.path,
          parent: r
        });
      })();
    {
      const a = this._def.in._parseSync({
        data: r.data,
        path: r.path,
        parent: r
      });
      return a.status === "aborted" ? U : a.status === "dirty" ? (n.dirty(), {
        status: "dirty",
        value: a.value
      }) : this._def.out._parseSync({
        data: a.value,
        path: r.path,
        parent: r
      });
    }
  }
  static create(t, n) {
    return new Zo({
      in: t,
      out: n,
      typeName: q.ZodPipeline
    });
  }
};
ue.lazycreate;
var q;
(function(e) {
  e.ZodString = "ZodString", e.ZodNumber = "ZodNumber", e.ZodNaN = "ZodNaN", e.ZodBigInt = "ZodBigInt", e.ZodBoolean = "ZodBoolean", e.ZodDate = "ZodDate", e.ZodSymbol = "ZodSymbol", e.ZodUndefined = "ZodUndefined", e.ZodNull = "ZodNull", e.ZodAny = "ZodAny", e.ZodUnknown = "ZodUnknown", e.ZodNever = "ZodNever", e.ZodVoid = "ZodVoid", e.ZodArray = "ZodArray", e.ZodObject = "ZodObject", e.ZodUnion = "ZodUnion", e.ZodDiscriminatedUnion = "ZodDiscriminatedUnion", e.ZodIntersection = "ZodIntersection", e.ZodTuple = "ZodTuple", e.ZodRecord = "ZodRecord", e.ZodMap = "ZodMap", e.ZodSet = "ZodSet", e.ZodFunction = "ZodFunction", e.ZodLazy = "ZodLazy", e.ZodLiteral = "ZodLiteral", e.ZodEnum = "ZodEnum", e.ZodEffects = "ZodEffects", e.ZodNativeEnum = "ZodNativeEnum", e.ZodOptional = "ZodOptional", e.ZodNullable = "ZodNullable", e.ZodDefault = "ZodDefault", e.ZodCatch = "ZodCatch", e.ZodPromise = "ZodPromise", e.ZodBranded = "ZodBranded", e.ZodPipeline = "ZodPipeline";
})(q || (q = {}));
const Y = Da.create, Ur = ja.create, Zn = La.create;
It.create;
const Fn = tt.create, W = ue.create;
ue.strictCreate;
const Ce = _r.create;
br.create;
en.create;
const X = Fa.create;
As.create;
wr.create;
Ot.create;
_n.create;
const Fo = W({
  address: Y(),
  label: Y(),
  appearanceId: Ur()
}), Kn = W({
  publicKey: Y(),
  signature: Y(),
  curve: Ce([X("curve25519"), X("secp256k1")])
}), Md = W({
  accountAddress: Y(),
  proof: Kn
}), Gn = W({ identityAddress: Y(), label: Y() }), $i = {
  western: "western",
  eastern: "eastern"
}, Zd = Ce([
  X($i.eastern),
  X($i.western)
]), zo = W({
  variant: Zd,
  familyName: Y(),
  nickname: Y(),
  givenNames: Y()
}), nt = W({
  quantifier: Ce([X("exactly"), X("atLeast")]),
  quantity: Ur().gte(0)
}), Wa = W({
  challenge: Y().optional(),
  numberOfAccounts: nt
}), Ba = W({
  accounts: Fn(Fo),
  challenge: Y().optional(),
  proofs: Fn(Md).optional()
}).refine((e) => {
  var t;
  return e.challenge || e != null && e.proofs ? e.challenge && ((t = e == null ? void 0 : e.proofs) == null ? void 0 : t.length) : !0;
}, "missing challenge or proofs"), xr = W({
  isRequestingName: Zn().optional(),
  numberOfRequestedEmailAddresses: nt.optional(),
  numberOfRequestedPhoneNumbers: nt.optional()
}), Ka = W({
  name: zo.optional(),
  emailAddresses: Fn(Y()).optional(),
  phoneNumbers: Fn(Y()).optional()
}), Fd = W({
  accounts: Zn(),
  personaData: Zn()
}), Vg = W({
  persona: Gn,
  challenge: Y().optional(),
  proof: Kn.optional()
}).refine((e) => e.challenge || e.proof ? e.challenge && e.proof : !0, "missing challenge or proof"), zd = W({
  discriminator: X("unauthorizedRequest"),
  oneTimeAccounts: Wa.optional(),
  oneTimePersonaData: xr.optional()
}), Ud = W({
  discriminator: X("usePersona"),
  identityAddress: Y()
}), Vd = W({
  discriminator: X("loginWithoutChallenge")
}), Wd = W({
  discriminator: X("loginWithChallenge"),
  challenge: Y()
}), Bd = Ce([
  Vd,
  Wd
]), Kd = Ce([
  Ud,
  Bd
]), Gd = W({
  discriminator: X("authorizedRequest"),
  auth: Kd,
  reset: Fd.optional(),
  oneTimeAccounts: Wa.optional(),
  ongoingAccounts: Wa.optional(),
  oneTimePersonaData: xr.optional(),
  ongoingPersonaData: xr.optional()
}), Hd = Ce([
  zd,
  Gd
]), Jd = W({
  transactionManifest: Y(),
  version: Ur(),
  blobs: Fn(Y()).optional(),
  message: Y().optional()
}), Yd = W({
  discriminator: X("transaction"),
  send: Jd
}), Xd = W({
  transactionIntentHash: Y()
}), Qd = W({
  discriminator: X("transaction"),
  send: Xd
}), ef = W({
  discriminator: X("cancelRequest")
}), tf = Ce([
  Hd,
  Yd,
  ef
]), Uo = W({
  version: X(2),
  networkId: Ur(),
  dAppDefinitionAddress: Y()
}), nf = W({
  interactionId: Y(),
  metadata: Uo,
  items: tf
}), rf = W({
  discriminator: X("unauthorizedRequest"),
  oneTimeAccounts: Ba.optional(),
  oneTimePersonaData: Ka.optional()
}), af = W({
  discriminator: X("loginWithoutChallenge"),
  persona: Gn
}), sf = W({
  discriminator: X("loginWithChallenge"),
  persona: Gn,
  challenge: Y(),
  proof: Kn
}), of = Ce([
  af,
  sf
]), uf = W({
  discriminator: X("usePersona"),
  persona: Gn
}), cf = Ce([
  uf,
  of
]), lf = W({
  discriminator: X("authorizedRequest"),
  auth: cf,
  oneTimeAccounts: Ba.optional(),
  ongoingAccounts: Ba.optional(),
  oneTimePersonaData: Ka.optional(),
  ongoingPersonaData: Ka.optional()
}), df = Ce([
  rf,
  lf
]), ff = Ce([
  df,
  Qd
]), hf = W({
  discriminator: X("success"),
  interactionId: Y(),
  items: ff
}), pf = W({
  discriminator: X("failure"),
  interactionId: Y(),
  error: Y(),
  message: Y().optional()
}), Vo = Ce([
  hf,
  pf
]), Wg = W({
  interactionId: Y(),
  discriminator: X("extensionStatus")
}), ln = {
  extensionStatus: "extensionStatus",
  receivedByExtension: "receivedByExtension",
  receivedByWallet: "receivedByWallet",
  requestCancelSuccess: "requestCancelSuccess",
  requestCancelFail: "requestCancelFail"
}, Bg = W({
  eventType: X(ln.extensionStatus),
  interactionId: Y(),
  isWalletLinked: Zn(),
  isExtensionAvailable: Zn()
}), mf = W({
  eventType: Ce([
    X(ln.extensionStatus),
    X(ln.receivedByExtension),
    X(ln.receivedByWallet),
    X(ln.requestCancelSuccess),
    X(ln.requestCancelFail)
  ]),
  interactionId: Y()
});
Ce([
  mf,
  Vo
]);
const ir = {
  outgoingMessage: "radix#chromeExtension#send",
  incomingMessage: "radix#chromeExtension#receive"
}, yf = (e, t) => ct.fromPromise(
  e.parseAsync(t),
  (n) => n.issues
), Wo = (e) => (t, n, r = crypto.randomUUID()) => {
  const a = {
    items: n,
    interactionId: r,
    metadata: t
  };
  return yf(nf, a).mapErr((s) => (e == null || e.error(" invalidWalletInteraction", s), Xt(
    $n.walletRequestValidation,
    a.interactionId
  )));
}, Kg = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  walletInteractionFactory: Wo
}, Symbol.toStringTag, { value: "Module" })), vf = (e) => e, $n = {
  rejectedByUser: "rejectedByUser",
  missingExtension: "missingExtension",
  canceledByUser: "canceledByUser",
  walletRequestValidation: "walletRequestValidation",
  walletResponseValidation: "walletResponseValidation",
  wrongNetwork: "wrongNetwork",
  failedToPrepareTransaction: "failedToPrepareTransaction",
  failedToCompileTransaction: "failedToCompileTransaction",
  failedToSignTransaction: "failedToSignTransaction",
  failedToSubmitTransaction: "failedToSubmitTransaction",
  failedToPollSubmittedTransaction: "failedToPollSubmittedTransaction",
  submittedTransactionWasDuplicate: "submittedTransactionWasDuplicate",
  submittedTransactionHasFailedTransactionStatus: "submittedTransactionHasFailedTransactionStatus",
  submittedTransactionHasRejectedTransactionStatus: "submittedTransactionHasRejectedTransactionStatus",
  failedToFindAccountWithEnoughFundsToLockFee: "failedToFindAccountWithEnoughFundsToLockFee",
  wrongAccountType: "wrongAccountType",
  unknownWebsite: "unknownWebsite",
  radixJsonNotFound: "radixJsonNotFound",
  unknownDappDefinitionAddress: "unknownDappDefinitionAddress",
  invalidPersona: "invalidPersona"
}, gf = (/* @__PURE__ */ new Map()).set($n.missingExtension, "extension could not be found").set($n.rejectedByUser, "user rejected request").set($n.canceledByUser, "user has canceled the request"), Xt = (e, t, n) => ({
  error: e,
  interactionId: t,
  message: n || gf.get(e) || ""
}), Li = (e) => ct.fromPromise(
  Vo.parseAsync(e),
  (t) => t.issues
).andThen(
  (t) => t.discriminator === "success" ? et(t) : Fe(t)
).mapErr(() => Xt("walletResponseValidation", "")), _f = (e, t) => {
  const n = e.logger, r = Wo(n);
  return {
    request: (a, s = {}) => r(e, a).andThen(
      (i) => t.send(i, s)
    ).andThen(Li).map((i) => i.items),
    sendTransaction: (a, s = {}) => r(e, {
      discriminator: "transaction",
      send: a
    }).andThen(
      (i) => t.send(i, s)
    ).andThen(Li).map(
      (i) => i.items.send
    ),
    extensionStatus$: t.extensionStatus$,
    openPopup: t.openPopup
  };
};
var Ga = function(e, t) {
  return Ga = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n, r) {
    n.__proto__ = r;
  } || function(n, r) {
    for (var a in r)
      Object.prototype.hasOwnProperty.call(r, a) && (n[a] = r[a]);
  }, Ga(e, t);
};
function Nt(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
  Ga(e, t);
  function n() {
    this.constructor = e;
  }
  e.prototype = t === null ? Object.create(t) : (n.prototype = t.prototype, new n());
}
function bf(e, t, n, r) {
  function a(s) {
    return s instanceof n ? s : new n(function(i) {
      i(s);
    });
  }
  return new (n || (n = Promise))(function(s, i) {
    function o(d) {
      try {
        u(r.next(d));
      } catch (h) {
        i(h);
      }
    }
    function c(d) {
      try {
        u(r.throw(d));
      } catch (h) {
        i(h);
      }
    }
    function u(d) {
      d.done ? s(d.value) : a(d.value).then(o, c);
    }
    u((r = r.apply(e, t || [])).next());
  });
}
function Bo(e, t) {
  var n = { label: 0, sent: function() {
    if (s[0] & 1)
      throw s[1];
    return s[1];
  }, trys: [], ops: [] }, r, a, s, i;
  return i = { next: o(0), throw: o(1), return: o(2) }, typeof Symbol == "function" && (i[Symbol.iterator] = function() {
    return this;
  }), i;
  function o(u) {
    return function(d) {
      return c([u, d]);
    };
  }
  function c(u) {
    if (r)
      throw new TypeError("Generator is already executing.");
    for (; i && (i = 0, u[0] && (n = 0)), n; )
      try {
        if (r = 1, a && (s = u[0] & 2 ? a.return : u[0] ? a.throw || ((s = a.return) && s.call(a), 0) : a.next) && !(s = s.call(a, u[1])).done)
          return s;
        switch (a = 0, s && (u = [u[0] & 2, s.value]), u[0]) {
          case 0:
          case 1:
            s = u;
            break;
          case 4:
            return n.label++, { value: u[1], done: !1 };
          case 5:
            n.label++, a = u[1], u = [0];
            continue;
          case 7:
            u = n.ops.pop(), n.trys.pop();
            continue;
          default:
            if (s = n.trys, !(s = s.length > 0 && s[s.length - 1]) && (u[0] === 6 || u[0] === 2)) {
              n = 0;
              continue;
            }
            if (u[0] === 3 && (!s || u[1] > s[0] && u[1] < s[3])) {
              n.label = u[1];
              break;
            }
            if (u[0] === 6 && n.label < s[1]) {
              n.label = s[1], s = u;
              break;
            }
            if (s && n.label < s[2]) {
              n.label = s[2], n.ops.push(u);
              break;
            }
            s[2] && n.ops.pop(), n.trys.pop();
            continue;
        }
        u = t.call(e, n);
      } catch (d) {
        u = [6, d], a = 0;
      } finally {
        r = s = 0;
      }
    if (u[0] & 5)
      throw u[1];
    return { value: u[0] ? u[1] : void 0, done: !0 };
  }
}
function bn(e) {
  var t = typeof Symbol == "function" && Symbol.iterator, n = t && e[t], r = 0;
  if (n)
    return n.call(e);
  if (e && typeof e.length == "number")
    return {
      next: function() {
        return e && r >= e.length && (e = void 0), { value: e && e[r++], done: !e };
      }
    };
  throw new TypeError(t ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function wn(e, t) {
  var n = typeof Symbol == "function" && e[Symbol.iterator];
  if (!n)
    return e;
  var r = n.call(e), a, s = [], i;
  try {
    for (; (t === void 0 || t-- > 0) && !(a = r.next()).done; )
      s.push(a.value);
  } catch (o) {
    i = { error: o };
  } finally {
    try {
      a && !a.done && (n = r.return) && n.call(r);
    } finally {
      if (i)
        throw i.error;
    }
  }
  return s;
}
function xn(e, t, n) {
  if (n || arguments.length === 2)
    for (var r = 0, a = t.length, s; r < a; r++)
      (s || !(r in t)) && (s || (s = Array.prototype.slice.call(t, 0, r)), s[r] = t[r]);
  return e.concat(s || Array.prototype.slice.call(t));
}
function mn(e) {
  return this instanceof mn ? (this.v = e, this) : new mn(e);
}
function wf(e, t, n) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var r = n.apply(e, t || []), a, s = [];
  return a = {}, i("next"), i("throw"), i("return"), a[Symbol.asyncIterator] = function() {
    return this;
  }, a;
  function i(p) {
    r[p] && (a[p] = function(v) {
      return new Promise(function(T, g) {
        s.push([p, v, T, g]) > 1 || o(p, v);
      });
    });
  }
  function o(p, v) {
    try {
      c(r[p](v));
    } catch (T) {
      h(s[0][3], T);
    }
  }
  function c(p) {
    p.value instanceof mn ? Promise.resolve(p.value.v).then(u, d) : h(s[0][2], p);
  }
  function u(p) {
    o("next", p);
  }
  function d(p) {
    o("throw", p);
  }
  function h(p, v) {
    p(v), s.shift(), s.length && o(s[0][0], s[0][1]);
  }
}
function xf(e) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var t = e[Symbol.asyncIterator], n;
  return t ? t.call(e) : (e = typeof bn == "function" ? bn(e) : e[Symbol.iterator](), n = {}, r("next"), r("throw"), r("return"), n[Symbol.asyncIterator] = function() {
    return this;
  }, n);
  function r(s) {
    n[s] = e[s] && function(i) {
      return new Promise(function(o, c) {
        i = e[s](i), a(o, c, i.done, i.value);
      });
    };
  }
  function a(s, i, o, c) {
    Promise.resolve(c).then(function(u) {
      s({ value: u, done: o });
    }, i);
  }
}
function de(e) {
  return typeof e == "function";
}
function Is(e) {
  var t = function(r) {
    Error.call(r), r.stack = new Error().stack;
  }, n = e(t);
  return n.prototype = Object.create(Error.prototype), n.prototype.constructor = n, n;
}
var pa = Is(function(e) {
  return function(t) {
    e(this), this.message = t ? t.length + ` errors occurred during unsubscription:
` + t.map(function(n, r) {
      return r + 1 + ") " + n.toString();
    }).join(`
  `) : "", this.name = "UnsubscriptionError", this.errors = t;
  };
});
function kr(e, t) {
  if (e) {
    var n = e.indexOf(t);
    0 <= n && e.splice(n, 1);
  }
}
var An = function() {
  function e(t) {
    this.initialTeardown = t, this.closed = !1, this._parentage = null, this._finalizers = null;
  }
  return e.prototype.unsubscribe = function() {
    var t, n, r, a, s;
    if (!this.closed) {
      this.closed = !0;
      var i = this._parentage;
      if (i)
        if (this._parentage = null, Array.isArray(i))
          try {
            for (var o = bn(i), c = o.next(); !c.done; c = o.next()) {
              var u = c.value;
              u.remove(this);
            }
          } catch (g) {
            t = { error: g };
          } finally {
            try {
              c && !c.done && (n = o.return) && n.call(o);
            } finally {
              if (t)
                throw t.error;
            }
          }
        else
          i.remove(this);
      var d = this.initialTeardown;
      if (de(d))
        try {
          d();
        } catch (g) {
          s = g instanceof pa ? g.errors : [g];
        }
      var h = this._finalizers;
      if (h) {
        this._finalizers = null;
        try {
          for (var p = bn(h), v = p.next(); !v.done; v = p.next()) {
            var T = v.value;
            try {
              Mi(T);
            } catch (g) {
              s = s ?? [], g instanceof pa ? s = xn(xn([], wn(s)), wn(g.errors)) : s.push(g);
            }
          }
        } catch (g) {
          r = { error: g };
        } finally {
          try {
            v && !v.done && (a = p.return) && a.call(p);
          } finally {
            if (r)
              throw r.error;
          }
        }
      }
      if (s)
        throw new pa(s);
    }
  }, e.prototype.add = function(t) {
    var n;
    if (t && t !== this)
      if (this.closed)
        Mi(t);
      else {
        if (t instanceof e) {
          if (t.closed || t._hasParent(this))
            return;
          t._addParent(this);
        }
        (this._finalizers = (n = this._finalizers) !== null && n !== void 0 ? n : []).push(t);
      }
  }, e.prototype._hasParent = function(t) {
    var n = this._parentage;
    return n === t || Array.isArray(n) && n.includes(t);
  }, e.prototype._addParent = function(t) {
    var n = this._parentage;
    this._parentage = Array.isArray(n) ? (n.push(t), n) : n ? [n, t] : t;
  }, e.prototype._removeParent = function(t) {
    var n = this._parentage;
    n === t ? this._parentage = null : Array.isArray(n) && kr(n, t);
  }, e.prototype.remove = function(t) {
    var n = this._finalizers;
    n && kr(n, t), t instanceof e && t._removeParent(this);
  }, e.EMPTY = function() {
    var t = new e();
    return t.closed = !0, t;
  }(), e;
}(), Ko = An.EMPTY;
function Go(e) {
  return e instanceof An || e && "closed" in e && de(e.remove) && de(e.add) && de(e.unsubscribe);
}
function Mi(e) {
  de(e) ? e() : e.unsubscribe();
}
var Ho = {
  onUnhandledError: null,
  onStoppedNotification: null,
  Promise: void 0,
  useDeprecatedSynchronousErrorHandling: !1,
  useDeprecatedNextContext: !1
}, kf = {
  setTimeout: function(e, t) {
    for (var n = [], r = 2; r < arguments.length; r++)
      n[r - 2] = arguments[r];
    return setTimeout.apply(void 0, xn([e, t], wn(n)));
  },
  clearTimeout: function(e) {
    return clearTimeout(e);
  },
  delegate: void 0
};
function Jo(e) {
  kf.setTimeout(function() {
    throw e;
  });
}
function Ha() {
}
function fr(e) {
  e();
}
var Rs = function(e) {
  Nt(t, e);
  function t(n) {
    var r = e.call(this) || this;
    return r.isStopped = !1, n ? (r.destination = n, Go(n) && n.add(r)) : r.destination = Of, r;
  }
  return t.create = function(n, r, a) {
    return new kn(n, r, a);
  }, t.prototype.next = function(n) {
    this.isStopped || this._next(n);
  }, t.prototype.error = function(n) {
    this.isStopped || (this.isStopped = !0, this._error(n));
  }, t.prototype.complete = function() {
    this.isStopped || (this.isStopped = !0, this._complete());
  }, t.prototype.unsubscribe = function() {
    this.closed || (this.isStopped = !0, e.prototype.unsubscribe.call(this), this.destination = null);
  }, t.prototype._next = function(n) {
    this.destination.next(n);
  }, t.prototype._error = function(n) {
    try {
      this.destination.error(n);
    } finally {
      this.unsubscribe();
    }
  }, t.prototype._complete = function() {
    try {
      this.destination.complete();
    } finally {
      this.unsubscribe();
    }
  }, t;
}(An), Sf = Function.prototype.bind;
function ma(e, t) {
  return Sf.call(e, t);
}
var Tf = function() {
  function e(t) {
    this.partialObserver = t;
  }
  return e.prototype.next = function(t) {
    var n = this.partialObserver;
    if (n.next)
      try {
        n.next(t);
      } catch (r) {
        or(r);
      }
  }, e.prototype.error = function(t) {
    var n = this.partialObserver;
    if (n.error)
      try {
        n.error(t);
      } catch (r) {
        or(r);
      }
    else
      or(t);
  }, e.prototype.complete = function() {
    var t = this.partialObserver;
    if (t.complete)
      try {
        t.complete();
      } catch (n) {
        or(n);
      }
  }, e;
}(), kn = function(e) {
  Nt(t, e);
  function t(n, r, a) {
    var s = e.call(this) || this, i;
    if (de(n) || !n)
      i = {
        next: n ?? void 0,
        error: r ?? void 0,
        complete: a ?? void 0
      };
    else {
      var o;
      s && Ho.useDeprecatedNextContext ? (o = Object.create(n), o.unsubscribe = function() {
        return s.unsubscribe();
      }, i = {
        next: n.next && ma(n.next, o),
        error: n.error && ma(n.error, o),
        complete: n.complete && ma(n.complete, o)
      }) : i = n;
    }
    return s.destination = new Tf(i), s;
  }
  return t;
}(Rs);
function or(e) {
  Jo(e);
}
function Pf(e) {
  throw e;
}
var Of = {
  closed: !0,
  next: Ha,
  error: Pf,
  complete: Ha
}, Ns = function() {
  return typeof Symbol == "function" && Symbol.observable || "@@observable";
}();
function Vr(e) {
  return e;
}
function Ef(e) {
  return e.length === 0 ? Vr : e.length === 1 ? e[0] : function(t) {
    return e.reduce(function(n, r) {
      return r(n);
    }, t);
  };
}
var Oe = function() {
  function e(t) {
    t && (this._subscribe = t);
  }
  return e.prototype.lift = function(t) {
    var n = new e();
    return n.source = this, n.operator = t, n;
  }, e.prototype.subscribe = function(t, n, r) {
    var a = this, s = Af(t) ? t : new kn(t, n, r);
    return fr(function() {
      var i = a, o = i.operator, c = i.source;
      s.add(o ? o.call(s, c) : c ? a._subscribe(s) : a._trySubscribe(s));
    }), s;
  }, e.prototype._trySubscribe = function(t) {
    try {
      return this._subscribe(t);
    } catch (n) {
      t.error(n);
    }
  }, e.prototype.forEach = function(t, n) {
    var r = this;
    return n = Zi(n), new n(function(a, s) {
      var i = new kn({
        next: function(o) {
          try {
            t(o);
          } catch (c) {
            s(c), i.unsubscribe();
          }
        },
        error: s,
        complete: a
      });
      r.subscribe(i);
    });
  }, e.prototype._subscribe = function(t) {
    var n;
    return (n = this.source) === null || n === void 0 ? void 0 : n.subscribe(t);
  }, e.prototype[Ns] = function() {
    return this;
  }, e.prototype.pipe = function() {
    for (var t = [], n = 0; n < arguments.length; n++)
      t[n] = arguments[n];
    return Ef(t)(this);
  }, e.prototype.toPromise = function(t) {
    var n = this;
    return t = Zi(t), new t(function(r, a) {
      var s;
      n.subscribe(function(i) {
        return s = i;
      }, function(i) {
        return a(i);
      }, function() {
        return r(s);
      });
    });
  }, e.create = function(t) {
    return new e(t);
  }, e;
}();
function Zi(e) {
  var t;
  return (t = e ?? Ho.Promise) !== null && t !== void 0 ? t : Promise;
}
function Cf(e) {
  return e && de(e.next) && de(e.error) && de(e.complete);
}
function Af(e) {
  return e && e instanceof Rs || Cf(e) && Go(e);
}
function If(e) {
  return de(e == null ? void 0 : e.lift);
}
function Ve(e) {
  return function(t) {
    if (If(t))
      return t.lift(function(n) {
        try {
          return e(n, this);
        } catch (r) {
          this.error(r);
        }
      });
    throw new TypeError("Unable to lift unknown Observable type");
  };
}
function Re(e, t, n, r, a) {
  return new Rf(e, t, n, r, a);
}
var Rf = function(e) {
  Nt(t, e);
  function t(n, r, a, s, i, o) {
    var c = e.call(this, n) || this;
    return c.onFinalize = i, c.shouldUnsubscribe = o, c._next = r ? function(u) {
      try {
        r(u);
      } catch (d) {
        n.error(d);
      }
    } : e.prototype._next, c._error = s ? function(u) {
      try {
        s(u);
      } catch (d) {
        n.error(d);
      } finally {
        this.unsubscribe();
      }
    } : e.prototype._error, c._complete = a ? function() {
      try {
        a();
      } catch (u) {
        n.error(u);
      } finally {
        this.unsubscribe();
      }
    } : e.prototype._complete, c;
  }
  return t.prototype.unsubscribe = function() {
    var n;
    if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) {
      var r = this.closed;
      e.prototype.unsubscribe.call(this), !r && ((n = this.onFinalize) === null || n === void 0 || n.call(this));
    }
  }, t;
}(Rs), Nf = Is(function(e) {
  return function() {
    e(this), this.name = "ObjectUnsubscribedError", this.message = "object unsubscribed";
  };
}), Jt = function(e) {
  Nt(t, e);
  function t() {
    var n = e.call(this) || this;
    return n.closed = !1, n.currentObservers = null, n.observers = [], n.isStopped = !1, n.hasError = !1, n.thrownError = null, n;
  }
  return t.prototype.lift = function(n) {
    var r = new Fi(this, this);
    return r.operator = n, r;
  }, t.prototype._throwIfClosed = function() {
    if (this.closed)
      throw new Nf();
  }, t.prototype.next = function(n) {
    var r = this;
    fr(function() {
      var a, s;
      if (r._throwIfClosed(), !r.isStopped) {
        r.currentObservers || (r.currentObservers = Array.from(r.observers));
        try {
          for (var i = bn(r.currentObservers), o = i.next(); !o.done; o = i.next()) {
            var c = o.value;
            c.next(n);
          }
        } catch (u) {
          a = { error: u };
        } finally {
          try {
            o && !o.done && (s = i.return) && s.call(i);
          } finally {
            if (a)
              throw a.error;
          }
        }
      }
    });
  }, t.prototype.error = function(n) {
    var r = this;
    fr(function() {
      if (r._throwIfClosed(), !r.isStopped) {
        r.hasError = r.isStopped = !0, r.thrownError = n;
        for (var a = r.observers; a.length; )
          a.shift().error(n);
      }
    });
  }, t.prototype.complete = function() {
    var n = this;
    fr(function() {
      if (n._throwIfClosed(), !n.isStopped) {
        n.isStopped = !0;
        for (var r = n.observers; r.length; )
          r.shift().complete();
      }
    });
  }, t.prototype.unsubscribe = function() {
    this.isStopped = this.closed = !0, this.observers = this.currentObservers = null;
  }, Object.defineProperty(t.prototype, "observed", {
    get: function() {
      var n;
      return ((n = this.observers) === null || n === void 0 ? void 0 : n.length) > 0;
    },
    enumerable: !1,
    configurable: !0
  }), t.prototype._trySubscribe = function(n) {
    return this._throwIfClosed(), e.prototype._trySubscribe.call(this, n);
  }, t.prototype._subscribe = function(n) {
    return this._throwIfClosed(), this._checkFinalizedStatuses(n), this._innerSubscribe(n);
  }, t.prototype._innerSubscribe = function(n) {
    var r = this, a = this, s = a.hasError, i = a.isStopped, o = a.observers;
    return s || i ? Ko : (this.currentObservers = null, o.push(n), new An(function() {
      r.currentObservers = null, kr(o, n);
    }));
  }, t.prototype._checkFinalizedStatuses = function(n) {
    var r = this, a = r.hasError, s = r.thrownError, i = r.isStopped;
    a ? n.error(s) : i && n.complete();
  }, t.prototype.asObservable = function() {
    var n = new Oe();
    return n.source = this, n;
  }, t.create = function(n, r) {
    return new Fi(n, r);
  }, t;
}(Oe), Fi = function(e) {
  Nt(t, e);
  function t(n, r) {
    var a = e.call(this) || this;
    return a.destination = n, a.source = r, a;
  }
  return t.prototype.next = function(n) {
    var r, a;
    (a = (r = this.destination) === null || r === void 0 ? void 0 : r.next) === null || a === void 0 || a.call(r, n);
  }, t.prototype.error = function(n) {
    var r, a;
    (a = (r = this.destination) === null || r === void 0 ? void 0 : r.error) === null || a === void 0 || a.call(r, n);
  }, t.prototype.complete = function() {
    var n, r;
    (r = (n = this.destination) === null || n === void 0 ? void 0 : n.complete) === null || r === void 0 || r.call(n);
  }, t.prototype._subscribe = function(n) {
    var r, a;
    return (a = (r = this.source) === null || r === void 0 ? void 0 : r.subscribe(n)) !== null && a !== void 0 ? a : Ko;
  }, t;
}(Jt), Df = {
  now: function() {
    return Date.now();
  },
  delegate: void 0
}, jf = function(e) {
  Nt(t, e);
  function t(n, r) {
    return e.call(this) || this;
  }
  return t.prototype.schedule = function(n, r) {
    return this;
  }, t;
}(An), Ja = {
  setInterval: function(e, t) {
    for (var n = [], r = 2; r < arguments.length; r++)
      n[r - 2] = arguments[r];
    var a = Ja.delegate;
    return a != null && a.setInterval ? a.setInterval.apply(a, xn([e, t], wn(n))) : setInterval.apply(void 0, xn([e, t], wn(n)));
  },
  clearInterval: function(e) {
    return clearInterval(e);
  },
  delegate: void 0
}, qf = function(e) {
  Nt(t, e);
  function t(n, r) {
    var a = e.call(this, n, r) || this;
    return a.scheduler = n, a.work = r, a.pending = !1, a;
  }
  return t.prototype.schedule = function(n, r) {
    var a;
    if (r === void 0 && (r = 0), this.closed)
      return this;
    this.state = n;
    var s = this.id, i = this.scheduler;
    return s != null && (this.id = this.recycleAsyncId(i, s, r)), this.pending = !0, this.delay = r, this.id = (a = this.id) !== null && a !== void 0 ? a : this.requestAsyncId(i, this.id, r), this;
  }, t.prototype.requestAsyncId = function(n, r, a) {
    return a === void 0 && (a = 0), Ja.setInterval(n.flush.bind(n, this), a);
  }, t.prototype.recycleAsyncId = function(n, r, a) {
    if (a === void 0 && (a = 0), a != null && this.delay === a && this.pending === !1)
      return r;
    r != null && Ja.clearInterval(r);
  }, t.prototype.execute = function(n, r) {
    if (this.closed)
      return new Error("executing a cancelled action");
    this.pending = !1;
    var a = this._execute(n, r);
    if (a)
      return a;
    this.pending === !1 && this.id != null && (this.id = this.recycleAsyncId(this.scheduler, this.id, null));
  }, t.prototype._execute = function(n, r) {
    var a = !1, s;
    try {
      this.work(n);
    } catch (i) {
      a = !0, s = i || new Error("Scheduled action threw falsy error");
    }
    if (a)
      return this.unsubscribe(), s;
  }, t.prototype.unsubscribe = function() {
    if (!this.closed) {
      var n = this, r = n.id, a = n.scheduler, s = a.actions;
      this.work = this.state = this.scheduler = null, this.pending = !1, kr(s, this), r != null && (this.id = this.recycleAsyncId(a, r, null)), this.delay = null, e.prototype.unsubscribe.call(this);
    }
  }, t;
}(jf), zi = function() {
  function e(t, n) {
    n === void 0 && (n = e.now), this.schedulerActionCtor = t, this.now = n;
  }
  return e.prototype.schedule = function(t, n, r) {
    return n === void 0 && (n = 0), new this.schedulerActionCtor(this, t).schedule(r, n);
  }, e.now = Df.now, e;
}(), $f = function(e) {
  Nt(t, e);
  function t(n, r) {
    r === void 0 && (r = zi.now);
    var a = e.call(this, n, r) || this;
    return a.actions = [], a._active = !1, a;
  }
  return t.prototype.flush = function(n) {
    var r = this.actions;
    if (this._active) {
      r.push(n);
      return;
    }
    var a;
    this._active = !0;
    do
      if (a = n.execute(n.state, n.delay))
        break;
    while (n = r.shift());
    if (this._active = !1, a) {
      for (; n = r.shift(); )
        n.unsubscribe();
      throw a;
    }
  }, t;
}(zi), Lf = new $f(qf), Mf = Lf, Yo = new Oe(function(e) {
  return e.complete();
});
function Xo(e) {
  return e && de(e.schedule);
}
function Qo(e) {
  return e[e.length - 1];
}
function eu(e) {
  return Xo(Qo(e)) ? e.pop() : void 0;
}
function Zf(e, t) {
  return typeof Qo(e) == "number" ? e.pop() : t;
}
var tu = function(e) {
  return e && typeof e.length == "number" && typeof e != "function";
};
function nu(e) {
  return de(e == null ? void 0 : e.then);
}
function ru(e) {
  return de(e[Ns]);
}
function au(e) {
  return Symbol.asyncIterator && de(e == null ? void 0 : e[Symbol.asyncIterator]);
}
function su(e) {
  return new TypeError("You provided " + (e !== null && typeof e == "object" ? "an invalid object" : "'" + e + "'") + " where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.");
}
function Ff() {
  return typeof Symbol != "function" || !Symbol.iterator ? "@@iterator" : Symbol.iterator;
}
var iu = Ff();
function ou(e) {
  return de(e == null ? void 0 : e[iu]);
}
function uu(e) {
  return wf(this, arguments, function() {
    var t, n, r, a;
    return Bo(this, function(s) {
      switch (s.label) {
        case 0:
          t = e.getReader(), s.label = 1;
        case 1:
          s.trys.push([1, , 9, 10]), s.label = 2;
        case 2:
          return [4, mn(t.read())];
        case 3:
          return n = s.sent(), r = n.value, a = n.done, a ? [4, mn(void 0)] : [3, 5];
        case 4:
          return [2, s.sent()];
        case 5:
          return [4, mn(r)];
        case 6:
          return [4, s.sent()];
        case 7:
          return s.sent(), [3, 2];
        case 8:
          return [3, 10];
        case 9:
          return t.releaseLock(), [7];
        case 10:
          return [2];
      }
    });
  });
}
function cu(e) {
  return de(e == null ? void 0 : e.getReader);
}
function We(e) {
  if (e instanceof Oe)
    return e;
  if (e != null) {
    if (ru(e))
      return zf(e);
    if (tu(e))
      return Uf(e);
    if (nu(e))
      return Vf(e);
    if (au(e))
      return lu(e);
    if (ou(e))
      return Wf(e);
    if (cu(e))
      return Bf(e);
  }
  throw su(e);
}
function zf(e) {
  return new Oe(function(t) {
    var n = e[Ns]();
    if (de(n.subscribe))
      return n.subscribe(t);
    throw new TypeError("Provided object does not correctly implement Symbol.observable");
  });
}
function Uf(e) {
  return new Oe(function(t) {
    for (var n = 0; n < e.length && !t.closed; n++)
      t.next(e[n]);
    t.complete();
  });
}
function Vf(e) {
  return new Oe(function(t) {
    e.then(function(n) {
      t.closed || (t.next(n), t.complete());
    }, function(n) {
      return t.error(n);
    }).then(null, Jo);
  });
}
function Wf(e) {
  return new Oe(function(t) {
    var n, r;
    try {
      for (var a = bn(e), s = a.next(); !s.done; s = a.next()) {
        var i = s.value;
        if (t.next(i), t.closed)
          return;
      }
    } catch (o) {
      n = { error: o };
    } finally {
      try {
        s && !s.done && (r = a.return) && r.call(a);
      } finally {
        if (n)
          throw n.error;
      }
    }
    t.complete();
  });
}
function lu(e) {
  return new Oe(function(t) {
    Kf(e, t).catch(function(n) {
      return t.error(n);
    });
  });
}
function Bf(e) {
  return lu(uu(e));
}
function Kf(e, t) {
  var n, r, a, s;
  return bf(this, void 0, void 0, function() {
    var i, o;
    return Bo(this, function(c) {
      switch (c.label) {
        case 0:
          c.trys.push([0, 5, 6, 11]), n = xf(e), c.label = 1;
        case 1:
          return [4, n.next()];
        case 2:
          if (r = c.sent(), !!r.done)
            return [3, 4];
          if (i = r.value, t.next(i), t.closed)
            return [2];
          c.label = 3;
        case 3:
          return [3, 1];
        case 4:
          return [3, 11];
        case 5:
          return o = c.sent(), a = { error: o }, [3, 11];
        case 6:
          return c.trys.push([6, , 9, 10]), r && !r.done && (s = n.return) ? [4, s.call(n)] : [3, 8];
        case 7:
          c.sent(), c.label = 8;
        case 8:
          return [3, 10];
        case 9:
          if (a)
            throw a.error;
          return [7];
        case 10:
          return [7];
        case 11:
          return t.complete(), [2];
      }
    });
  });
}
function Et(e, t, n, r, a) {
  r === void 0 && (r = 0), a === void 0 && (a = !1);
  var s = t.schedule(function() {
    n(), a ? e.add(this.schedule(null, r)) : this.unsubscribe();
  }, r);
  if (e.add(s), !a)
    return s;
}
function du(e, t) {
  return t === void 0 && (t = 0), Ve(function(n, r) {
    n.subscribe(Re(r, function(a) {
      return Et(r, e, function() {
        return r.next(a);
      }, t);
    }, function() {
      return Et(r, e, function() {
        return r.complete();
      }, t);
    }, function(a) {
      return Et(r, e, function() {
        return r.error(a);
      }, t);
    }));
  });
}
function fu(e, t) {
  return t === void 0 && (t = 0), Ve(function(n, r) {
    r.add(e.schedule(function() {
      return n.subscribe(r);
    }, t));
  });
}
function Gf(e, t) {
  return We(e).pipe(fu(t), du(t));
}
function Hf(e, t) {
  return We(e).pipe(fu(t), du(t));
}
function Jf(e, t) {
  return new Oe(function(n) {
    var r = 0;
    return t.schedule(function() {
      r === e.length ? n.complete() : (n.next(e[r++]), n.closed || this.schedule());
    });
  });
}
function Yf(e, t) {
  return new Oe(function(n) {
    var r;
    return Et(n, t, function() {
      r = e[iu](), Et(n, t, function() {
        var a, s, i;
        try {
          a = r.next(), s = a.value, i = a.done;
        } catch (o) {
          n.error(o);
          return;
        }
        i ? n.complete() : n.next(s);
      }, 0, !0);
    }), function() {
      return de(r == null ? void 0 : r.return) && r.return();
    };
  });
}
function hu(e, t) {
  if (!e)
    throw new Error("Iterable cannot be null");
  return new Oe(function(n) {
    Et(n, t, function() {
      var r = e[Symbol.asyncIterator]();
      Et(n, t, function() {
        r.next().then(function(a) {
          a.done ? n.complete() : n.next(a.value);
        });
      }, 0, !0);
    });
  });
}
function Xf(e, t) {
  return hu(uu(e), t);
}
function Qf(e, t) {
  if (e != null) {
    if (ru(e))
      return Gf(e, t);
    if (tu(e))
      return Jf(e, t);
    if (nu(e))
      return Hf(e, t);
    if (au(e))
      return hu(e, t);
    if (ou(e))
      return Yf(e, t);
    if (cu(e))
      return Xf(e, t);
  }
  throw su(e);
}
function pu(e, t) {
  return t ? Qf(e, t) : We(e);
}
function Ui() {
  for (var e = [], t = 0; t < arguments.length; t++)
    e[t] = arguments[t];
  var n = eu(e);
  return pu(e, n);
}
var Ds = Is(function(e) {
  return function() {
    e(this), this.name = "EmptyError", this.message = "no elements in sequence";
  };
});
function mu(e, t) {
  var n = typeof t == "object";
  return new Promise(function(r, a) {
    var s = new kn({
      next: function(i) {
        r(i), s.unsubscribe();
      },
      error: a,
      complete: function() {
        n ? r(t.defaultValue) : a(new Ds());
      }
    });
    e.subscribe(s);
  });
}
function eh(e) {
  return e instanceof Date && !isNaN(e);
}
function Ft(e, t) {
  return Ve(function(n, r) {
    var a = 0;
    n.subscribe(Re(r, function(s) {
      r.next(e.call(t, s, a++));
    }));
  });
}
function th(e, t, n, r, a, s, i, o) {
  var c = [], u = 0, d = 0, h = !1, p = function() {
    h && !c.length && !u && t.complete();
  }, v = function(g) {
    return u < r ? T(g) : c.push(g);
  }, T = function(g) {
    s && t.next(g), u++;
    var D = !1;
    We(n(g, d++)).subscribe(Re(t, function(j) {
      a == null || a(j), s ? v(j) : t.next(j);
    }, function() {
      D = !0;
    }, void 0, function() {
      if (D)
        try {
          u--;
          for (var j = function() {
            var I = c.shift();
            i ? Et(t, i, function() {
              return T(I);
            }) : T(I);
          }; c.length && u < r; )
            j();
          p();
        } catch (I) {
          t.error(I);
        }
    }));
  };
  return e.subscribe(Re(t, v, function() {
    h = !0, p();
  })), function() {
    o == null || o();
  };
}
function yu(e, t, n) {
  return n === void 0 && (n = 1 / 0), de(t) ? yu(function(r, a) {
    return Ft(function(s, i) {
      return t(r, s, a, i);
    })(We(e(r, a)));
  }, n) : (typeof t == "number" && (n = t), Ve(function(r, a) {
    return th(r, a, e, n);
  }));
}
function nh(e) {
  return e === void 0 && (e = 1 / 0), yu(Vr, e);
}
function Vi(e, t, n) {
  e === void 0 && (e = 0), n === void 0 && (n = Mf);
  var r = -1;
  return t != null && (Xo(t) ? n = t : r = t), new Oe(function(a) {
    var s = eh(e) ? +e - n.now() : e;
    s < 0 && (s = 0);
    var i = 0;
    return n.schedule(function() {
      a.closed || (a.next(i++), 0 <= r ? this.schedule(void 0, r) : a.complete());
    }, s);
  });
}
function jn() {
  for (var e = [], t = 0; t < arguments.length; t++)
    e[t] = arguments[t];
  var n = eu(e), r = Zf(e, 1 / 0), a = e;
  return a.length ? a.length === 1 ? We(a[0]) : nh(r)(pu(a, n)) : Yo;
}
var rh = Array.isArray;
function ah(e) {
  return e.length === 1 && rh(e[0]) ? e[0] : e;
}
function zt(e, t) {
  return Ve(function(n, r) {
    var a = 0;
    n.subscribe(Re(r, function(s) {
      return e.call(t, s, a++) && r.next(s);
    }));
  });
}
function sh() {
  for (var e = [], t = 0; t < arguments.length; t++)
    e[t] = arguments[t];
  return e = ah(e), e.length === 1 ? We(e[0]) : new Oe(ih(e));
}
function ih(e) {
  return function(t) {
    for (var n = [], r = function(s) {
      n.push(We(e[s]).subscribe(Re(t, function(i) {
        if (n) {
          for (var o = 0; o < n.length; o++)
            o !== s && n[o].unsubscribe();
          n = null;
        }
        t.next(i);
      })));
    }, a = 0; n && !t.closed && a < e.length; a++)
      r(a);
  };
}
function oh(e) {
  return Ve(function(t, n) {
    var r = !1;
    t.subscribe(Re(n, function(a) {
      r = !0, n.next(a);
    }, function() {
      r || n.next(e), n.complete();
    }));
  });
}
function uh(e) {
  return e <= 0 ? function() {
    return Yo;
  } : Ve(function(t, n) {
    var r = 0;
    t.subscribe(Re(n, function(a) {
      ++r <= e && (n.next(a), e <= r && n.complete());
    }));
  });
}
function ch(e) {
  return e === void 0 && (e = lh), Ve(function(t, n) {
    var r = !1;
    t.subscribe(Re(n, function(a) {
      r = !0, n.next(a);
    }, function() {
      return r ? n.complete() : n.error(e());
    }));
  });
}
function lh() {
  return new Ds();
}
function Wi(e, t) {
  var n = arguments.length >= 2;
  return function(r) {
    return r.pipe(e ? zt(function(a, s) {
      return e(a, s, r);
    }) : Vr, uh(1), n ? oh(t) : ch(function() {
      return new Ds();
    }));
  };
}
function dh(e) {
  e === void 0 && (e = {});
  var t = e.connector, n = t === void 0 ? function() {
    return new Jt();
  } : t, r = e.resetOnError, a = r === void 0 ? !0 : r, s = e.resetOnComplete, i = s === void 0 ? !0 : s, o = e.resetOnRefCountZero, c = o === void 0 ? !0 : o;
  return function(u) {
    var d, h, p, v = 0, T = !1, g = !1, D = function() {
      h == null || h.unsubscribe(), h = void 0;
    }, j = function() {
      D(), d = p = void 0, T = g = !1;
    }, I = function() {
      var b = d;
      j(), b == null || b.unsubscribe();
    };
    return Ve(function(b, R) {
      v++, !g && !T && D();
      var Q = p = p ?? n();
      R.add(function() {
        v--, v === 0 && !g && !T && (h = ya(I, c));
      }), Q.subscribe(R), !d && v > 0 && (d = new kn({
        next: function($) {
          return Q.next($);
        },
        error: function($) {
          g = !0, D(), h = ya(j, a, $), Q.error($);
        },
        complete: function() {
          T = !0, D(), h = ya(j, i), Q.complete();
        }
      }), We(b).subscribe(d));
    })(u);
  };
}
function ya(e, t) {
  for (var n = [], r = 2; r < arguments.length; r++)
    n[r - 2] = arguments[r];
  if (t === !0) {
    e();
    return;
  }
  if (t !== !1) {
    var a = new kn({
      next: function() {
        a.unsubscribe(), e();
      }
    });
    return We(t.apply(void 0, xn([], wn(n)))).subscribe(a);
  }
}
function fh(e, t) {
  return Ve(function(n, r) {
    var a = null, s = 0, i = !1, o = function() {
      return i && !a && r.complete();
    };
    n.subscribe(Re(r, function(c) {
      a == null || a.unsubscribe();
      var u = 0, d = s++;
      We(e(c, d)).subscribe(a = Re(r, function(h) {
        return r.next(t ? t(c, h, d, u++) : h);
      }, function() {
        a = null, o();
      }));
    }, function() {
      i = !0, o();
    }));
  });
}
function hh(e) {
  return Ve(function(t, n) {
    We(e).subscribe(Re(n, function() {
      return n.complete();
    }, Ha)), !n.closed && t.subscribe(n);
  });
}
function un(e, t, n) {
  var r = de(e) || t || n ? { next: e, error: t, complete: n } : e;
  return r ? Ve(function(a, s) {
    var i;
    (i = r.subscribe) === null || i === void 0 || i.call(r);
    var o = !0;
    a.subscribe(Re(s, function(c) {
      var u;
      (u = r.next) === null || u === void 0 || u.call(r, c), s.next(c);
    }, function() {
      var c;
      o = !1, (c = r.complete) === null || c === void 0 || c.call(r), s.complete();
    }, function(c) {
      var u;
      o = !1, (u = r.error) === null || u === void 0 || u.call(r, c), s.error(c);
    }, function() {
      var c, u;
      o && ((c = r.unsubscribe) === null || c === void 0 || c.call(r)), (u = r.finalize) === null || u === void 0 || u.call(r);
    }));
  }) : Vr;
}
const ph = () => ({
  outgoingMessageSubject: new Jt(),
  incomingMessageSubject: new Jt(),
  responseSubject: new Jt(),
  messageLifeCycleEventSubject: new Jt()
}), mh = (e) => ct.fromPromise(mu(e), vf).andThen(
  (t) => t
), Bi = {
  extensionDetectionTime: 100
}, yh = (e) => {
  const t = e == null ? void 0 : e.logger, n = (e == null ? void 0 : e.subjects) ?? ph(), r = new An();
  r.add(
    n.incomingMessageSubject.pipe(
      un((o) => {
        "eventType" in o ? (t == null || t.debug(" messageLifecycleEvent", o), n.messageLifeCycleEventSubject.next(o)) : (t == null || t.debug(" walletResponse", o), n.responseSubject.next(o));
      })
    ).subscribe()
  ), r.add(
    n.outgoingMessageSubject.pipe(
      un((o) => {
        t == null || t.debug(" walletRequest", o), window.dispatchEvent(
          new CustomEvent(ir.outgoingMessage, {
            detail: o
          })
        );
      })
    ).subscribe()
  );
  const a = (o) => {
    const c = o.detail;
    n.incomingMessageSubject.next(c);
  };
  addEventListener(ir.incomingMessage, a);
  const s = (o, c) => {
    const u = new Jt(), d = n.responseSubject.pipe(
      zt(
        (b) => b.interactionId === o.interactionId
      ),
      Ft(
        (b) => b.discriminator === "success" ? et(b) : Fe(b)
      )
    ), h = n.messageLifeCycleEventSubject.pipe(
      zt(
        ({ interactionId: b, eventType: R }) => o.interactionId === b && ["requestCancelSuccess", "requestCancelFail"].includes(R)
      ),
      Ft((b) => {
        const R = Xt("canceledByUser", b.interactionId);
        return t == null || t.debug(" walletRequestCanceled", R), b;
      })
    ), p = () => (n.outgoingMessageSubject.next({
      interactionId: o.interactionId,
      items: { discriminator: "cancelRequest" },
      metadata: o.metadata
    }), setTimeout(() => {
      u.next(
        Fe(Xt("canceledByUser", o.interactionId))
      );
    }), ct.fromSafePromise(
      mu(
        jn(
          d.pipe(Ft(() => "requestCancelFail")),
          h.pipe(Ft(({ eventType: b }) => b))
        )
      )
    ));
    c.requestControl && c.requestControl({
      cancelRequest: () => p().andThen(
        (b) => b === "requestCancelSuccess" ? et("requestCancelSuccess") : Fe("requestCancelFail")
      ),
      getRequest: () => o
    });
    const v = jn(
      d,
      u
    ).pipe(Wi()), T = n.messageLifeCycleEventSubject.pipe(
      zt(
        ({ interactionId: b }) => o.interactionId === b
      ),
      un((b) => {
        c.eventCallback && c.eventCallback(b.eventType);
      }),
      hh(d),
      dh()
    ), g = T.subscribe(), D = Vi(Bi.extensionDetectionTime).pipe(
      Ft(
        () => Fe(Xt("missingExtension", o.interactionId))
      )
    ), j = jn(
      D,
      T
    ).pipe(
      Wi(),
      zt((b) => !("eventType" in b))
    ), I = Ui(o).pipe(
      un((b) => {
        n.outgoingMessageSubject.next(b);
      }),
      zt((b) => !1)
    );
    return mh(
      jn(
        v,
        j,
        I
      ).pipe(
        un(() => {
          g.unsubscribe();
        })
      )
    );
  }, i = n.messageLifeCycleEventSubject.pipe(
    zt(
      (o) => o.eventType === "extensionStatus"
    )
  );
  return {
    send: s,
    destroy: () => {
      r.unsubscribe(), removeEventListener(ir.incomingMessage, a);
    },
    openPopup: () => {
      window.dispatchEvent(
        new CustomEvent(ir.outgoingMessage, {
          detail: { discriminator: "openPopup" }
        })
      );
    },
    extensionStatus$: Ui(!0).pipe(
      un(() => {
        n.outgoingMessageSubject.next({
          interactionId: crypto.randomUUID(),
          discriminator: "extensionStatus"
        });
      }),
      fh(
        () => sh(
          i,
          jn(
            i,
            Vi(Bi.extensionDetectionTime).pipe(
              Ft(
                () => ({
                  eventType: "extensionStatus",
                  isWalletLinked: !1,
                  isExtensionAvailable: !1
                })
              )
            )
          )
        )
      )
    )
  };
}, Ya = {
  reset: [0, 0],
  bold: [1, 22],
  dim: [2, 22],
  italic: [3, 23],
  underline: [4, 24],
  overline: [53, 55],
  inverse: [7, 27],
  hidden: [8, 28],
  strikethrough: [9, 29],
  black: [30, 39],
  red: [31, 39],
  green: [32, 39],
  yellow: [33, 39],
  blue: [34, 39],
  magenta: [35, 39],
  cyan: [36, 39],
  white: [37, 39],
  blackBright: [90, 39],
  redBright: [91, 39],
  greenBright: [92, 39],
  yellowBright: [93, 39],
  blueBright: [94, 39],
  magentaBright: [95, 39],
  cyanBright: [96, 39],
  whiteBright: [97, 39],
  bgBlack: [40, 49],
  bgRed: [41, 49],
  bgGreen: [42, 49],
  bgYellow: [43, 49],
  bgBlue: [44, 49],
  bgMagenta: [45, 49],
  bgCyan: [46, 49],
  bgWhite: [47, 49],
  bgBlackBright: [100, 49],
  bgRedBright: [101, 49],
  bgGreenBright: [102, 49],
  bgYellowBright: [103, 49],
  bgBlueBright: [104, 49],
  bgMagentaBright: [105, 49],
  bgCyanBright: [106, 49],
  bgWhiteBright: [107, 49]
};
function Xa(e, t, n, r = !1) {
  const a = String(t), s = (o, c) => `\x1B[${c[0]}m${o}\x1B[${c[1]}m`, i = (o, c) => c != null && typeof c == "string" ? s(o, Ya[c]) : c != null && Array.isArray(c) ? c.reduce((u, d) => i(u, d), o) : c != null && c[o.trim()] != null ? i(o, c[o.trim()]) : c != null && c["*"] != null ? i(o, c["*"]) : o;
  return a.replace(/{{(.+?)}}/g, (o, c) => {
    var u;
    const d = n[c] != null ? n[c] : r ? "" : o;
    return e.stylePrettyLogs ? i(d, (u = e == null ? void 0 : e.prettyLogStyles) == null ? void 0 : u[c]) + s("", Ya.reset) : d;
  });
}
function vu(e) {
  const t = /* @__PURE__ */ new Set();
  return JSON.stringify(e, (n, r) => {
    if (typeof r == "object" && r !== null) {
      if (t.has(r))
        return "[Circular]";
      t.add(r);
    }
    return r;
  });
}
function Te(e, t) {
  const n = {
    seen: [],
    stylize: gu
  };
  return t != null && xu(n, t), fn(n.showHidden) && (n.showHidden = !1), fn(n.depth) && (n.depth = 2), fn(n.colors) && (n.colors = !0), fn(n.customInspect) && (n.customInspect = !0), n.colors && (n.stylize = gh), Sr(n, e, n.depth);
}
Te.colors = Ya;
Te.styles = {
  special: "cyan",
  number: "yellow",
  boolean: "yellow",
  undefined: "grey",
  null: "bold",
  string: "green",
  date: "magenta",
  regexp: "red"
};
function vh(e) {
  return typeof e == "boolean";
}
function fn(e) {
  return e == null;
}
function gu(e) {
  return e;
}
function gh(e, t) {
  var n, r, a, s;
  const i = Te.styles[t];
  return i != null && ((r = (n = Te == null ? void 0 : Te.colors) == null ? void 0 : n[i]) == null ? void 0 : r[0]) != null && ((s = (a = Te == null ? void 0 : Te.colors) == null ? void 0 : a[i]) == null ? void 0 : s[1]) != null ? "\x1B[" + Te.colors[i][0] + "m" + e + "\x1B[" + Te.colors[i][1] + "m" : e;
}
function ur(e) {
  return typeof e == "function";
}
function _u(e) {
  return typeof e == "string";
}
function _h(e) {
  return typeof e == "number";
}
function bu(e) {
  return e === null;
}
function wu(e, t) {
  return Object.prototype.hasOwnProperty.call(e, t);
}
function va(e) {
  return Wr(e) && js(e) === "[object RegExp]";
}
function Wr(e) {
  return typeof e == "object" && e !== null;
}
function ga(e) {
  return Wr(e) && (js(e) === "[object Error]" || e instanceof Error);
}
function Ki(e) {
  return Wr(e) && js(e) === "[object Date]";
}
function js(e) {
  return Object.prototype.toString.call(e);
}
function bh(e) {
  const t = {};
  return e.forEach((n) => {
    t[n] = !0;
  }), t;
}
function wh(e, t, n, r, a) {
  const s = [];
  for (let i = 0, o = t.length; i < o; ++i)
    wu(t, String(i)) ? s.push(Qa(e, t, n, r, String(i), !0)) : s.push("");
  return a.forEach((i) => {
    i.match(/^\d+$/) || s.push(Qa(e, t, n, r, i, !0));
  }), s;
}
function _a(e) {
  return "[" + Error.prototype.toString.call(e) + "]";
}
function Sr(e, t, n = 0) {
  if (e.customInspect && t != null && ur(t) && (t == null ? void 0 : t.inspect) !== Te && !(t != null && t.constructor && (t == null ? void 0 : t.constructor.prototype) === t)) {
    if (typeof t.inspect != "function" && t.toString != null)
      return t.toString();
    let d = t == null ? void 0 : t.inspect(n, e);
    return _u(d) || (d = Sr(e, d, n)), d;
  }
  const r = Ut(e, t);
  if (r)
    return r;
  let a = Object.keys(t);
  const s = bh(a);
  try {
    e.showHidden && Object.getOwnPropertyNames && (a = Object.getOwnPropertyNames(t));
  } catch {
  }
  if (ga(t) && (a.indexOf("message") >= 0 || a.indexOf("description") >= 0))
    return _a(t);
  if (a.length === 0)
    if (ur(e.stylize)) {
      if (ur(t)) {
        const d = t.name ? ": " + t.name : "";
        return e.stylize("[Function" + d + "]", "special");
      }
      if (va(t))
        return e.stylize(RegExp.prototype.toString.call(t), "regexp");
      if (Ki(t))
        return e.stylize(Date.prototype.toString.call(t), "date");
      if (ga(t))
        return _a(t);
    } else
      return t;
  let i = "", o = !1, c = [`{
`, `
}`];
  if (Array.isArray(t) && (o = !0, c = [`[
`, `
]`]), ur(t) && (i = " [Function" + (t.name ? ": " + t.name : "") + "]"), va(t) && (i = " " + RegExp.prototype.toString.call(t)), Ki(t) && (i = " " + Date.prototype.toUTCString.call(t)), ga(t) && (i = " " + _a(t)), a.length === 0 && (!o || t.length == 0))
    return c[0] + i + c[1];
  if (n < 0)
    return va(t) ? e.stylize(RegExp.prototype.toString.call(t), "regexp") : e.stylize("[Object]", "special");
  e.seen.push(t);
  let u;
  return o ? u = wh(e, t, n, s, a) : u = a.map((d) => Qa(e, t, n, s, d, o)), e.seen.pop(), xh(u, i, c);
}
function Qa(e, t, n, r, a, s) {
  let i, o, c;
  c = { value: void 0 };
  try {
    c.value = t[a];
  } catch {
  }
  try {
    Object.getOwnPropertyDescriptor && (c = Object.getOwnPropertyDescriptor(t, a) || c);
  } catch {
  }
  if (c.get ? c.set ? o = e.stylize("[Getter/Setter]", "special") : o = e.stylize("[Getter]", "special") : c.set && (o = e.stylize("[Setter]", "special")), wu(r, a) || (i = "[" + a + "]"), o || (e.seen.indexOf(c.value) < 0 ? (bu(n) ? o = Sr(e, c.value, void 0) : o = Sr(e, c.value, n - 1), o.indexOf(`
`) > -1 && (s ? o = o.split(`
`).map((u) => "  " + u).join(`
`).substr(2) : o = `
` + o.split(`
`).map((u) => "   " + u).join(`
`))) : o = e.stylize("[Circular]", "special")), fn(i)) {
    if (s && a.match(/^\d+$/))
      return o;
    i = JSON.stringify("" + a), i.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (i = i.substr(1, i.length - 2), i = e.stylize(i, "name")) : (i = i.replace(/'/g, "\\'").replace(/\\"/g, "\\'").replace(/(^"|"$)/g, "'"), i = e.stylize(i, "string"));
  }
  return i + ": " + o;
}
function Ut(e, t) {
  if (fn(t))
    return e.stylize("undefined", "undefined");
  if (_u(t)) {
    const n = "'" + JSON.stringify(t).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, "\\'") + "'";
    return e.stylize(n, "string");
  }
  if (_h(t))
    return e.stylize("" + t, "number");
  if (vh(t))
    return e.stylize("" + t, "boolean");
  if (bu(t))
    return e.stylize("null", "null");
}
function xh(e, t, n) {
  return n[0] + (t === "" ? "" : t + `
`) + "  " + e.join(`,
  `) + " " + n[1];
}
function xu(e, t) {
  if (!t || !Wr(t))
    return e;
  const n = Object.keys(t);
  let r = n.length;
  for (; r--; )
    e[n[r]] = t[n[r]];
  return e;
}
function kh(e, ...t) {
  const n = {
    seen: [],
    stylize: gu
  };
  e != null && xu(n, e);
  const r = t[0];
  let a = 0, s = "", i = "";
  if (typeof r == "string") {
    if (t.length === 1)
      return r;
    let o, c = 0;
    for (let u = 0; u < r.length - 1; u++)
      if (r.charCodeAt(u) === 37) {
        const d = r.charCodeAt(++u);
        if (a + 1 !== t.length) {
          switch (d) {
            case 115: {
              const h = t[++a];
              typeof h == "number" || typeof h == "bigint" ? o = Ut(n, h) : typeof h != "object" || h === null ? o = String(h) : o = Te(h, {
                ...e,
                compact: 3,
                colors: !1,
                depth: 0
              });
              break;
            }
            case 106:
              o = vu(t[++a]);
              break;
            case 100: {
              const h = t[++a];
              typeof h == "bigint" ? o = Ut(n, h) : typeof h == "symbol" ? o = "NaN" : o = Ut(n, h);
              break;
            }
            case 79:
              o = Te(t[++a], e);
              break;
            case 111:
              o = Te(t[++a], {
                ...e,
                showHidden: !0,
                showProxy: !0,
                depth: 4
              });
              break;
            case 105: {
              const h = t[++a];
              typeof h == "bigint" ? o = Ut(n, h) : typeof h == "symbol" ? o = "NaN" : o = Ut(n, parseInt(o));
              break;
            }
            case 102: {
              const h = t[++a];
              typeof h == "symbol" ? o = "NaN" : o = Ut(n, parseInt(h));
              break;
            }
            case 99:
              a += 1, o = "";
              break;
            case 37:
              s += r.slice(c, u), c = u + 1;
              continue;
            default:
              continue;
          }
          c !== u - 1 && (s += r.slice(c, u - 1)), s += o, c = u + 1;
        } else
          d === 37 && (s += r.slice(c, u), c = u + 1);
      }
    c !== 0 && (a++, i = " ", c < r.length && (s += r.slice(c)));
  }
  for (; a < t.length; ) {
    const o = t[a];
    s += i, s += typeof o != "string" ? Te(o, e) : o, i = " ", a++;
  }
  return s;
}
var Gi;
const Sh = {
  runtime: [typeof window, typeof document].includes("undefined") ? "Generic" : "Browser",
  browser: (Gi = globalThis == null ? void 0 : globalThis.navigator) == null ? void 0 : Gi.userAgent
}, Th = /(?:(?:file|https?|global code|[^@]+)@)?(?:file:)?((?:\/[^:/]+){2,})(?::(\d+))?(?::(\d+))?/;
function Ph(e, t, n, r, a, s) {
  return Object.assign({}, Sh, {
    name: a,
    parentNames: s,
    date: /* @__PURE__ */ new Date(),
    logLevelId: e,
    logLevelName: t,
    path: r ? void 0 : Oh(n)
  });
}
function Oh(e, t = Error()) {
  var n, r, a;
  return Su((a = (r = (n = t == null ? void 0 : t.stack) == null ? void 0 : n.split(`
`)) == null ? void 0 : r.filter((s) => !s.includes("Error: "))) == null ? void 0 : a[e]);
}
function ku(e) {
  var t, n, r;
  return (r = (n = (t = e == null ? void 0 : e.stack) == null ? void 0 : t.split(`
`)) == null ? void 0 : n.filter((a) => !a.includes("Error: "))) == null ? void 0 : r.reduce((a, s) => (a.push(Su(s)), a), []);
}
function Su(e) {
  const t = globalThis.location.origin, n = {
    fullFilePath: void 0,
    fileName: void 0,
    fileNameWithLine: void 0,
    fileColumn: void 0,
    fileLine: void 0,
    filePath: void 0,
    filePathWithLine: void 0,
    method: void 0
  };
  if (e != null) {
    const r = e.match(Th);
    if (r) {
      n.filePath = r[1].replace(/\?.*$/, ""), n.fullFilePath = `${t}${n.filePath}`;
      const a = n.filePath.split("/");
      n.fileName = a[a.length - 1], n.fileLine = r[2], n.fileColumn = r[3], n.filePathWithLine = `${n.filePath}:${n.fileLine}`, n.fileNameWithLine = `${n.fileName}:${n.fileLine}`;
    }
  }
  return n;
}
function es(e) {
  return e instanceof Error;
}
function Eh(e, t) {
  return e.reduce((n, r) => (es(r) ? n.errors.push(Ch(r, t)) : n.args.push(r), n), { args: [], errors: [] });
}
function Ch(e, t) {
  const n = ku(e).map((a) => Xa(t, t.prettyErrorStackTemplate, { ...a }, !0)), r = {
    errorName: ` ${e.name} `,
    errorMessage: e.message,
    errorStack: n.join(`
`)
  };
  return Xa(t, t.prettyErrorTemplate, r);
}
function Ah(e, t, n, r) {
  const a = (n.length > 0 && t.length > 0 ? `
` : "") + n.join(`
`);
  r.prettyInspectOptions.colors = r.stylePrettyLogs, console.log(e + kh(r.prettyInspectOptions, ...t) + a);
}
function Ih(e) {
  console.log(vu(e));
}
function Me(e, t = 2, n = 0) {
  return e != null && isNaN(e) ? "" : (e = e != null ? e + n : e, t === 2 ? e == null ? "--" : e < 10 ? "0" + e : e.toString() : e == null ? "---" : e < 10 ? "00" + e : e < 100 ? "0" + e : e.toString());
}
class Rh {
  constructor(t, n, r = 4) {
    var a, s, i, o, c, u, d;
    this.logObj = n, this.stackDepthLevel = r;
    const h = ![typeof window, typeof document].includes("undefined"), p = Object.prototype.toString.call(typeof process < "u" ? process : 0) === "[object process]";
    this.runtime = h ? "browser" : p ? "nodejs" : "unknown";
    const v = h ? (((window == null ? void 0 : window.chrome) || window.Intl && (Intl == null ? void 0 : Intl.v8BreakIterator)) && "CSS" in window) != null : !1, T = h ? /^((?!chrome|android).)*safari/i.test(navigator == null ? void 0 : navigator.userAgent) : !1;
    this.stackDepthLevel = T ? 4 : this.stackDepthLevel, this.settings = {
      type: (t == null ? void 0 : t.type) ?? "pretty",
      name: t == null ? void 0 : t.name,
      parentNames: t == null ? void 0 : t.parentNames,
      minLevel: (t == null ? void 0 : t.minLevel) ?? 0,
      argumentsArrayName: t == null ? void 0 : t.argumentsArrayName,
      hideLogPositionForProduction: (t == null ? void 0 : t.hideLogPositionForProduction) ?? !1,
      prettyLogTemplate: (t == null ? void 0 : t.prettyLogTemplate) ?? "{{yyyy}}.{{mm}}.{{dd}} {{hh}}:{{MM}}:{{ss}}:{{ms}}	{{logLevelName}}	{{filePathWithLine}}{{nameWithDelimiterPrefix}}	",
      prettyErrorTemplate: (t == null ? void 0 : t.prettyErrorTemplate) ?? `
{{errorName}} {{errorMessage}}
error stack:
{{errorStack}}`,
      prettyErrorStackTemplate: (t == null ? void 0 : t.prettyErrorStackTemplate) ?? `   {{fileName}}	{{method}}
	{{filePathWithLine}}`,
      prettyErrorParentNamesSeparator: (t == null ? void 0 : t.prettyErrorParentNamesSeparator) ?? ":",
      prettyErrorLoggerNameDelimiter: (t == null ? void 0 : t.prettyErrorLoggerNameDelimiter) ?? "	",
      stylePrettyLogs: (t == null ? void 0 : t.stylePrettyLogs) ?? !0,
      prettyLogTimeZone: (t == null ? void 0 : t.prettyLogTimeZone) ?? "UTC",
      prettyLogStyles: (t == null ? void 0 : t.prettyLogStyles) ?? {
        logLevelName: {
          "*": ["bold", "black", "bgWhiteBright", "dim"],
          SILLY: ["bold", "white"],
          TRACE: ["bold", "whiteBright"],
          DEBUG: ["bold", "green"],
          INFO: ["bold", "blue"],
          WARN: ["bold", "yellow"],
          ERROR: ["bold", "red"],
          FATAL: ["bold", "redBright"]
        },
        dateIsoStr: "white",
        filePathWithLine: "white",
        name: ["white", "bold"],
        nameWithDelimiterPrefix: ["white", "bold"],
        nameWithDelimiterSuffix: ["white", "bold"],
        errorName: ["bold", "bgRedBright", "whiteBright"],
        fileName: ["yellow"],
        fileNameWithLine: "white"
      },
      prettyInspectOptions: (t == null ? void 0 : t.prettyInspectOptions) ?? {
        colors: !0,
        compact: !1,
        depth: 1 / 0
      },
      metaProperty: (t == null ? void 0 : t.metaProperty) ?? "_meta",
      maskPlaceholder: (t == null ? void 0 : t.maskPlaceholder) ?? "[***]",
      maskValuesOfKeys: (t == null ? void 0 : t.maskValuesOfKeys) ?? ["password"],
      maskValuesOfKeysCaseInsensitive: (t == null ? void 0 : t.maskValuesOfKeysCaseInsensitive) ?? !1,
      maskValuesRegEx: t == null ? void 0 : t.maskValuesRegEx,
      prefix: [...(t == null ? void 0 : t.prefix) ?? []],
      attachedTransports: [...(t == null ? void 0 : t.attachedTransports) ?? []],
      overwrite: {
        mask: (a = t == null ? void 0 : t.overwrite) == null ? void 0 : a.mask,
        toLogObj: (s = t == null ? void 0 : t.overwrite) == null ? void 0 : s.toLogObj,
        addMeta: (i = t == null ? void 0 : t.overwrite) == null ? void 0 : i.addMeta,
        formatMeta: (o = t == null ? void 0 : t.overwrite) == null ? void 0 : o.formatMeta,
        formatLogObj: (c = t == null ? void 0 : t.overwrite) == null ? void 0 : c.formatLogObj,
        transportFormatted: (u = t == null ? void 0 : t.overwrite) == null ? void 0 : u.transportFormatted,
        transportJSON: (d = t == null ? void 0 : t.overwrite) == null ? void 0 : d.transportJSON
      }
    }, this.settings.stylePrettyLogs = this.settings.stylePrettyLogs && h && !v ? !1 : this.settings.stylePrettyLogs;
  }
  log(t, n, ...r) {
    var a, s, i, o, c, u, d, h, p, v, T, g, D, j;
    if (t < this.settings.minLevel)
      return;
    const I = [...this.settings.prefix, ...r], b = ((a = this.settings.overwrite) == null ? void 0 : a.mask) != null ? (s = this.settings.overwrite) == null ? void 0 : s.mask(I) : this.settings.maskValuesOfKeys != null && this.settings.maskValuesOfKeys.length > 0 ? this._mask(I) : I, R = this.logObj != null ? this._recursiveCloneAndExecuteFunctions(this.logObj) : void 0, Q = ((i = this.settings.overwrite) == null ? void 0 : i.toLogObj) != null ? (o = this.settings.overwrite) == null ? void 0 : o.toLogObj(b, R) : this._toLogObj(b, R), $ = ((c = this.settings.overwrite) == null ? void 0 : c.addMeta) != null ? (u = this.settings.overwrite) == null ? void 0 : u.addMeta(Q, t, n) : this._addMetaToLogObj(Q, t, n);
    let A, te;
    return ((d = this.settings.overwrite) == null ? void 0 : d.formatMeta) != null && (A = (h = this.settings.overwrite) == null ? void 0 : h.formatMeta($ == null ? void 0 : $[this.settings.metaProperty])), ((p = this.settings.overwrite) == null ? void 0 : p.formatLogObj) != null && (te = (v = this.settings.overwrite) == null ? void 0 : v.formatLogObj(b, this.settings)), this.settings.type === "pretty" && (A = A ?? this._prettyFormatLogObjMeta($ == null ? void 0 : $[this.settings.metaProperty]), te = te ?? Eh(b, this.settings)), A != null && te != null ? ((T = this.settings.overwrite) == null ? void 0 : T.transportFormatted) != null ? (g = this.settings.overwrite) == null || g.transportFormatted(A, te.args, te.errors, this.settings) : Ah(A, te.args, te.errors, this.settings) : ((D = this.settings.overwrite) == null ? void 0 : D.transportJSON) != null ? (j = this.settings.overwrite) == null || j.transportJSON($) : this.settings.type !== "hidden" && Ih($), this.settings.attachedTransports != null && this.settings.attachedTransports.length > 0 && this.settings.attachedTransports.forEach((qe) => {
      qe($);
    }), $;
  }
  attachTransport(t) {
    this.settings.attachedTransports.push(t);
  }
  getSubLogger(t, n) {
    var r, a, s;
    const i = {
      ...this.settings,
      ...t,
      parentNames: ((r = this.settings) == null ? void 0 : r.parentNames) != null && ((a = this.settings) == null ? void 0 : a.name) != null ? [...this.settings.parentNames, this.settings.name] : ((s = this.settings) == null ? void 0 : s.name) != null ? [this.settings.name] : void 0,
      prefix: [...this.settings.prefix, ...(t == null ? void 0 : t.prefix) ?? []]
    };
    return new this.constructor(i, n ?? this.logObj, this.stackDepthLevel);
  }
  _mask(t) {
    const n = this.settings.maskValuesOfKeysCaseInsensitive !== !0 ? this.settings.maskValuesOfKeys : this.settings.maskValuesOfKeys.map((r) => r.toLowerCase());
    return t == null ? void 0 : t.map((r) => this._recursiveCloneAndMaskValuesOfKeys(r, n));
  }
  _recursiveCloneAndMaskValuesOfKeys(t, n, r = []) {
    return r.includes(t) ? { ...t } : (typeof t == "object" && t != null && r.push(t), t instanceof Map ? new Map(t) : t instanceof Set ? new Set(t) : Array.isArray(t) ? t.map((a) => this._recursiveCloneAndMaskValuesOfKeys(a, n, r)) : t instanceof Date ? new Date(t.getTime()) : es(t) ? Object.getOwnPropertyNames(t).reduce((a, s) => {
      var i;
      return a[s] = n.includes(((i = this.settings) == null ? void 0 : i.maskValuesOfKeysCaseInsensitive) !== !0 ? s : s.toLowerCase()) ? this.settings.maskPlaceholder : this._recursiveCloneAndMaskValuesOfKeys(t[s], n, r), a;
    }, this._cloneError(t)) : t != null && typeof t == "object" ? Object.getOwnPropertyNames(t).reduce((a, s) => {
      var i;
      return a[s] = n.includes(((i = this.settings) == null ? void 0 : i.maskValuesOfKeysCaseInsensitive) !== !0 ? s : s.toLowerCase()) ? this.settings.maskPlaceholder : this._recursiveCloneAndMaskValuesOfKeys(t[s], n, r), a;
    }, Object.create(Object.getPrototypeOf(t))) : ((a) => {
      var s, i;
      return (i = (s = this.settings) == null ? void 0 : s.maskValuesRegEx) == null || i.forEach((o) => {
        var c;
        a = (c = a == null ? void 0 : a.toString()) == null ? void 0 : c.replace(o, this.settings.maskPlaceholder);
      }), a;
    })(t));
  }
  _recursiveCloneAndExecuteFunctions(t, n = []) {
    return n.includes(t) ? { ...t } : (typeof t == "object" && n.push(t), Array.isArray(t) ? t.map((r) => this._recursiveCloneAndExecuteFunctions(r, n)) : t instanceof Date ? new Date(t.getTime()) : t && typeof t == "object" ? Object.getOwnPropertyNames(t).reduce((r, a) => (Object.defineProperty(r, a, Object.getOwnPropertyDescriptor(t, a)), r[a] = typeof t[a] == "function" ? t[a]() : this._recursiveCloneAndExecuteFunctions(t[a], n), r), Object.create(Object.getPrototypeOf(t))) : t);
  }
  _toLogObj(t, n = {}) {
    return t = t == null ? void 0 : t.map((r) => es(r) ? this._toErrorObject(r) : r), this.settings.argumentsArrayName == null ? t.length === 1 && !Array.isArray(t[0]) && (t[0], void 0 !== !0) && !(t[0] instanceof Date) ? n = typeof t[0] == "object" && t[0] != null ? { ...t[0], ...n } : { 0: t[0], ...n } : n = { ...n, ...t } : n = {
      ...n,
      [this.settings.argumentsArrayName]: t
    }, n;
  }
  _cloneError(t) {
    const n = t.constructor, r = new n(t.message);
    Object.assign(r, t);
    const a = Object.getOwnPropertyNames(r);
    for (const s of a) {
      const i = Object.getOwnPropertyDescriptor(r, s);
      i && (i.writable = !0, Object.defineProperty(r, s, i));
    }
    return r;
  }
  _toErrorObject(t) {
    return {
      nativeError: t,
      name: t.name ?? "Error",
      message: t.message,
      stack: ku(t)
    };
  }
  _addMetaToLogObj(t, n, r) {
    return {
      ...t,
      [this.settings.metaProperty]: Ph(n, r, this.stackDepthLevel, this.settings.hideLogPositionForProduction, this.settings.name, this.settings.parentNames)
    };
  }
  _prettyFormatLogObjMeta(t) {
    var n, r, a, s, i, o, c, u, d, h, p, v, T, g, D, j, I, b, R, Q;
    if (t == null)
      return "";
    let $ = this.settings.prettyLogTemplate;
    const A = {};
    $.includes("{{yyyy}}.{{mm}}.{{dd}} {{hh}}:{{MM}}:{{ss}}:{{ms}}") ? $ = $.replace("{{yyyy}}.{{mm}}.{{dd}} {{hh}}:{{MM}}:{{ss}}:{{ms}}", "{{dateIsoStr}}") : this.settings.prettyLogTimeZone === "UTC" ? (A.yyyy = ((n = t == null ? void 0 : t.date) == null ? void 0 : n.getUTCFullYear()) ?? "----", A.mm = Me((r = t == null ? void 0 : t.date) == null ? void 0 : r.getUTCMonth(), 2, 1), A.dd = Me((a = t == null ? void 0 : t.date) == null ? void 0 : a.getUTCDate(), 2), A.hh = Me((s = t == null ? void 0 : t.date) == null ? void 0 : s.getUTCHours(), 2), A.MM = Me((i = t == null ? void 0 : t.date) == null ? void 0 : i.getUTCMinutes(), 2), A.ss = Me((o = t == null ? void 0 : t.date) == null ? void 0 : o.getUTCSeconds(), 2), A.ms = Me((c = t == null ? void 0 : t.date) == null ? void 0 : c.getUTCMilliseconds(), 3)) : (A.yyyy = ((u = t == null ? void 0 : t.date) == null ? void 0 : u.getFullYear()) ?? "----", A.mm = Me((d = t == null ? void 0 : t.date) == null ? void 0 : d.getMonth(), 2, 1), A.dd = Me((h = t == null ? void 0 : t.date) == null ? void 0 : h.getDate(), 2), A.hh = Me((p = t == null ? void 0 : t.date) == null ? void 0 : p.getHours(), 2), A.MM = Me((v = t == null ? void 0 : t.date) == null ? void 0 : v.getMinutes(), 2), A.ss = Me((T = t == null ? void 0 : t.date) == null ? void 0 : T.getSeconds(), 2), A.ms = Me((g = t == null ? void 0 : t.date) == null ? void 0 : g.getMilliseconds(), 3));
    const te = this.settings.prettyLogTimeZone === "UTC" ? t == null ? void 0 : t.date : new Date(((D = t == null ? void 0 : t.date) == null ? void 0 : D.getTime()) - ((j = t == null ? void 0 : t.date) == null ? void 0 : j.getTimezoneOffset()) * 6e4);
    A.rawIsoStr = te == null ? void 0 : te.toISOString(), A.dateIsoStr = te == null ? void 0 : te.toISOString().replace("T", " ").replace("Z", ""), A.logLevelName = t == null ? void 0 : t.logLevelName, A.fileNameWithLine = ((I = t == null ? void 0 : t.path) == null ? void 0 : I.fileNameWithLine) ?? "", A.filePathWithLine = ((b = t == null ? void 0 : t.path) == null ? void 0 : b.filePathWithLine) ?? "", A.fullFilePath = ((R = t == null ? void 0 : t.path) == null ? void 0 : R.fullFilePath) ?? "";
    let qe = (Q = this.settings.parentNames) == null ? void 0 : Q.join(this.settings.prettyErrorParentNamesSeparator);
    return qe = qe != null && (t == null ? void 0 : t.name) != null ? qe + this.settings.prettyErrorParentNamesSeparator : void 0, A.name = (t == null ? void 0 : t.name) != null || qe != null ? (qe ?? "") + (t == null ? void 0 : t.name) : "", A.nameWithDelimiterPrefix = A.name.length > 0 ? this.settings.prettyErrorLoggerNameDelimiter + A.name : "", A.nameWithDelimiterSuffix = A.name.length > 0 ? A.name + this.settings.prettyErrorLoggerNameDelimiter : "", Xa(this.settings, $, A);
  }
}
class Nh extends Rh {
  constructor(t, n) {
    super(t, n, 5);
  }
  log(t, n, ...r) {
    return super.log(t, n, ...r);
  }
  silly(...t) {
    return super.log(0, "SILLY", ...t);
  }
  trace(...t) {
    return super.log(1, "TRACE", ...t);
  }
  debug(...t) {
    return super.log(2, "DEBUG", ...t);
  }
  info(...t) {
    return super.log(3, "INFO", ...t);
  }
  warn(...t) {
    return super.log(4, "WARN", ...t);
  }
  error(...t) {
    return super.log(5, "ERROR", ...t);
  }
  fatal(...t) {
    return super.log(6, "FATAL", ...t);
  }
  getSubLogger(t, n) {
    return super.getSubLogger(t, n);
  }
}
const Gg = (e) => new Nh({
  minLevel: e,
  prettyLogTemplate: "{{hh}}:{{MM}}:{{ss}}:{{ms}}	{{logLevelName}}	"
}), Dh = (e) => {
  var t, n;
  const r = {
    version: 2,
    dAppDefinitionAddress: e.dAppDefinitionAddress,
    networkId: e.networkId
  };
  Uo.parse(r), (t = e.logger) == null || t.debug(" walletSdkInstantiated", r);
  const a = e.logger, s = ((n = e.providers) == null ? void 0 : n.connectorExtensionClient) ?? yh({ logger: a });
  return {
    ..._f(
      {
        version: 2,
        logger: e.logger,
        dAppDefinitionAddress: e.dAppDefinitionAddress,
        networkId: e.networkId
      },
      s
    ),
    destroy: () => {
      a == null || a.debug(" walletSdkInstantiatedDestroyed"), s.destroy();
    }
  };
};
var J;
(function(e) {
  e.assertEqual = (a) => a;
  function t(a) {
  }
  e.assertIs = t;
  function n(a) {
    throw new Error();
  }
  e.assertNever = n, e.arrayToEnum = (a) => {
    const s = {};
    for (const i of a)
      s[i] = i;
    return s;
  }, e.getValidEnumValues = (a) => {
    const s = e.objectKeys(a).filter((o) => typeof a[a[o]] != "number"), i = {};
    for (const o of s)
      i[o] = a[o];
    return e.objectValues(i);
  }, e.objectValues = (a) => e.objectKeys(a).map(function(s) {
    return a[s];
  }), e.objectKeys = typeof Object.keys == "function" ? (a) => Object.keys(a) : (a) => {
    const s = [];
    for (const i in a)
      Object.prototype.hasOwnProperty.call(a, i) && s.push(i);
    return s;
  }, e.find = (a, s) => {
    for (const i of a)
      if (s(i))
        return i;
  }, e.isInteger = typeof Number.isInteger == "function" ? (a) => Number.isInteger(a) : (a) => typeof a == "number" && isFinite(a) && Math.floor(a) === a;
  function r(a, s = " | ") {
    return a.map((i) => typeof i == "string" ? `'${i}'` : i).join(s);
  }
  e.joinValues = r, e.jsonStringifyReplacer = (a, s) => typeof s == "bigint" ? s.toString() : s;
})(J || (J = {}));
var Hi;
(function(e) {
  e.mergeShapes = (t, n) => ({
    ...t,
    ...n
    // second overwrites first
  });
})(Hi || (Hi = {}));
const x = J.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]), Kt = (e) => {
  switch (typeof e) {
    case "undefined":
      return x.undefined;
    case "string":
      return x.string;
    case "number":
      return isNaN(e) ? x.nan : x.number;
    case "boolean":
      return x.boolean;
    case "function":
      return x.function;
    case "bigint":
      return x.bigint;
    case "symbol":
      return x.symbol;
    case "object":
      return Array.isArray(e) ? x.array : e === null ? x.null : e.then && typeof e.then == "function" && e.catch && typeof e.catch == "function" ? x.promise : typeof Map < "u" && e instanceof Map ? x.map : typeof Set < "u" && e instanceof Set ? x.set : typeof Date < "u" && e instanceof Date ? x.date : x.object;
    default:
      return x.unknown;
  }
}, _ = J.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]);
class rt extends Error {
  constructor(t) {
    super(), this.issues = [], this.addIssue = (r) => {
      this.issues = [...this.issues, r];
    }, this.addIssues = (r = []) => {
      this.issues = [...this.issues, ...r];
    };
    const n = new.target.prototype;
    Object.setPrototypeOf ? Object.setPrototypeOf(this, n) : this.__proto__ = n, this.name = "ZodError", this.issues = t;
  }
  get errors() {
    return this.issues;
  }
  format(t) {
    const n = t || function(s) {
      return s.message;
    }, r = { _errors: [] }, a = (s) => {
      for (const i of s.issues)
        if (i.code === "invalid_union")
          i.unionErrors.map(a);
        else if (i.code === "invalid_return_type")
          a(i.returnTypeError);
        else if (i.code === "invalid_arguments")
          a(i.argumentsError);
        else if (i.path.length === 0)
          r._errors.push(n(i));
        else {
          let o = r, c = 0;
          for (; c < i.path.length; ) {
            const u = i.path[c];
            c === i.path.length - 1 ? (o[u] = o[u] || { _errors: [] }, o[u]._errors.push(n(i))) : o[u] = o[u] || { _errors: [] }, o = o[u], c++;
          }
        }
    };
    return a(this), r;
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, J.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(t = (n) => n.message) {
    const n = {}, r = [];
    for (const a of this.issues)
      a.path.length > 0 ? (n[a.path[0]] = n[a.path[0]] || [], n[a.path[0]].push(t(a))) : r.push(t(a));
    return { formErrors: r, fieldErrors: n };
  }
  get formErrors() {
    return this.flatten();
  }
}
rt.create = (e) => new rt(e);
const Tr = (e, t) => {
  let n;
  switch (e.code) {
    case _.invalid_type:
      e.received === x.undefined ? n = "Required" : n = `Expected ${e.expected}, received ${e.received}`;
      break;
    case _.invalid_literal:
      n = `Invalid literal value, expected ${JSON.stringify(e.expected, J.jsonStringifyReplacer)}`;
      break;
    case _.unrecognized_keys:
      n = `Unrecognized key(s) in object: ${J.joinValues(e.keys, ", ")}`;
      break;
    case _.invalid_union:
      n = "Invalid input";
      break;
    case _.invalid_union_discriminator:
      n = `Invalid discriminator value. Expected ${J.joinValues(e.options)}`;
      break;
    case _.invalid_enum_value:
      n = `Invalid enum value. Expected ${J.joinValues(e.options)}, received '${e.received}'`;
      break;
    case _.invalid_arguments:
      n = "Invalid function arguments";
      break;
    case _.invalid_return_type:
      n = "Invalid function return type";
      break;
    case _.invalid_date:
      n = "Invalid date";
      break;
    case _.invalid_string:
      typeof e.validation == "object" ? "includes" in e.validation ? (n = `Invalid input: must include "${e.validation.includes}"`, typeof e.validation.position == "number" && (n = `${n} at one or more positions greater than or equal to ${e.validation.position}`)) : "startsWith" in e.validation ? n = `Invalid input: must start with "${e.validation.startsWith}"` : "endsWith" in e.validation ? n = `Invalid input: must end with "${e.validation.endsWith}"` : J.assertNever(e.validation) : e.validation !== "regex" ? n = `Invalid ${e.validation}` : n = "Invalid";
      break;
    case _.too_small:
      e.type === "array" ? n = `Array must contain ${e.exact ? "exactly" : e.inclusive ? "at least" : "more than"} ${e.minimum} element(s)` : e.type === "string" ? n = `String must contain ${e.exact ? "exactly" : e.inclusive ? "at least" : "over"} ${e.minimum} character(s)` : e.type === "number" ? n = `Number must be ${e.exact ? "exactly equal to " : e.inclusive ? "greater than or equal to " : "greater than "}${e.minimum}` : e.type === "date" ? n = `Date must be ${e.exact ? "exactly equal to " : e.inclusive ? "greater than or equal to " : "greater than "}${new Date(Number(e.minimum))}` : n = "Invalid input";
      break;
    case _.too_big:
      e.type === "array" ? n = `Array must contain ${e.exact ? "exactly" : e.inclusive ? "at most" : "less than"} ${e.maximum} element(s)` : e.type === "string" ? n = `String must contain ${e.exact ? "exactly" : e.inclusive ? "at most" : "under"} ${e.maximum} character(s)` : e.type === "number" ? n = `Number must be ${e.exact ? "exactly" : e.inclusive ? "less than or equal to" : "less than"} ${e.maximum}` : e.type === "bigint" ? n = `BigInt must be ${e.exact ? "exactly" : e.inclusive ? "less than or equal to" : "less than"} ${e.maximum}` : e.type === "date" ? n = `Date must be ${e.exact ? "exactly" : e.inclusive ? "smaller than or equal to" : "smaller than"} ${new Date(Number(e.maximum))}` : n = "Invalid input";
      break;
    case _.custom:
      n = "Invalid input";
      break;
    case _.invalid_intersection_types:
      n = "Intersection results could not be merged";
      break;
    case _.not_multiple_of:
      n = `Number must be a multiple of ${e.multipleOf}`;
      break;
    case _.not_finite:
      n = "Number must be finite";
      break;
    default:
      n = t.defaultError, J.assertNever(e);
  }
  return { message: n };
};
let jh = Tr;
function ts() {
  return jh;
}
const ns = (e) => {
  const { data: t, path: n, errorMaps: r, issueData: a } = e, s = [...n, ...a.path || []], i = {
    ...a,
    path: s
  };
  let o = "";
  const c = r.filter((u) => !!u).slice().reverse();
  for (const u of c)
    o = u(i, { data: t, defaultError: o }).message;
  return {
    ...a,
    path: s,
    message: a.message || o
  };
};
function S(e, t) {
  const n = ns({
    issueData: t,
    data: e.data,
    path: e.path,
    errorMaps: [
      e.common.contextualErrorMap,
      e.schemaErrorMap,
      ts(),
      Tr
      // then global default map
    ].filter((r) => !!r)
  });
  e.common.issues.push(n);
}
class ke {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    this.value === "valid" && (this.value = "dirty");
  }
  abort() {
    this.value !== "aborted" && (this.value = "aborted");
  }
  static mergeArray(t, n) {
    const r = [];
    for (const a of n) {
      if (a.status === "aborted")
        return M;
      a.status === "dirty" && t.dirty(), r.push(a.value);
    }
    return { status: t.value, value: r };
  }
  static async mergeObjectAsync(t, n) {
    const r = [];
    for (const a of n)
      r.push({
        key: await a.key,
        value: await a.value
      });
    return ke.mergeObjectSync(t, r);
  }
  static mergeObjectSync(t, n) {
    const r = {};
    for (const a of n) {
      const { key: s, value: i } = a;
      if (s.status === "aborted" || i.status === "aborted")
        return M;
      s.status === "dirty" && t.dirty(), i.status === "dirty" && t.dirty(), (typeof i.value < "u" || a.alwaysSet) && (r[s.value] = i.value);
    }
    return { status: t.value, value: r };
  }
}
const M = Object.freeze({
  status: "aborted"
}), qh = (e) => ({ status: "dirty", value: e }), Ee = (e) => ({ status: "valid", value: e }), Ji = (e) => e.status === "aborted", Yi = (e) => e.status === "dirty", rs = (e) => e.status === "valid", as = (e) => typeof Promise < "u" && e instanceof Promise;
var C;
(function(e) {
  e.errToObj = (t) => typeof t == "string" ? { message: t } : t || {}, e.toString = (t) => typeof t == "string" ? t : t == null ? void 0 : t.message;
})(C || (C = {}));
class it {
  constructor(t, n, r, a) {
    this._cachedPath = [], this.parent = t, this.data = n, this._path = r, this._key = a;
  }
  get path() {
    return this._cachedPath.length || (this._key instanceof Array ? this._cachedPath.push(...this._path, ...this._key) : this._cachedPath.push(...this._path, this._key)), this._cachedPath;
  }
}
const Xi = (e, t) => {
  if (rs(t))
    return { success: !0, data: t.value };
  if (!e.common.issues.length)
    throw new Error("Validation failed but no issues detected.");
  return {
    success: !1,
    get error() {
      if (this._error)
        return this._error;
      const n = new rt(e.common.issues);
      return this._error = n, this._error;
    }
  };
};
function F(e) {
  if (!e)
    return {};
  const { errorMap: t, invalid_type_error: n, required_error: r, description: a } = e;
  if (t && (n || r))
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  return t ? { errorMap: t, description: a } : { errorMap: (i, o) => i.code !== "invalid_type" ? { message: o.defaultError } : typeof o.data > "u" ? { message: r ?? o.defaultError } : { message: n ?? o.defaultError }, description: a };
}
class V {
  constructor(t) {
    this.spa = this.safeParseAsync, this._def = t, this.parse = this.parse.bind(this), this.safeParse = this.safeParse.bind(this), this.parseAsync = this.parseAsync.bind(this), this.safeParseAsync = this.safeParseAsync.bind(this), this.spa = this.spa.bind(this), this.refine = this.refine.bind(this), this.refinement = this.refinement.bind(this), this.superRefine = this.superRefine.bind(this), this.optional = this.optional.bind(this), this.nullable = this.nullable.bind(this), this.nullish = this.nullish.bind(this), this.array = this.array.bind(this), this.promise = this.promise.bind(this), this.or = this.or.bind(this), this.and = this.and.bind(this), this.transform = this.transform.bind(this), this.brand = this.brand.bind(this), this.default = this.default.bind(this), this.catch = this.catch.bind(this), this.describe = this.describe.bind(this), this.pipe = this.pipe.bind(this), this.isNullable = this.isNullable.bind(this), this.isOptional = this.isOptional.bind(this);
  }
  get description() {
    return this._def.description;
  }
  _getType(t) {
    return Kt(t.data);
  }
  _getOrReturnCtx(t, n) {
    return n || {
      common: t.parent.common,
      data: t.data,
      parsedType: Kt(t.data),
      schemaErrorMap: this._def.errorMap,
      path: t.path,
      parent: t.parent
    };
  }
  _processInputParams(t) {
    return {
      status: new ke(),
      ctx: {
        common: t.parent.common,
        data: t.data,
        parsedType: Kt(t.data),
        schemaErrorMap: this._def.errorMap,
        path: t.path,
        parent: t.parent
      }
    };
  }
  _parseSync(t) {
    const n = this._parse(t);
    if (as(n))
      throw new Error("Synchronous parse encountered promise.");
    return n;
  }
  _parseAsync(t) {
    const n = this._parse(t);
    return Promise.resolve(n);
  }
  parse(t, n) {
    const r = this.safeParse(t, n);
    if (r.success)
      return r.data;
    throw r.error;
  }
  safeParse(t, n) {
    var r;
    const a = {
      common: {
        issues: [],
        async: (r = n == null ? void 0 : n.async) !== null && r !== void 0 ? r : !1,
        contextualErrorMap: n == null ? void 0 : n.errorMap
      },
      path: (n == null ? void 0 : n.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: t,
      parsedType: Kt(t)
    }, s = this._parseSync({ data: t, path: a.path, parent: a });
    return Xi(a, s);
  }
  async parseAsync(t, n) {
    const r = await this.safeParseAsync(t, n);
    if (r.success)
      return r.data;
    throw r.error;
  }
  async safeParseAsync(t, n) {
    const r = {
      common: {
        issues: [],
        contextualErrorMap: n == null ? void 0 : n.errorMap,
        async: !0
      },
      path: (n == null ? void 0 : n.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: t,
      parsedType: Kt(t)
    }, a = this._parse({ data: t, path: r.path, parent: r }), s = await (as(a) ? a : Promise.resolve(a));
    return Xi(r, s);
  }
  refine(t, n) {
    const r = (a) => typeof n == "string" || typeof n > "u" ? { message: n } : typeof n == "function" ? n(a) : n;
    return this._refinement((a, s) => {
      const i = t(a), o = () => s.addIssue({
        code: _.custom,
        ...r(a)
      });
      return typeof Promise < "u" && i instanceof Promise ? i.then((c) => c ? !0 : (o(), !1)) : i ? !0 : (o(), !1);
    });
  }
  refinement(t, n) {
    return this._refinement((r, a) => t(r) ? !0 : (a.addIssue(typeof n == "function" ? n(r, a) : n), !1));
  }
  _refinement(t) {
    return new wt({
      schema: this,
      typeName: N.ZodEffects,
      effect: { type: "refinement", refinement: t }
    });
  }
  superRefine(t) {
    return this._refinement(t);
  }
  optional() {
    return Ct.create(this, this._def);
  }
  nullable() {
    return On.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return at.create(this, this._def);
  }
  promise() {
    return Un.create(this, this._def);
  }
  or(t) {
    return Er.create([this, t], this._def);
  }
  and(t) {
    return Cr.create(this, t, this._def);
  }
  transform(t) {
    return new wt({
      ...F(this._def),
      schema: this,
      typeName: N.ZodEffects,
      effect: { type: "transform", transform: t }
    });
  }
  default(t) {
    const n = typeof t == "function" ? t : () => t;
    return new Dr({
      ...F(this._def),
      innerType: this,
      defaultValue: n,
      typeName: N.ZodDefault
    });
  }
  brand() {
    return new Gh({
      typeName: N.ZodBranded,
      type: this,
      ...F(this._def)
    });
  }
  catch(t) {
    const n = typeof t == "function" ? t : () => t;
    return new ds({
      ...F(this._def),
      innerType: this,
      catchValue: n,
      typeName: N.ZodCatch
    });
  }
  describe(t) {
    const n = this.constructor;
    return new n({
      ...this._def,
      description: t
    });
  }
  pipe(t) {
    return Br.create(this, t);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
}
const $h = /^c[^\s-]{8,}$/i, Lh = /^[a-z][a-z0-9]*$/, Mh = /[0-9A-HJKMNP-TV-Z]{26}/, Zh = /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[a-f0-9]{4}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i, Fh = /^(([^<>()[\]\\.,;:\s@\"]+(\.[^<>()[\]\\.,;:\s@\"]+)*)|(\".+\"))@((\[(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\])|(\[IPv6:(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))\])|([A-Za-z0-9]([A-Za-z0-9-]*[A-Za-z0-9])*(\.[A-Za-z]{2,})+))$/, zh = /^(\p{Extended_Pictographic}|\p{Emoji_Component})+$/u, Uh = /^(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))$/, Vh = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/, Wh = (e) => e.precision ? e.offset ? new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${e.precision}}(([+-]\\d{2}(:?\\d{2})?)|Z)$`) : new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${e.precision}}Z$`) : e.precision === 0 ? e.offset ? new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(([+-]\\d{2}(:?\\d{2})?)|Z)$") : new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}Z$") : e.offset ? new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(([+-]\\d{2}(:?\\d{2})?)|Z)$") : new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?Z$");
function Bh(e, t) {
  return !!((t === "v4" || !t) && Uh.test(e) || (t === "v6" || !t) && Vh.test(e));
}
class pt extends V {
  constructor() {
    super(...arguments), this._regex = (t, n, r) => this.refinement((a) => t.test(a), {
      validation: n,
      code: _.invalid_string,
      ...C.errToObj(r)
    }), this.nonempty = (t) => this.min(1, C.errToObj(t)), this.trim = () => new pt({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    }), this.toLowerCase = () => new pt({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    }), this.toUpperCase = () => new pt({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  _parse(t) {
    if (this._def.coerce && (t.data = String(t.data)), this._getType(t) !== x.string) {
      const s = this._getOrReturnCtx(t);
      return S(
        s,
        {
          code: _.invalid_type,
          expected: x.string,
          received: s.parsedType
        }
        //
      ), M;
    }
    const r = new ke();
    let a;
    for (const s of this._def.checks)
      if (s.kind === "min")
        t.data.length < s.value && (a = this._getOrReturnCtx(t, a), S(a, {
          code: _.too_small,
          minimum: s.value,
          type: "string",
          inclusive: !0,
          exact: !1,
          message: s.message
        }), r.dirty());
      else if (s.kind === "max")
        t.data.length > s.value && (a = this._getOrReturnCtx(t, a), S(a, {
          code: _.too_big,
          maximum: s.value,
          type: "string",
          inclusive: !0,
          exact: !1,
          message: s.message
        }), r.dirty());
      else if (s.kind === "length") {
        const i = t.data.length > s.value, o = t.data.length < s.value;
        (i || o) && (a = this._getOrReturnCtx(t, a), i ? S(a, {
          code: _.too_big,
          maximum: s.value,
          type: "string",
          inclusive: !0,
          exact: !0,
          message: s.message
        }) : o && S(a, {
          code: _.too_small,
          minimum: s.value,
          type: "string",
          inclusive: !0,
          exact: !0,
          message: s.message
        }), r.dirty());
      } else if (s.kind === "email")
        Fh.test(t.data) || (a = this._getOrReturnCtx(t, a), S(a, {
          validation: "email",
          code: _.invalid_string,
          message: s.message
        }), r.dirty());
      else if (s.kind === "emoji")
        zh.test(t.data) || (a = this._getOrReturnCtx(t, a), S(a, {
          validation: "emoji",
          code: _.invalid_string,
          message: s.message
        }), r.dirty());
      else if (s.kind === "uuid")
        Zh.test(t.data) || (a = this._getOrReturnCtx(t, a), S(a, {
          validation: "uuid",
          code: _.invalid_string,
          message: s.message
        }), r.dirty());
      else if (s.kind === "cuid")
        $h.test(t.data) || (a = this._getOrReturnCtx(t, a), S(a, {
          validation: "cuid",
          code: _.invalid_string,
          message: s.message
        }), r.dirty());
      else if (s.kind === "cuid2")
        Lh.test(t.data) || (a = this._getOrReturnCtx(t, a), S(a, {
          validation: "cuid2",
          code: _.invalid_string,
          message: s.message
        }), r.dirty());
      else if (s.kind === "ulid")
        Mh.test(t.data) || (a = this._getOrReturnCtx(t, a), S(a, {
          validation: "ulid",
          code: _.invalid_string,
          message: s.message
        }), r.dirty());
      else if (s.kind === "url")
        try {
          new URL(t.data);
        } catch {
          a = this._getOrReturnCtx(t, a), S(a, {
            validation: "url",
            code: _.invalid_string,
            message: s.message
          }), r.dirty();
        }
      else
        s.kind === "regex" ? (s.regex.lastIndex = 0, s.regex.test(t.data) || (a = this._getOrReturnCtx(t, a), S(a, {
          validation: "regex",
          code: _.invalid_string,
          message: s.message
        }), r.dirty())) : s.kind === "trim" ? t.data = t.data.trim() : s.kind === "includes" ? t.data.includes(s.value, s.position) || (a = this._getOrReturnCtx(t, a), S(a, {
          code: _.invalid_string,
          validation: { includes: s.value, position: s.position },
          message: s.message
        }), r.dirty()) : s.kind === "toLowerCase" ? t.data = t.data.toLowerCase() : s.kind === "toUpperCase" ? t.data = t.data.toUpperCase() : s.kind === "startsWith" ? t.data.startsWith(s.value) || (a = this._getOrReturnCtx(t, a), S(a, {
          code: _.invalid_string,
          validation: { startsWith: s.value },
          message: s.message
        }), r.dirty()) : s.kind === "endsWith" ? t.data.endsWith(s.value) || (a = this._getOrReturnCtx(t, a), S(a, {
          code: _.invalid_string,
          validation: { endsWith: s.value },
          message: s.message
        }), r.dirty()) : s.kind === "datetime" ? Wh(s).test(t.data) || (a = this._getOrReturnCtx(t, a), S(a, {
          code: _.invalid_string,
          validation: "datetime",
          message: s.message
        }), r.dirty()) : s.kind === "ip" ? Bh(t.data, s.version) || (a = this._getOrReturnCtx(t, a), S(a, {
          validation: "ip",
          code: _.invalid_string,
          message: s.message
        }), r.dirty()) : J.assertNever(s);
    return { status: r.value, value: t.data };
  }
  _addCheck(t) {
    return new pt({
      ...this._def,
      checks: [...this._def.checks, t]
    });
  }
  email(t) {
    return this._addCheck({ kind: "email", ...C.errToObj(t) });
  }
  url(t) {
    return this._addCheck({ kind: "url", ...C.errToObj(t) });
  }
  emoji(t) {
    return this._addCheck({ kind: "emoji", ...C.errToObj(t) });
  }
  uuid(t) {
    return this._addCheck({ kind: "uuid", ...C.errToObj(t) });
  }
  cuid(t) {
    return this._addCheck({ kind: "cuid", ...C.errToObj(t) });
  }
  cuid2(t) {
    return this._addCheck({ kind: "cuid2", ...C.errToObj(t) });
  }
  ulid(t) {
    return this._addCheck({ kind: "ulid", ...C.errToObj(t) });
  }
  ip(t) {
    return this._addCheck({ kind: "ip", ...C.errToObj(t) });
  }
  datetime(t) {
    var n;
    return typeof t == "string" ? this._addCheck({
      kind: "datetime",
      precision: null,
      offset: !1,
      message: t
    }) : this._addCheck({
      kind: "datetime",
      precision: typeof (t == null ? void 0 : t.precision) > "u" ? null : t == null ? void 0 : t.precision,
      offset: (n = t == null ? void 0 : t.offset) !== null && n !== void 0 ? n : !1,
      ...C.errToObj(t == null ? void 0 : t.message)
    });
  }
  regex(t, n) {
    return this._addCheck({
      kind: "regex",
      regex: t,
      ...C.errToObj(n)
    });
  }
  includes(t, n) {
    return this._addCheck({
      kind: "includes",
      value: t,
      position: n == null ? void 0 : n.position,
      ...C.errToObj(n == null ? void 0 : n.message)
    });
  }
  startsWith(t, n) {
    return this._addCheck({
      kind: "startsWith",
      value: t,
      ...C.errToObj(n)
    });
  }
  endsWith(t, n) {
    return this._addCheck({
      kind: "endsWith",
      value: t,
      ...C.errToObj(n)
    });
  }
  min(t, n) {
    return this._addCheck({
      kind: "min",
      value: t,
      ...C.errToObj(n)
    });
  }
  max(t, n) {
    return this._addCheck({
      kind: "max",
      value: t,
      ...C.errToObj(n)
    });
  }
  length(t, n) {
    return this._addCheck({
      kind: "length",
      value: t,
      ...C.errToObj(n)
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((t) => t.kind === "datetime");
  }
  get isEmail() {
    return !!this._def.checks.find((t) => t.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((t) => t.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((t) => t.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((t) => t.kind === "uuid");
  }
  get isCUID() {
    return !!this._def.checks.find((t) => t.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((t) => t.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((t) => t.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((t) => t.kind === "ip");
  }
  get minLength() {
    let t = null;
    for (const n of this._def.checks)
      n.kind === "min" && (t === null || n.value > t) && (t = n.value);
    return t;
  }
  get maxLength() {
    let t = null;
    for (const n of this._def.checks)
      n.kind === "max" && (t === null || n.value < t) && (t = n.value);
    return t;
  }
}
pt.create = (e) => {
  var t;
  return new pt({
    checks: [],
    typeName: N.ZodString,
    coerce: (t = e == null ? void 0 : e.coerce) !== null && t !== void 0 ? t : !1,
    ...F(e)
  });
};
function Kh(e, t) {
  const n = (e.toString().split(".")[1] || "").length, r = (t.toString().split(".")[1] || "").length, a = n > r ? n : r, s = parseInt(e.toFixed(a).replace(".", "")), i = parseInt(t.toFixed(a).replace(".", ""));
  return s % i / Math.pow(10, a);
}
class Sn extends V {
  constructor() {
    super(...arguments), this.min = this.gte, this.max = this.lte, this.step = this.multipleOf;
  }
  _parse(t) {
    if (this._def.coerce && (t.data = Number(t.data)), this._getType(t) !== x.number) {
      const s = this._getOrReturnCtx(t);
      return S(s, {
        code: _.invalid_type,
        expected: x.number,
        received: s.parsedType
      }), M;
    }
    let r;
    const a = new ke();
    for (const s of this._def.checks)
      s.kind === "int" ? J.isInteger(t.data) || (r = this._getOrReturnCtx(t, r), S(r, {
        code: _.invalid_type,
        expected: "integer",
        received: "float",
        message: s.message
      }), a.dirty()) : s.kind === "min" ? (s.inclusive ? t.data < s.value : t.data <= s.value) && (r = this._getOrReturnCtx(t, r), S(r, {
        code: _.too_small,
        minimum: s.value,
        type: "number",
        inclusive: s.inclusive,
        exact: !1,
        message: s.message
      }), a.dirty()) : s.kind === "max" ? (s.inclusive ? t.data > s.value : t.data >= s.value) && (r = this._getOrReturnCtx(t, r), S(r, {
        code: _.too_big,
        maximum: s.value,
        type: "number",
        inclusive: s.inclusive,
        exact: !1,
        message: s.message
      }), a.dirty()) : s.kind === "multipleOf" ? Kh(t.data, s.value) !== 0 && (r = this._getOrReturnCtx(t, r), S(r, {
        code: _.not_multiple_of,
        multipleOf: s.value,
        message: s.message
      }), a.dirty()) : s.kind === "finite" ? Number.isFinite(t.data) || (r = this._getOrReturnCtx(t, r), S(r, {
        code: _.not_finite,
        message: s.message
      }), a.dirty()) : J.assertNever(s);
    return { status: a.value, value: t.data };
  }
  gte(t, n) {
    return this.setLimit("min", t, !0, C.toString(n));
  }
  gt(t, n) {
    return this.setLimit("min", t, !1, C.toString(n));
  }
  lte(t, n) {
    return this.setLimit("max", t, !0, C.toString(n));
  }
  lt(t, n) {
    return this.setLimit("max", t, !1, C.toString(n));
  }
  setLimit(t, n, r, a) {
    return new Sn({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind: t,
          value: n,
          inclusive: r,
          message: C.toString(a)
        }
      ]
    });
  }
  _addCheck(t) {
    return new Sn({
      ...this._def,
      checks: [...this._def.checks, t]
    });
  }
  int(t) {
    return this._addCheck({
      kind: "int",
      message: C.toString(t)
    });
  }
  positive(t) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: !1,
      message: C.toString(t)
    });
  }
  negative(t) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: !1,
      message: C.toString(t)
    });
  }
  nonpositive(t) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: !0,
      message: C.toString(t)
    });
  }
  nonnegative(t) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: !0,
      message: C.toString(t)
    });
  }
  multipleOf(t, n) {
    return this._addCheck({
      kind: "multipleOf",
      value: t,
      message: C.toString(n)
    });
  }
  finite(t) {
    return this._addCheck({
      kind: "finite",
      message: C.toString(t)
    });
  }
  safe(t) {
    return this._addCheck({
      kind: "min",
      inclusive: !0,
      value: Number.MIN_SAFE_INTEGER,
      message: C.toString(t)
    })._addCheck({
      kind: "max",
      inclusive: !0,
      value: Number.MAX_SAFE_INTEGER,
      message: C.toString(t)
    });
  }
  get minValue() {
    let t = null;
    for (const n of this._def.checks)
      n.kind === "min" && (t === null || n.value > t) && (t = n.value);
    return t;
  }
  get maxValue() {
    let t = null;
    for (const n of this._def.checks)
      n.kind === "max" && (t === null || n.value < t) && (t = n.value);
    return t;
  }
  get isInt() {
    return !!this._def.checks.find((t) => t.kind === "int" || t.kind === "multipleOf" && J.isInteger(t.value));
  }
  get isFinite() {
    let t = null, n = null;
    for (const r of this._def.checks) {
      if (r.kind === "finite" || r.kind === "int" || r.kind === "multipleOf")
        return !0;
      r.kind === "min" ? (n === null || r.value > n) && (n = r.value) : r.kind === "max" && (t === null || r.value < t) && (t = r.value);
    }
    return Number.isFinite(n) && Number.isFinite(t);
  }
}
Sn.create = (e) => new Sn({
  checks: [],
  typeName: N.ZodNumber,
  coerce: (e == null ? void 0 : e.coerce) || !1,
  ...F(e)
});
class Tn extends V {
  constructor() {
    super(...arguments), this.min = this.gte, this.max = this.lte;
  }
  _parse(t) {
    if (this._def.coerce && (t.data = BigInt(t.data)), this._getType(t) !== x.bigint) {
      const s = this._getOrReturnCtx(t);
      return S(s, {
        code: _.invalid_type,
        expected: x.bigint,
        received: s.parsedType
      }), M;
    }
    let r;
    const a = new ke();
    for (const s of this._def.checks)
      s.kind === "min" ? (s.inclusive ? t.data < s.value : t.data <= s.value) && (r = this._getOrReturnCtx(t, r), S(r, {
        code: _.too_small,
        type: "bigint",
        minimum: s.value,
        inclusive: s.inclusive,
        message: s.message
      }), a.dirty()) : s.kind === "max" ? (s.inclusive ? t.data > s.value : t.data >= s.value) && (r = this._getOrReturnCtx(t, r), S(r, {
        code: _.too_big,
        type: "bigint",
        maximum: s.value,
        inclusive: s.inclusive,
        message: s.message
      }), a.dirty()) : s.kind === "multipleOf" ? t.data % s.value !== BigInt(0) && (r = this._getOrReturnCtx(t, r), S(r, {
        code: _.not_multiple_of,
        multipleOf: s.value,
        message: s.message
      }), a.dirty()) : J.assertNever(s);
    return { status: a.value, value: t.data };
  }
  gte(t, n) {
    return this.setLimit("min", t, !0, C.toString(n));
  }
  gt(t, n) {
    return this.setLimit("min", t, !1, C.toString(n));
  }
  lte(t, n) {
    return this.setLimit("max", t, !0, C.toString(n));
  }
  lt(t, n) {
    return this.setLimit("max", t, !1, C.toString(n));
  }
  setLimit(t, n, r, a) {
    return new Tn({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind: t,
          value: n,
          inclusive: r,
          message: C.toString(a)
        }
      ]
    });
  }
  _addCheck(t) {
    return new Tn({
      ...this._def,
      checks: [...this._def.checks, t]
    });
  }
  positive(t) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: !1,
      message: C.toString(t)
    });
  }
  negative(t) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: !1,
      message: C.toString(t)
    });
  }
  nonpositive(t) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: !0,
      message: C.toString(t)
    });
  }
  nonnegative(t) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: !0,
      message: C.toString(t)
    });
  }
  multipleOf(t, n) {
    return this._addCheck({
      kind: "multipleOf",
      value: t,
      message: C.toString(n)
    });
  }
  get minValue() {
    let t = null;
    for (const n of this._def.checks)
      n.kind === "min" && (t === null || n.value > t) && (t = n.value);
    return t;
  }
  get maxValue() {
    let t = null;
    for (const n of this._def.checks)
      n.kind === "max" && (t === null || n.value < t) && (t = n.value);
    return t;
  }
}
Tn.create = (e) => {
  var t;
  return new Tn({
    checks: [],
    typeName: N.ZodBigInt,
    coerce: (t = e == null ? void 0 : e.coerce) !== null && t !== void 0 ? t : !1,
    ...F(e)
  });
};
class ss extends V {
  _parse(t) {
    if (this._def.coerce && (t.data = !!t.data), this._getType(t) !== x.boolean) {
      const r = this._getOrReturnCtx(t);
      return S(r, {
        code: _.invalid_type,
        expected: x.boolean,
        received: r.parsedType
      }), M;
    }
    return Ee(t.data);
  }
}
ss.create = (e) => new ss({
  typeName: N.ZodBoolean,
  coerce: (e == null ? void 0 : e.coerce) || !1,
  ...F(e)
});
class zn extends V {
  _parse(t) {
    if (this._def.coerce && (t.data = new Date(t.data)), this._getType(t) !== x.date) {
      const s = this._getOrReturnCtx(t);
      return S(s, {
        code: _.invalid_type,
        expected: x.date,
        received: s.parsedType
      }), M;
    }
    if (isNaN(t.data.getTime())) {
      const s = this._getOrReturnCtx(t);
      return S(s, {
        code: _.invalid_date
      }), M;
    }
    const r = new ke();
    let a;
    for (const s of this._def.checks)
      s.kind === "min" ? t.data.getTime() < s.value && (a = this._getOrReturnCtx(t, a), S(a, {
        code: _.too_small,
        message: s.message,
        inclusive: !0,
        exact: !1,
        minimum: s.value,
        type: "date"
      }), r.dirty()) : s.kind === "max" ? t.data.getTime() > s.value && (a = this._getOrReturnCtx(t, a), S(a, {
        code: _.too_big,
        message: s.message,
        inclusive: !0,
        exact: !1,
        maximum: s.value,
        type: "date"
      }), r.dirty()) : J.assertNever(s);
    return {
      status: r.value,
      value: new Date(t.data.getTime())
    };
  }
  _addCheck(t) {
    return new zn({
      ...this._def,
      checks: [...this._def.checks, t]
    });
  }
  min(t, n) {
    return this._addCheck({
      kind: "min",
      value: t.getTime(),
      message: C.toString(n)
    });
  }
  max(t, n) {
    return this._addCheck({
      kind: "max",
      value: t.getTime(),
      message: C.toString(n)
    });
  }
  get minDate() {
    let t = null;
    for (const n of this._def.checks)
      n.kind === "min" && (t === null || n.value > t) && (t = n.value);
    return t != null ? new Date(t) : null;
  }
  get maxDate() {
    let t = null;
    for (const n of this._def.checks)
      n.kind === "max" && (t === null || n.value < t) && (t = n.value);
    return t != null ? new Date(t) : null;
  }
}
zn.create = (e) => new zn({
  checks: [],
  coerce: (e == null ? void 0 : e.coerce) || !1,
  typeName: N.ZodDate,
  ...F(e)
});
class is extends V {
  _parse(t) {
    if (this._getType(t) !== x.symbol) {
      const r = this._getOrReturnCtx(t);
      return S(r, {
        code: _.invalid_type,
        expected: x.symbol,
        received: r.parsedType
      }), M;
    }
    return Ee(t.data);
  }
}
is.create = (e) => new is({
  typeName: N.ZodSymbol,
  ...F(e)
});
class Pr extends V {
  _parse(t) {
    if (this._getType(t) !== x.undefined) {
      const r = this._getOrReturnCtx(t);
      return S(r, {
        code: _.invalid_type,
        expected: x.undefined,
        received: r.parsedType
      }), M;
    }
    return Ee(t.data);
  }
}
Pr.create = (e) => new Pr({
  typeName: N.ZodUndefined,
  ...F(e)
});
class Or extends V {
  _parse(t) {
    if (this._getType(t) !== x.null) {
      const r = this._getOrReturnCtx(t);
      return S(r, {
        code: _.invalid_type,
        expected: x.null,
        received: r.parsedType
      }), M;
    }
    return Ee(t.data);
  }
}
Or.create = (e) => new Or({
  typeName: N.ZodNull,
  ...F(e)
});
class os extends V {
  constructor() {
    super(...arguments), this._any = !0;
  }
  _parse(t) {
    return Ee(t.data);
  }
}
os.create = (e) => new os({
  typeName: N.ZodAny,
  ...F(e)
});
class yn extends V {
  constructor() {
    super(...arguments), this._unknown = !0;
  }
  _parse(t) {
    return Ee(t.data);
  }
}
yn.create = (e) => new yn({
  typeName: N.ZodUnknown,
  ...F(e)
});
class Rt extends V {
  _parse(t) {
    const n = this._getOrReturnCtx(t);
    return S(n, {
      code: _.invalid_type,
      expected: x.never,
      received: n.parsedType
    }), M;
  }
}
Rt.create = (e) => new Rt({
  typeName: N.ZodNever,
  ...F(e)
});
class us extends V {
  _parse(t) {
    if (this._getType(t) !== x.undefined) {
      const r = this._getOrReturnCtx(t);
      return S(r, {
        code: _.invalid_type,
        expected: x.void,
        received: r.parsedType
      }), M;
    }
    return Ee(t.data);
  }
}
us.create = (e) => new us({
  typeName: N.ZodVoid,
  ...F(e)
});
class at extends V {
  _parse(t) {
    const { ctx: n, status: r } = this._processInputParams(t), a = this._def;
    if (n.parsedType !== x.array)
      return S(n, {
        code: _.invalid_type,
        expected: x.array,
        received: n.parsedType
      }), M;
    if (a.exactLength !== null) {
      const i = n.data.length > a.exactLength.value, o = n.data.length < a.exactLength.value;
      (i || o) && (S(n, {
        code: i ? _.too_big : _.too_small,
        minimum: o ? a.exactLength.value : void 0,
        maximum: i ? a.exactLength.value : void 0,
        type: "array",
        inclusive: !0,
        exact: !0,
        message: a.exactLength.message
      }), r.dirty());
    }
    if (a.minLength !== null && n.data.length < a.minLength.value && (S(n, {
      code: _.too_small,
      minimum: a.minLength.value,
      type: "array",
      inclusive: !0,
      exact: !1,
      message: a.minLength.message
    }), r.dirty()), a.maxLength !== null && n.data.length > a.maxLength.value && (S(n, {
      code: _.too_big,
      maximum: a.maxLength.value,
      type: "array",
      inclusive: !0,
      exact: !1,
      message: a.maxLength.message
    }), r.dirty()), n.common.async)
      return Promise.all([...n.data].map((i, o) => a.type._parseAsync(new it(n, i, n.path, o)))).then((i) => ke.mergeArray(r, i));
    const s = [...n.data].map((i, o) => a.type._parseSync(new it(n, i, n.path, o)));
    return ke.mergeArray(r, s);
  }
  get element() {
    return this._def.type;
  }
  min(t, n) {
    return new at({
      ...this._def,
      minLength: { value: t, message: C.toString(n) }
    });
  }
  max(t, n) {
    return new at({
      ...this._def,
      maxLength: { value: t, message: C.toString(n) }
    });
  }
  length(t, n) {
    return new at({
      ...this._def,
      exactLength: { value: t, message: C.toString(n) }
    });
  }
  nonempty(t) {
    return this.min(1, t);
  }
}
at.create = (e, t) => new at({
  type: e,
  minLength: null,
  maxLength: null,
  exactLength: null,
  typeName: N.ZodArray,
  ...F(t)
});
function dn(e) {
  if (e instanceof ce) {
    const t = {};
    for (const n in e.shape) {
      const r = e.shape[n];
      t[n] = Ct.create(dn(r));
    }
    return new ce({
      ...e._def,
      shape: () => t
    });
  } else
    return e instanceof at ? new at({
      ...e._def,
      type: dn(e.element)
    }) : e instanceof Ct ? Ct.create(dn(e.unwrap())) : e instanceof On ? On.create(dn(e.unwrap())) : e instanceof bt ? bt.create(e.items.map((t) => dn(t))) : e;
}
class ce extends V {
  constructor() {
    super(...arguments), this._cached = null, this.nonstrict = this.passthrough, this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const t = this._def.shape(), n = J.objectKeys(t);
    return this._cached = { shape: t, keys: n };
  }
  _parse(t) {
    if (this._getType(t) !== x.object) {
      const u = this._getOrReturnCtx(t);
      return S(u, {
        code: _.invalid_type,
        expected: x.object,
        received: u.parsedType
      }), M;
    }
    const { status: r, ctx: a } = this._processInputParams(t), { shape: s, keys: i } = this._getCached(), o = [];
    if (!(this._def.catchall instanceof Rt && this._def.unknownKeys === "strip"))
      for (const u in a.data)
        i.includes(u) || o.push(u);
    const c = [];
    for (const u of i) {
      const d = s[u], h = a.data[u];
      c.push({
        key: { status: "valid", value: u },
        value: d._parse(new it(a, h, a.path, u)),
        alwaysSet: u in a.data
      });
    }
    if (this._def.catchall instanceof Rt) {
      const u = this._def.unknownKeys;
      if (u === "passthrough")
        for (const d of o)
          c.push({
            key: { status: "valid", value: d },
            value: { status: "valid", value: a.data[d] }
          });
      else if (u === "strict")
        o.length > 0 && (S(a, {
          code: _.unrecognized_keys,
          keys: o
        }), r.dirty());
      else if (u !== "strip")
        throw new Error("Internal ZodObject error: invalid unknownKeys value.");
    } else {
      const u = this._def.catchall;
      for (const d of o) {
        const h = a.data[d];
        c.push({
          key: { status: "valid", value: d },
          value: u._parse(
            new it(a, h, a.path, d)
            //, ctx.child(key), value, getParsedType(value)
          ),
          alwaysSet: d in a.data
        });
      }
    }
    return a.common.async ? Promise.resolve().then(async () => {
      const u = [];
      for (const d of c) {
        const h = await d.key;
        u.push({
          key: h,
          value: await d.value,
          alwaysSet: d.alwaysSet
        });
      }
      return u;
    }).then((u) => ke.mergeObjectSync(r, u)) : ke.mergeObjectSync(r, c);
  }
  get shape() {
    return this._def.shape();
  }
  strict(t) {
    return C.errToObj, new ce({
      ...this._def,
      unknownKeys: "strict",
      ...t !== void 0 ? {
        errorMap: (n, r) => {
          var a, s, i, o;
          const c = (i = (s = (a = this._def).errorMap) === null || s === void 0 ? void 0 : s.call(a, n, r).message) !== null && i !== void 0 ? i : r.defaultError;
          return n.code === "unrecognized_keys" ? {
            message: (o = C.errToObj(t).message) !== null && o !== void 0 ? o : c
          } : {
            message: c
          };
        }
      } : {}
    });
  }
  strip() {
    return new ce({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new ce({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  // const AugmentFactory =
  //   <Def extends ZodObjectDef>(def: Def) =>
  //   <Augmentation extends ZodRawShape>(
  //     augmentation: Augmentation
  //   ): ZodObject<
  //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
  //     Def["unknownKeys"],
  //     Def["catchall"]
  //   > => {
  //     return new ZodObject({
  //       ...def,
  //       shape: () => ({
  //         ...def.shape(),
  //         ...augmentation,
  //       }),
  //     }) as any;
  //   };
  extend(t) {
    return new ce({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...t
      })
    });
  }
  /**
   * Prior to zod@1.0.12 there was a bug in the
   * inferred type of merged objects. Please
   * upgrade if you are experiencing issues.
   */
  merge(t) {
    return new ce({
      unknownKeys: t._def.unknownKeys,
      catchall: t._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...t._def.shape()
      }),
      typeName: N.ZodObject
    });
  }
  // merge<
  //   Incoming extends AnyZodObject,
  //   Augmentation extends Incoming["shape"],
  //   NewOutput extends {
  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
  //       ? Augmentation[k]["_output"]
  //       : k extends keyof Output
  //       ? Output[k]
  //       : never;
  //   },
  //   NewInput extends {
  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
  //       ? Augmentation[k]["_input"]
  //       : k extends keyof Input
  //       ? Input[k]
  //       : never;
  //   }
  // >(
  //   merging: Incoming
  // ): ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"],
  //   NewOutput,
  //   NewInput
  // > {
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  setKey(t, n) {
    return this.augment({ [t]: n });
  }
  // merge<Incoming extends AnyZodObject>(
  //   merging: Incoming
  // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
  // ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"]
  // > {
  //   // const mergedShape = objectUtil.mergeShapes(
  //   //   this._def.shape(),
  //   //   merging._def.shape()
  //   // );
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  catchall(t) {
    return new ce({
      ...this._def,
      catchall: t
    });
  }
  pick(t) {
    const n = {};
    return J.objectKeys(t).forEach((r) => {
      t[r] && this.shape[r] && (n[r] = this.shape[r]);
    }), new ce({
      ...this._def,
      shape: () => n
    });
  }
  omit(t) {
    const n = {};
    return J.objectKeys(this.shape).forEach((r) => {
      t[r] || (n[r] = this.shape[r]);
    }), new ce({
      ...this._def,
      shape: () => n
    });
  }
  /**
   * @deprecated
   */
  deepPartial() {
    return dn(this);
  }
  partial(t) {
    const n = {};
    return J.objectKeys(this.shape).forEach((r) => {
      const a = this.shape[r];
      t && !t[r] ? n[r] = a : n[r] = a.optional();
    }), new ce({
      ...this._def,
      shape: () => n
    });
  }
  required(t) {
    const n = {};
    return J.objectKeys(this.shape).forEach((r) => {
      if (t && !t[r])
        n[r] = this.shape[r];
      else {
        let s = this.shape[r];
        for (; s instanceof Ct; )
          s = s._def.innerType;
        n[r] = s;
      }
    }), new ce({
      ...this._def,
      shape: () => n
    });
  }
  keyof() {
    return Tu(J.objectKeys(this.shape));
  }
}
ce.create = (e, t) => new ce({
  shape: () => e,
  unknownKeys: "strip",
  catchall: Rt.create(),
  typeName: N.ZodObject,
  ...F(t)
});
ce.strictCreate = (e, t) => new ce({
  shape: () => e,
  unknownKeys: "strict",
  catchall: Rt.create(),
  typeName: N.ZodObject,
  ...F(t)
});
ce.lazycreate = (e, t) => new ce({
  shape: e,
  unknownKeys: "strip",
  catchall: Rt.create(),
  typeName: N.ZodObject,
  ...F(t)
});
class Er extends V {
  _parse(t) {
    const { ctx: n } = this._processInputParams(t), r = this._def.options;
    function a(s) {
      for (const o of s)
        if (o.result.status === "valid")
          return o.result;
      for (const o of s)
        if (o.result.status === "dirty")
          return n.common.issues.push(...o.ctx.common.issues), o.result;
      const i = s.map((o) => new rt(o.ctx.common.issues));
      return S(n, {
        code: _.invalid_union,
        unionErrors: i
      }), M;
    }
    if (n.common.async)
      return Promise.all(r.map(async (s) => {
        const i = {
          ...n,
          common: {
            ...n.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await s._parseAsync({
            data: n.data,
            path: n.path,
            parent: i
          }),
          ctx: i
        };
      })).then(a);
    {
      let s;
      const i = [];
      for (const c of r) {
        const u = {
          ...n,
          common: {
            ...n.common,
            issues: []
          },
          parent: null
        }, d = c._parseSync({
          data: n.data,
          path: n.path,
          parent: u
        });
        if (d.status === "valid")
          return d;
        d.status === "dirty" && !s && (s = { result: d, ctx: u }), u.common.issues.length && i.push(u.common.issues);
      }
      if (s)
        return n.common.issues.push(...s.ctx.common.issues), s.result;
      const o = i.map((c) => new rt(c));
      return S(n, {
        code: _.invalid_union,
        unionErrors: o
      }), M;
    }
  }
  get options() {
    return this._def.options;
  }
}
Er.create = (e, t) => new Er({
  options: e,
  typeName: N.ZodUnion,
  ...F(t)
});
const hr = (e) => e instanceof Ir ? hr(e.schema) : e instanceof wt ? hr(e.innerType()) : e instanceof Rr ? [e.value] : e instanceof tn ? e.options : e instanceof Nr ? Object.keys(e.enum) : e instanceof Dr ? hr(e._def.innerType) : e instanceof Pr ? [void 0] : e instanceof Or ? [null] : null;
class qs extends V {
  _parse(t) {
    const { ctx: n } = this._processInputParams(t);
    if (n.parsedType !== x.object)
      return S(n, {
        code: _.invalid_type,
        expected: x.object,
        received: n.parsedType
      }), M;
    const r = this.discriminator, a = n.data[r], s = this.optionsMap.get(a);
    return s ? n.common.async ? s._parseAsync({
      data: n.data,
      path: n.path,
      parent: n
    }) : s._parseSync({
      data: n.data,
      path: n.path,
      parent: n
    }) : (S(n, {
      code: _.invalid_union_discriminator,
      options: Array.from(this.optionsMap.keys()),
      path: [r]
    }), M);
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  /**
   * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
   * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
   * have a different value for each object in the union.
   * @param discriminator the name of the discriminator property
   * @param types an array of object schemas
   * @param params
   */
  static create(t, n, r) {
    const a = /* @__PURE__ */ new Map();
    for (const s of n) {
      const i = hr(s.shape[t]);
      if (!i)
        throw new Error(`A discriminator value for key \`${t}\` could not be extracted from all schema options`);
      for (const o of i) {
        if (a.has(o))
          throw new Error(`Discriminator property ${String(t)} has duplicate value ${String(o)}`);
        a.set(o, s);
      }
    }
    return new qs({
      typeName: N.ZodDiscriminatedUnion,
      discriminator: t,
      options: n,
      optionsMap: a,
      ...F(r)
    });
  }
}
function cs(e, t) {
  const n = Kt(e), r = Kt(t);
  if (e === t)
    return { valid: !0, data: e };
  if (n === x.object && r === x.object) {
    const a = J.objectKeys(t), s = J.objectKeys(e).filter((o) => a.indexOf(o) !== -1), i = { ...e, ...t };
    for (const o of s) {
      const c = cs(e[o], t[o]);
      if (!c.valid)
        return { valid: !1 };
      i[o] = c.data;
    }
    return { valid: !0, data: i };
  } else if (n === x.array && r === x.array) {
    if (e.length !== t.length)
      return { valid: !1 };
    const a = [];
    for (let s = 0; s < e.length; s++) {
      const i = e[s], o = t[s], c = cs(i, o);
      if (!c.valid)
        return { valid: !1 };
      a.push(c.data);
    }
    return { valid: !0, data: a };
  } else
    return n === x.date && r === x.date && +e == +t ? { valid: !0, data: e } : { valid: !1 };
}
class Cr extends V {
  _parse(t) {
    const { status: n, ctx: r } = this._processInputParams(t), a = (s, i) => {
      if (Ji(s) || Ji(i))
        return M;
      const o = cs(s.value, i.value);
      return o.valid ? ((Yi(s) || Yi(i)) && n.dirty(), { status: n.value, value: o.data }) : (S(r, {
        code: _.invalid_intersection_types
      }), M);
    };
    return r.common.async ? Promise.all([
      this._def.left._parseAsync({
        data: r.data,
        path: r.path,
        parent: r
      }),
      this._def.right._parseAsync({
        data: r.data,
        path: r.path,
        parent: r
      })
    ]).then(([s, i]) => a(s, i)) : a(this._def.left._parseSync({
      data: r.data,
      path: r.path,
      parent: r
    }), this._def.right._parseSync({
      data: r.data,
      path: r.path,
      parent: r
    }));
  }
}
Cr.create = (e, t, n) => new Cr({
  left: e,
  right: t,
  typeName: N.ZodIntersection,
  ...F(n)
});
class bt extends V {
  _parse(t) {
    const { status: n, ctx: r } = this._processInputParams(t);
    if (r.parsedType !== x.array)
      return S(r, {
        code: _.invalid_type,
        expected: x.array,
        received: r.parsedType
      }), M;
    if (r.data.length < this._def.items.length)
      return S(r, {
        code: _.too_small,
        minimum: this._def.items.length,
        inclusive: !0,
        exact: !1,
        type: "array"
      }), M;
    !this._def.rest && r.data.length > this._def.items.length && (S(r, {
      code: _.too_big,
      maximum: this._def.items.length,
      inclusive: !0,
      exact: !1,
      type: "array"
    }), n.dirty());
    const s = [...r.data].map((i, o) => {
      const c = this._def.items[o] || this._def.rest;
      return c ? c._parse(new it(r, i, r.path, o)) : null;
    }).filter((i) => !!i);
    return r.common.async ? Promise.all(s).then((i) => ke.mergeArray(n, i)) : ke.mergeArray(n, s);
  }
  get items() {
    return this._def.items;
  }
  rest(t) {
    return new bt({
      ...this._def,
      rest: t
    });
  }
}
bt.create = (e, t) => {
  if (!Array.isArray(e))
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  return new bt({
    items: e,
    typeName: N.ZodTuple,
    rest: null,
    ...F(t)
  });
};
class Ar extends V {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(t) {
    const { status: n, ctx: r } = this._processInputParams(t);
    if (r.parsedType !== x.object)
      return S(r, {
        code: _.invalid_type,
        expected: x.object,
        received: r.parsedType
      }), M;
    const a = [], s = this._def.keyType, i = this._def.valueType;
    for (const o in r.data)
      a.push({
        key: s._parse(new it(r, o, r.path, o)),
        value: i._parse(new it(r, r.data[o], r.path, o))
      });
    return r.common.async ? ke.mergeObjectAsync(n, a) : ke.mergeObjectSync(n, a);
  }
  get element() {
    return this._def.valueType;
  }
  static create(t, n, r) {
    return n instanceof V ? new Ar({
      keyType: t,
      valueType: n,
      typeName: N.ZodRecord,
      ...F(r)
    }) : new Ar({
      keyType: pt.create(),
      valueType: t,
      typeName: N.ZodRecord,
      ...F(n)
    });
  }
}
class ls extends V {
  _parse(t) {
    const { status: n, ctx: r } = this._processInputParams(t);
    if (r.parsedType !== x.map)
      return S(r, {
        code: _.invalid_type,
        expected: x.map,
        received: r.parsedType
      }), M;
    const a = this._def.keyType, s = this._def.valueType, i = [...r.data.entries()].map(([o, c], u) => ({
      key: a._parse(new it(r, o, r.path, [u, "key"])),
      value: s._parse(new it(r, c, r.path, [u, "value"]))
    }));
    if (r.common.async) {
      const o = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (const c of i) {
          const u = await c.key, d = await c.value;
          if (u.status === "aborted" || d.status === "aborted")
            return M;
          (u.status === "dirty" || d.status === "dirty") && n.dirty(), o.set(u.value, d.value);
        }
        return { status: n.value, value: o };
      });
    } else {
      const o = /* @__PURE__ */ new Map();
      for (const c of i) {
        const u = c.key, d = c.value;
        if (u.status === "aborted" || d.status === "aborted")
          return M;
        (u.status === "dirty" || d.status === "dirty") && n.dirty(), o.set(u.value, d.value);
      }
      return { status: n.value, value: o };
    }
  }
}
ls.create = (e, t, n) => new ls({
  valueType: t,
  keyType: e,
  typeName: N.ZodMap,
  ...F(n)
});
class Pn extends V {
  _parse(t) {
    const { status: n, ctx: r } = this._processInputParams(t);
    if (r.parsedType !== x.set)
      return S(r, {
        code: _.invalid_type,
        expected: x.set,
        received: r.parsedType
      }), M;
    const a = this._def;
    a.minSize !== null && r.data.size < a.minSize.value && (S(r, {
      code: _.too_small,
      minimum: a.minSize.value,
      type: "set",
      inclusive: !0,
      exact: !1,
      message: a.minSize.message
    }), n.dirty()), a.maxSize !== null && r.data.size > a.maxSize.value && (S(r, {
      code: _.too_big,
      maximum: a.maxSize.value,
      type: "set",
      inclusive: !0,
      exact: !1,
      message: a.maxSize.message
    }), n.dirty());
    const s = this._def.valueType;
    function i(c) {
      const u = /* @__PURE__ */ new Set();
      for (const d of c) {
        if (d.status === "aborted")
          return M;
        d.status === "dirty" && n.dirty(), u.add(d.value);
      }
      return { status: n.value, value: u };
    }
    const o = [...r.data.values()].map((c, u) => s._parse(new it(r, c, r.path, u)));
    return r.common.async ? Promise.all(o).then((c) => i(c)) : i(o);
  }
  min(t, n) {
    return new Pn({
      ...this._def,
      minSize: { value: t, message: C.toString(n) }
    });
  }
  max(t, n) {
    return new Pn({
      ...this._def,
      maxSize: { value: t, message: C.toString(n) }
    });
  }
  size(t, n) {
    return this.min(t, n).max(t, n);
  }
  nonempty(t) {
    return this.min(1, t);
  }
}
Pn.create = (e, t) => new Pn({
  valueType: e,
  minSize: null,
  maxSize: null,
  typeName: N.ZodSet,
  ...F(t)
});
class Ln extends V {
  constructor() {
    super(...arguments), this.validate = this.implement;
  }
  _parse(t) {
    const { ctx: n } = this._processInputParams(t);
    if (n.parsedType !== x.function)
      return S(n, {
        code: _.invalid_type,
        expected: x.function,
        received: n.parsedType
      }), M;
    function r(o, c) {
      return ns({
        data: o,
        path: n.path,
        errorMaps: [
          n.common.contextualErrorMap,
          n.schemaErrorMap,
          ts(),
          Tr
        ].filter((u) => !!u),
        issueData: {
          code: _.invalid_arguments,
          argumentsError: c
        }
      });
    }
    function a(o, c) {
      return ns({
        data: o,
        path: n.path,
        errorMaps: [
          n.common.contextualErrorMap,
          n.schemaErrorMap,
          ts(),
          Tr
        ].filter((u) => !!u),
        issueData: {
          code: _.invalid_return_type,
          returnTypeError: c
        }
      });
    }
    const s = { errorMap: n.common.contextualErrorMap }, i = n.data;
    return this._def.returns instanceof Un ? Ee(async (...o) => {
      const c = new rt([]), u = await this._def.args.parseAsync(o, s).catch((p) => {
        throw c.addIssue(r(o, p)), c;
      }), d = await i(...u);
      return await this._def.returns._def.type.parseAsync(d, s).catch((p) => {
        throw c.addIssue(a(d, p)), c;
      });
    }) : Ee((...o) => {
      const c = this._def.args.safeParse(o, s);
      if (!c.success)
        throw new rt([r(o, c.error)]);
      const u = i(...c.data), d = this._def.returns.safeParse(u, s);
      if (!d.success)
        throw new rt([a(u, d.error)]);
      return d.data;
    });
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...t) {
    return new Ln({
      ...this._def,
      args: bt.create(t).rest(yn.create())
    });
  }
  returns(t) {
    return new Ln({
      ...this._def,
      returns: t
    });
  }
  implement(t) {
    return this.parse(t);
  }
  strictImplement(t) {
    return this.parse(t);
  }
  static create(t, n, r) {
    return new Ln({
      args: t || bt.create([]).rest(yn.create()),
      returns: n || yn.create(),
      typeName: N.ZodFunction,
      ...F(r)
    });
  }
}
class Ir extends V {
  get schema() {
    return this._def.getter();
  }
  _parse(t) {
    const { ctx: n } = this._processInputParams(t);
    return this._def.getter()._parse({ data: n.data, path: n.path, parent: n });
  }
}
Ir.create = (e, t) => new Ir({
  getter: e,
  typeName: N.ZodLazy,
  ...F(t)
});
class Rr extends V {
  _parse(t) {
    if (t.data !== this._def.value) {
      const n = this._getOrReturnCtx(t);
      return S(n, {
        received: n.data,
        code: _.invalid_literal,
        expected: this._def.value
      }), M;
    }
    return { status: "valid", value: t.data };
  }
  get value() {
    return this._def.value;
  }
}
Rr.create = (e, t) => new Rr({
  value: e,
  typeName: N.ZodLiteral,
  ...F(t)
});
function Tu(e, t) {
  return new tn({
    values: e,
    typeName: N.ZodEnum,
    ...F(t)
  });
}
class tn extends V {
  _parse(t) {
    if (typeof t.data != "string") {
      const n = this._getOrReturnCtx(t), r = this._def.values;
      return S(n, {
        expected: J.joinValues(r),
        received: n.parsedType,
        code: _.invalid_type
      }), M;
    }
    if (this._def.values.indexOf(t.data) === -1) {
      const n = this._getOrReturnCtx(t), r = this._def.values;
      return S(n, {
        received: n.data,
        code: _.invalid_enum_value,
        options: r
      }), M;
    }
    return Ee(t.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const t = {};
    for (const n of this._def.values)
      t[n] = n;
    return t;
  }
  get Values() {
    const t = {};
    for (const n of this._def.values)
      t[n] = n;
    return t;
  }
  get Enum() {
    const t = {};
    for (const n of this._def.values)
      t[n] = n;
    return t;
  }
  extract(t) {
    return tn.create(t);
  }
  exclude(t) {
    return tn.create(this.options.filter((n) => !t.includes(n)));
  }
}
tn.create = Tu;
class Nr extends V {
  _parse(t) {
    const n = J.getValidEnumValues(this._def.values), r = this._getOrReturnCtx(t);
    if (r.parsedType !== x.string && r.parsedType !== x.number) {
      const a = J.objectValues(n);
      return S(r, {
        expected: J.joinValues(a),
        received: r.parsedType,
        code: _.invalid_type
      }), M;
    }
    if (n.indexOf(t.data) === -1) {
      const a = J.objectValues(n);
      return S(r, {
        received: r.data,
        code: _.invalid_enum_value,
        options: a
      }), M;
    }
    return Ee(t.data);
  }
  get enum() {
    return this._def.values;
  }
}
Nr.create = (e, t) => new Nr({
  values: e,
  typeName: N.ZodNativeEnum,
  ...F(t)
});
class Un extends V {
  unwrap() {
    return this._def.type;
  }
  _parse(t) {
    const { ctx: n } = this._processInputParams(t);
    if (n.parsedType !== x.promise && n.common.async === !1)
      return S(n, {
        code: _.invalid_type,
        expected: x.promise,
        received: n.parsedType
      }), M;
    const r = n.parsedType === x.promise ? n.data : Promise.resolve(n.data);
    return Ee(r.then((a) => this._def.type.parseAsync(a, {
      path: n.path,
      errorMap: n.common.contextualErrorMap
    })));
  }
}
Un.create = (e, t) => new Un({
  type: e,
  typeName: N.ZodPromise,
  ...F(t)
});
class wt extends V {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === N.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(t) {
    const { status: n, ctx: r } = this._processInputParams(t), a = this._def.effect || null;
    if (a.type === "preprocess") {
      const i = a.transform(r.data);
      return r.common.async ? Promise.resolve(i).then((o) => this._def.schema._parseAsync({
        data: o,
        path: r.path,
        parent: r
      })) : this._def.schema._parseSync({
        data: i,
        path: r.path,
        parent: r
      });
    }
    const s = {
      addIssue: (i) => {
        S(r, i), i.fatal ? n.abort() : n.dirty();
      },
      get path() {
        return r.path;
      }
    };
    if (s.addIssue = s.addIssue.bind(s), a.type === "refinement") {
      const i = (o) => {
        const c = a.refinement(o, s);
        if (r.common.async)
          return Promise.resolve(c);
        if (c instanceof Promise)
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        return o;
      };
      if (r.common.async === !1) {
        const o = this._def.schema._parseSync({
          data: r.data,
          path: r.path,
          parent: r
        });
        return o.status === "aborted" ? M : (o.status === "dirty" && n.dirty(), i(o.value), { status: n.value, value: o.value });
      } else
        return this._def.schema._parseAsync({ data: r.data, path: r.path, parent: r }).then((o) => o.status === "aborted" ? M : (o.status === "dirty" && n.dirty(), i(o.value).then(() => ({ status: n.value, value: o.value }))));
    }
    if (a.type === "transform")
      if (r.common.async === !1) {
        const i = this._def.schema._parseSync({
          data: r.data,
          path: r.path,
          parent: r
        });
        if (!rs(i))
          return i;
        const o = a.transform(i.value, s);
        if (o instanceof Promise)
          throw new Error("Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.");
        return { status: n.value, value: o };
      } else
        return this._def.schema._parseAsync({ data: r.data, path: r.path, parent: r }).then((i) => rs(i) ? Promise.resolve(a.transform(i.value, s)).then((o) => ({ status: n.value, value: o })) : i);
    J.assertNever(a);
  }
}
wt.create = (e, t, n) => new wt({
  schema: e,
  typeName: N.ZodEffects,
  effect: t,
  ...F(n)
});
wt.createWithPreprocess = (e, t, n) => new wt({
  schema: t,
  effect: { type: "preprocess", transform: e },
  typeName: N.ZodEffects,
  ...F(n)
});
class Ct extends V {
  _parse(t) {
    return this._getType(t) === x.undefined ? Ee(void 0) : this._def.innerType._parse(t);
  }
  unwrap() {
    return this._def.innerType;
  }
}
Ct.create = (e, t) => new Ct({
  innerType: e,
  typeName: N.ZodOptional,
  ...F(t)
});
class On extends V {
  _parse(t) {
    return this._getType(t) === x.null ? Ee(null) : this._def.innerType._parse(t);
  }
  unwrap() {
    return this._def.innerType;
  }
}
On.create = (e, t) => new On({
  innerType: e,
  typeName: N.ZodNullable,
  ...F(t)
});
class Dr extends V {
  _parse(t) {
    const { ctx: n } = this._processInputParams(t);
    let r = n.data;
    return n.parsedType === x.undefined && (r = this._def.defaultValue()), this._def.innerType._parse({
      data: r,
      path: n.path,
      parent: n
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
}
Dr.create = (e, t) => new Dr({
  innerType: e,
  typeName: N.ZodDefault,
  defaultValue: typeof t.default == "function" ? t.default : () => t.default,
  ...F(t)
});
class ds extends V {
  _parse(t) {
    const { ctx: n } = this._processInputParams(t), r = {
      ...n,
      common: {
        ...n.common,
        issues: []
      }
    }, a = this._def.innerType._parse({
      data: r.data,
      path: r.path,
      parent: {
        ...r
      }
    });
    return as(a) ? a.then((s) => ({
      status: "valid",
      value: s.status === "valid" ? s.value : this._def.catchValue({
        get error() {
          return new rt(r.common.issues);
        },
        input: r.data
      })
    })) : {
      status: "valid",
      value: a.status === "valid" ? a.value : this._def.catchValue({
        get error() {
          return new rt(r.common.issues);
        },
        input: r.data
      })
    };
  }
  removeCatch() {
    return this._def.innerType;
  }
}
ds.create = (e, t) => new ds({
  innerType: e,
  typeName: N.ZodCatch,
  catchValue: typeof t.catch == "function" ? t.catch : () => t.catch,
  ...F(t)
});
class fs extends V {
  _parse(t) {
    if (this._getType(t) !== x.nan) {
      const r = this._getOrReturnCtx(t);
      return S(r, {
        code: _.invalid_type,
        expected: x.nan,
        received: r.parsedType
      }), M;
    }
    return { status: "valid", value: t.data };
  }
}
fs.create = (e) => new fs({
  typeName: N.ZodNaN,
  ...F(e)
});
class Gh extends V {
  _parse(t) {
    const { ctx: n } = this._processInputParams(t), r = n.data;
    return this._def.type._parse({
      data: r,
      path: n.path,
      parent: n
    });
  }
  unwrap() {
    return this._def.type;
  }
}
class Br extends V {
  _parse(t) {
    const { status: n, ctx: r } = this._processInputParams(t);
    if (r.common.async)
      return (async () => {
        const s = await this._def.in._parseAsync({
          data: r.data,
          path: r.path,
          parent: r
        });
        return s.status === "aborted" ? M : s.status === "dirty" ? (n.dirty(), qh(s.value)) : this._def.out._parseAsync({
          data: s.value,
          path: r.path,
          parent: r
        });
      })();
    {
      const a = this._def.in._parseSync({
        data: r.data,
        path: r.path,
        parent: r
      });
      return a.status === "aborted" ? M : a.status === "dirty" ? (n.dirty(), {
        status: "dirty",
        value: a.value
      }) : this._def.out._parseSync({
        data: a.value,
        path: r.path,
        parent: r
      });
    }
  }
  static create(t, n) {
    return new Br({
      in: t,
      out: n,
      typeName: N.ZodPipeline
    });
  }
}
ce.lazycreate;
var N;
(function(e) {
  e.ZodString = "ZodString", e.ZodNumber = "ZodNumber", e.ZodNaN = "ZodNaN", e.ZodBigInt = "ZodBigInt", e.ZodBoolean = "ZodBoolean", e.ZodDate = "ZodDate", e.ZodSymbol = "ZodSymbol", e.ZodUndefined = "ZodUndefined", e.ZodNull = "ZodNull", e.ZodAny = "ZodAny", e.ZodUnknown = "ZodUnknown", e.ZodNever = "ZodNever", e.ZodVoid = "ZodVoid", e.ZodArray = "ZodArray", e.ZodObject = "ZodObject", e.ZodUnion = "ZodUnion", e.ZodDiscriminatedUnion = "ZodDiscriminatedUnion", e.ZodIntersection = "ZodIntersection", e.ZodTuple = "ZodTuple", e.ZodRecord = "ZodRecord", e.ZodMap = "ZodMap", e.ZodSet = "ZodSet", e.ZodFunction = "ZodFunction", e.ZodLazy = "ZodLazy", e.ZodLiteral = "ZodLiteral", e.ZodEnum = "ZodEnum", e.ZodEffects = "ZodEffects", e.ZodNativeEnum = "ZodNativeEnum", e.ZodOptional = "ZodOptional", e.ZodNullable = "ZodNullable", e.ZodDefault = "ZodDefault", e.ZodCatch = "ZodCatch", e.ZodPromise = "ZodPromise", e.ZodBranded = "ZodBranded", e.ZodPipeline = "ZodPipeline";
})(N || (N = {}));
const Ge = pt.create;
Sn.create;
fs.create;
Tn.create;
const Ye = ss.create;
zn.create;
is.create;
Pr.create;
Or.create;
os.create;
yn.create;
Rt.create;
us.create;
const Mn = at.create, be = ce.create;
ce.strictCreate;
Er.create;
const Pu = qs.create;
Cr.create;
bt.create;
Ar.create;
ls.create;
Pn.create;
Ln.create;
Ir.create;
const Hn = Rr.create;
tn.create;
Nr.create;
Un.create;
wt.create;
Ct.create;
On.create;
wt.createWithPreprocess;
Br.create;
const hn = {
  persona: "persona",
  account: "account"
}, Hh = be({
  challenge: Ge(),
  proof: Kn,
  address: Ge(),
  type: Hn(hn.persona)
}), Jh = be({
  challenge: Ge(),
  proof: Kn,
  address: Ge(),
  type: Hn(hn.account)
}), Yh = Pu("type", [
  Hh,
  Jh
]), Xh = be({
  entry: Hn("fullName"),
  fields: zo
}), Qh = be({
  entry: Hn("emailAddresses"),
  fields: Mn(Ge())
}), ep = be({
  entry: Hn("phoneNumbers"),
  fields: Mn(Ge())
}), tp = Pu("entry", [
  Xh,
  Qh,
  ep
]), np = be({
  accounts: Mn(Fo),
  personaData: Mn(tp),
  persona: Gn.optional(),
  proofs: Mn(Yh)
}), rp = be({
  ongoingAccounts: nt.optional(),
  ongoingPersonaData: xr.optional()
}), ap = be({
  loggedInTimestamp: Ge(),
  walletData: np,
  sharedData: rp
}), hs = {
  accounts: [],
  personaData: [],
  proofs: [],
  persona: void 0
}, sp = () => ({
  walletData: new se(hs),
  sharedData: new se({}),
  loggedInTimestamp: new se(""),
  initialized: new se(!1)
});
function ba(e, t, n, r) {
  function a(s) {
    return s instanceof n ? s : new n(function(i) {
      i(s);
    });
  }
  return new (n || (n = Promise))(function(s, i) {
    function o(d) {
      try {
        u(r.next(d));
      } catch (h) {
        i(h);
      }
    }
    function c(d) {
      try {
        u(r.throw(d));
      } catch (h) {
        i(h);
      }
    }
    function u(d) {
      d.done ? s(d.value) : a(d.value).then(o, c);
    }
    u((r = r.apply(e, t || [])).next());
  });
}
function wa(e, t) {
  var n = { label: 0, sent: function() {
    if (s[0] & 1)
      throw s[1];
    return s[1];
  }, trys: [], ops: [] }, r, a, s, i;
  return i = { next: o(0), throw: o(1), return: o(2) }, typeof Symbol == "function" && (i[Symbol.iterator] = function() {
    return this;
  }), i;
  function o(u) {
    return function(d) {
      return c([u, d]);
    };
  }
  function c(u) {
    if (r)
      throw new TypeError("Generator is already executing.");
    for (; n; )
      try {
        if (r = 1, a && (s = u[0] & 2 ? a.return : u[0] ? a.throw || ((s = a.return) && s.call(a), 0) : a.next) && !(s = s.call(a, u[1])).done)
          return s;
        switch (a = 0, s && (u = [u[0] & 2, s.value]), u[0]) {
          case 0:
          case 1:
            s = u;
            break;
          case 4:
            return n.label++, { value: u[1], done: !1 };
          case 5:
            n.label++, a = u[1], u = [0];
            continue;
          case 7:
            u = n.ops.pop(), n.trys.pop();
            continue;
          default:
            if (s = n.trys, !(s = s.length > 0 && s[s.length - 1]) && (u[0] === 6 || u[0] === 2)) {
              n = 0;
              continue;
            }
            if (u[0] === 3 && (!s || u[1] > s[0] && u[1] < s[3])) {
              n.label = u[1];
              break;
            }
            if (u[0] === 6 && n.label < s[1]) {
              n.label = s[1], s = u;
              break;
            }
            if (s && n.label < s[2]) {
              n.label = s[2], n.ops.push(u);
              break;
            }
            s[2] && n.ops.pop(), n.trys.pop();
            continue;
        }
        u = t.call(e, n);
      } catch (d) {
        u = [6, d], a = 0;
      } finally {
        r = s = 0;
      }
    if (u[0] & 5)
      throw u[1];
    return { value: u[0] ? u[1] : void 0, done: !0 };
  }
}
function jr(e, t) {
  var n = typeof Symbol == "function" && e[Symbol.iterator];
  if (!n)
    return e;
  var r = n.call(e), a, s = [], i;
  try {
    for (; (t === void 0 || t-- > 0) && !(a = r.next()).done; )
      s.push(a.value);
  } catch (o) {
    i = { error: o };
  } finally {
    try {
      a && !a.done && (n = r.return) && n.call(r);
    } finally {
      if (i)
        throw i.error;
    }
  }
  return s;
}
function Yt(e, t, n) {
  if (n || arguments.length === 2)
    for (var r = 0, a = t.length, s; r < a; r++)
      (s || !(r in t)) && (s || (s = Array.prototype.slice.call(t, 0, r)), s[r] = t[r]);
  return e.concat(s || Array.prototype.slice.call(t));
}
var ip = {
  withStackTrace: !1
}, Ou = function(e, t, n) {
  n === void 0 && (n = ip);
  var r = t.isOk() ? { type: "Ok", value: t.value } : { type: "Err", value: t.error }, a = n.withStackTrace ? new Error().stack : void 0;
  return {
    data: r,
    message: e,
    stack: a
  };
}, fe = (
  /** @class */
  function() {
    function e(t) {
      this._promise = t;
    }
    return e.fromSafePromise = function(t) {
      var n = t.then(function(r) {
        return new Pt(r);
      });
      return new e(n);
    }, e.fromPromise = function(t, n) {
      var r = t.then(function(a) {
        return new Pt(a);
      }).catch(function(a) {
        return new Gt(n(a));
      });
      return new e(r);
    }, e.combine = function(t) {
      return up(t);
    }, e.combineWithAllErrors = function(t) {
      return cp(t);
    }, e.prototype.map = function(t) {
      var n = this;
      return new e(this._promise.then(function(r) {
        return ba(n, void 0, void 0, function() {
          var a;
          return wa(this, function(s) {
            switch (s.label) {
              case 0:
                return r.isErr() ? [2, new Gt(r.error)] : (a = Pt.bind, [4, t(r.value)]);
              case 1:
                return [2, new (a.apply(Pt, [void 0, s.sent()]))()];
            }
          });
        });
      }));
    }, e.prototype.mapErr = function(t) {
      var n = this;
      return new e(this._promise.then(function(r) {
        return ba(n, void 0, void 0, function() {
          var a;
          return wa(this, function(s) {
            switch (s.label) {
              case 0:
                return r.isOk() ? [2, new Pt(r.value)] : (a = Gt.bind, [4, t(r.error)]);
              case 1:
                return [2, new (a.apply(Gt, [void 0, s.sent()]))()];
            }
          });
        });
      }));
    }, e.prototype.andThen = function(t) {
      return new e(this._promise.then(function(n) {
        if (n.isErr())
          return new Gt(n.error);
        var r = t(n.value);
        return r instanceof e ? r._promise : r;
      }));
    }, e.prototype.orElse = function(t) {
      var n = this;
      return new e(this._promise.then(function(r) {
        return ba(n, void 0, void 0, function() {
          return wa(this, function(a) {
            return r.isErr() ? [2, t(r.error)] : [2, new Pt(r.value)];
          });
        });
      }));
    }, e.prototype.match = function(t, n) {
      return this._promise.then(function(r) {
        return r.match(t, n);
      });
    }, e.prototype.unwrapOr = function(t) {
      return this._promise.then(function(n) {
        return n.unwrapOr(t);
      });
    }, e.prototype.then = function(t, n) {
      return this._promise.then(t, n);
    }, e;
  }()
), Qi = function(e) {
  return new fe(Promise.resolve(new Pt(e)));
}, eo = function(e) {
  return new fe(Promise.resolve(new Gt(e)));
};
fe.fromPromise;
fe.fromSafePromise;
var op = function(e) {
  return function(t) {
    return Yt(Yt([], jr(t), !1), [e], !1);
  };
}, Eu = function(e) {
  return e.reduce(function(t, n) {
    return t.isOk() ? n.isErr() ? vt(n.error) : t.map(op(n.value)) : t;
  }, ge([]));
}, up = function(e) {
  return fe.fromSafePromise(Promise.all(e)).andThen(Eu);
}, Cu = function(e) {
  return e.reduce(function(t, n) {
    return n.isErr() ? t.isErr() ? vt(Yt(Yt([], jr(t.error), !1), [n.error], !1)) : vt([n.error]) : t.isErr() ? t : ge(Yt(Yt([], jr(t.value), !1), [n.value], !1));
  }, ge([]));
}, cp = function(e) {
  return fe.fromSafePromise(Promise.all(e)).andThen(Cu);
}, ps;
(function(e) {
  function t(a, s) {
    return function() {
      for (var i = [], o = 0; o < arguments.length; o++)
        i[o] = arguments[o];
      try {
        var c = a.apply(void 0, Yt([], jr(i), !1));
        return ge(c);
      } catch (u) {
        return vt(s ? s(u) : u);
      }
    };
  }
  e.fromThrowable = t;
  function n(a) {
    return Eu(a);
  }
  e.combine = n;
  function r(a) {
    return Cu(a);
  }
  e.combineWithAllErrors = r;
})(ps || (ps = {}));
var ge = function(e) {
  return new Pt(e);
}, vt = function(e) {
  return new Gt(e);
}, Pt = (
  /** @class */
  function() {
    function e(t) {
      this.value = t;
    }
    return e.prototype.isOk = function() {
      return !0;
    }, e.prototype.isErr = function() {
      return !this.isOk();
    }, e.prototype.map = function(t) {
      return ge(t(this.value));
    }, e.prototype.mapErr = function(t) {
      return ge(this.value);
    }, e.prototype.andThen = function(t) {
      return t(this.value);
    }, e.prototype.orElse = function(t) {
      return ge(this.value);
    }, e.prototype.asyncAndThen = function(t) {
      return t(this.value);
    }, e.prototype.asyncMap = function(t) {
      return fe.fromSafePromise(t(this.value));
    }, e.prototype.unwrapOr = function(t) {
      return this.value;
    }, e.prototype.match = function(t, n) {
      return t(this.value);
    }, e.prototype._unsafeUnwrap = function(t) {
      return this.value;
    }, e.prototype._unsafeUnwrapErr = function(t) {
      throw Ou("Called `_unsafeUnwrapErr` on an Ok", this, t);
    }, e;
  }()
), Gt = (
  /** @class */
  function() {
    function e(t) {
      this.error = t;
    }
    return e.prototype.isOk = function() {
      return !1;
    }, e.prototype.isErr = function() {
      return !this.isOk();
    }, e.prototype.map = function(t) {
      return vt(this.error);
    }, e.prototype.mapErr = function(t) {
      return vt(t(this.error));
    }, e.prototype.andThen = function(t) {
      return vt(this.error);
    }, e.prototype.orElse = function(t) {
      return t(this.error);
    }, e.prototype.asyncAndThen = function(t) {
      return eo(this.error);
    }, e.prototype.asyncMap = function(t) {
      return eo(this.error);
    }, e.prototype.unwrapOr = function(t) {
      return t;
    }, e.prototype.match = function(t, n) {
      return n(this.error);
    }, e.prototype._unsafeUnwrap = function(t) {
      throw Ou("Called `_unsafeUnwrap` on an Err", this, t);
    }, e.prototype._unsafeUnwrapErr = function(t) {
      return this.error;
    }, e;
  }()
);
ps.fromThrowable;
var Au = Symbol.for("immer-nothing"), to = Symbol.for("immer-draftable"), Ne = Symbol.for("immer-state"), lp = process.env.NODE_ENV !== "production" ? [
  // All error codes, starting by 0:
  function(e) {
    return `The plugin for '${e}' has not been loaded into Immer. To enable the plugin, import and call \`enable${e}()\` when initializing your application.`;
  },
  function(e) {
    return `produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '${e}'`;
  },
  "This object has been frozen and should not be mutated",
  function(e) {
    return "Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? " + e;
  },
  "An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.",
  "Immer forbids circular references",
  "The first or second argument to `produce` must be a function",
  "The third argument to `produce` must be a function or undefined",
  "First argument to `createDraft` must be a plain object, an array, or an immerable object",
  "First argument to `finishDraft` must be a draft returned by `createDraft`",
  function(e) {
    return `'current' expects a draft, got: ${e}`;
  },
  "Object.defineProperty() cannot be used on an Immer draft",
  "Object.setPrototypeOf() cannot be used on an Immer draft",
  "Immer only supports deleting array indices",
  "Immer only supports setting array indices and the 'length' property",
  function(e) {
    return `'original' expects a draft, got: ${e}`;
  }
  // Note: if more errors are added, the errorOffset in Patches.ts should be increased
  // See Patches.ts for additional errors
] : [];
function Pe(e, ...t) {
  if (process.env.NODE_ENV !== "production") {
    const n = lp[e], r = typeof n == "function" ? n.apply(null, t) : n;
    throw new Error(`[Immer] ${r}`);
  }
  throw new Error(
    `[Immer] minified error nr: ${e}. Full error at: https://bit.ly/3cXEKWf`
  );
}
var En = Object.getPrototypeOf;
function Cn(e) {
  return !!e && !!e[Ne];
}
function nn(e) {
  var t;
  return e ? Iu(e) || Array.isArray(e) || !!e[to] || !!((t = e.constructor) != null && t[to]) || Gr(e) || Hr(e) : !1;
}
var dp = Object.prototype.constructor.toString();
function Iu(e) {
  if (!e || typeof e != "object")
    return !1;
  const t = En(e);
  if (t === null)
    return !0;
  const n = Object.hasOwnProperty.call(t, "constructor") && t.constructor;
  return n === Object ? !0 : typeof n == "function" && Function.toString.call(n) === dp;
}
function Vn(e, t) {
  Kr(e) === 0 ? Object.entries(e).forEach(([n, r]) => {
    t(n, r, e);
  }) : e.forEach((n, r) => t(r, n, e));
}
function Kr(e) {
  const t = e[Ne];
  return t ? t.type_ : Array.isArray(e) ? 1 : Gr(e) ? 2 : Hr(e) ? 3 : 0;
}
function ms(e, t) {
  return Kr(e) === 2 ? e.has(t) : Object.prototype.hasOwnProperty.call(e, t);
}
function Ru(e, t, n) {
  const r = Kr(e);
  r === 2 ? e.set(t, n) : r === 3 ? e.add(n) : e[t] = n;
}
function fp(e, t) {
  return e === t ? e !== 0 || 1 / e === 1 / t : e !== e && t !== t;
}
function Gr(e) {
  return e instanceof Map;
}
function Hr(e) {
  return e instanceof Set;
}
function Vt(e) {
  return e.copy_ || e.base_;
}
function ys(e, t) {
  if (Gr(e))
    return new Map(e);
  if (Hr(e))
    return new Set(e);
  if (Array.isArray(e))
    return Array.prototype.slice.call(e);
  if (!t && Iu(e))
    return En(e) ? { ...e } : Object.assign(/* @__PURE__ */ Object.create(null), e);
  const n = Object.getOwnPropertyDescriptors(e);
  delete n[Ne];
  let r = Reflect.ownKeys(n);
  for (let a = 0; a < r.length; a++) {
    const s = r[a], i = n[s];
    i.writable === !1 && (i.writable = !0, i.configurable = !0), (i.get || i.set) && (n[s] = {
      configurable: !0,
      writable: !0,
      // could live with !!desc.set as well here...
      enumerable: i.enumerable,
      value: e[s]
    });
  }
  return Object.create(En(e), n);
}
function $s(e, t = !1) {
  return Jr(e) || Cn(e) || !nn(e) || (Kr(e) > 1 && (e.set = e.add = e.clear = e.delete = hp), Object.freeze(e), t && Vn(e, (n, r) => $s(r, !0))), e;
}
function hp() {
  Pe(2);
}
function Jr(e) {
  return Object.isFrozen(e);
}
var pp = {};
function rn(e) {
  const t = pp[e];
  return t || Pe(0, e), t;
}
var Wn;
function Nu() {
  return Wn;
}
function mp(e, t) {
  return {
    drafts_: [],
    parent_: e,
    immer_: t,
    // Whenever the modified draft contains a draft from another scope, we
    // need to prevent auto-freezing so the unowned draft can be finalized.
    canAutoFreeze_: !0,
    unfinalizedDrafts_: 0
  };
}
function no(e, t) {
  t && (rn("Patches"), e.patches_ = [], e.inversePatches_ = [], e.patchListener_ = t);
}
function vs(e) {
  gs(e), e.drafts_.forEach(yp), e.drafts_ = null;
}
function gs(e) {
  e === Wn && (Wn = e.parent_);
}
function ro(e) {
  return Wn = mp(Wn, e);
}
function yp(e) {
  const t = e[Ne];
  t.type_ === 0 || t.type_ === 1 ? t.revoke_() : t.revoked_ = !0;
}
function ao(e, t) {
  t.unfinalizedDrafts_ = t.drafts_.length;
  const n = t.drafts_[0];
  return e !== void 0 && e !== n ? (n[Ne].modified_ && (vs(t), Pe(4)), nn(e) && (e = qr(t, e), t.parent_ || $r(t, e)), t.patches_ && rn("Patches").generateReplacementPatches_(
    n[Ne].base_,
    e,
    t.patches_,
    t.inversePatches_
  )) : e = qr(t, n, []), vs(t), t.patches_ && t.patchListener_(t.patches_, t.inversePatches_), e !== Au ? e : void 0;
}
function qr(e, t, n) {
  if (Jr(t))
    return t;
  const r = t[Ne];
  if (!r)
    return Vn(
      t,
      (a, s) => so(e, r, t, a, s, n)
    ), t;
  if (r.scope_ !== e)
    return t;
  if (!r.modified_)
    return $r(e, r.base_, !0), r.base_;
  if (!r.finalized_) {
    r.finalized_ = !0, r.scope_.unfinalizedDrafts_--;
    const a = r.copy_;
    let s = a, i = !1;
    r.type_ === 3 && (s = new Set(a), a.clear(), i = !0), Vn(
      s,
      (o, c) => so(e, r, a, o, c, n, i)
    ), $r(e, a, !1), n && e.patches_ && rn("Patches").generatePatches_(
      r,
      n,
      e.patches_,
      e.inversePatches_
    );
  }
  return r.copy_;
}
function so(e, t, n, r, a, s, i) {
  if (process.env.NODE_ENV !== "production" && a === n && Pe(5), Cn(a)) {
    const o = s && t && t.type_ !== 3 && // Set objects are atomic since they have no keys.
    !ms(t.assigned_, r) ? s.concat(r) : void 0, c = qr(e, a, o);
    if (Ru(n, r, c), Cn(c))
      e.canAutoFreeze_ = !1;
    else
      return;
  } else
    i && n.add(a);
  if (nn(a) && !Jr(a)) {
    if (!e.immer_.autoFreeze_ && e.unfinalizedDrafts_ < 1)
      return;
    qr(e, a), (!t || !t.scope_.parent_) && $r(e, a);
  }
}
function $r(e, t, n = !1) {
  !e.parent_ && e.immer_.autoFreeze_ && e.canAutoFreeze_ && $s(t, n);
}
function vp(e, t) {
  const n = Array.isArray(e), r = {
    type_: n ? 1 : 0,
    // Track which produce call this is associated with.
    scope_: t ? t.scope_ : Nu(),
    // True for both shallow and deep changes.
    modified_: !1,
    // Used during finalization.
    finalized_: !1,
    // Track which properties have been assigned (true) or deleted (false).
    assigned_: {},
    // The parent draft state.
    parent_: t,
    // The base state.
    base_: e,
    // The base proxy.
    draft_: null,
    // set below
    // The base copy with any updated values.
    copy_: null,
    // Called by the `produce` function.
    revoke_: null,
    isManual_: !1
  };
  let a = r, s = Ls;
  n && (a = [r], s = Bn);
  const { revoke: i, proxy: o } = Proxy.revocable(a, s);
  return r.draft_ = o, r.revoke_ = i, o;
}
var Ls = {
  get(e, t) {
    if (t === Ne)
      return e;
    const n = Vt(e);
    if (!ms(n, t))
      return gp(e, n, t);
    const r = n[t];
    return e.finalized_ || !nn(r) ? r : r === xa(e.base_, t) ? (ka(e), e.copy_[t] = bs(r, e)) : r;
  },
  has(e, t) {
    return t in Vt(e);
  },
  ownKeys(e) {
    return Reflect.ownKeys(Vt(e));
  },
  set(e, t, n) {
    const r = Du(Vt(e), t);
    if (r != null && r.set)
      return r.set.call(e.draft_, n), !0;
    if (!e.modified_) {
      const a = xa(Vt(e), t), s = a == null ? void 0 : a[Ne];
      if (s && s.base_ === n)
        return e.copy_[t] = n, e.assigned_[t] = !1, !0;
      if (fp(n, a) && (n !== void 0 || ms(e.base_, t)))
        return !0;
      ka(e), _s(e);
    }
    return e.copy_[t] === n && // special case: handle new props with value 'undefined'
    (n !== void 0 || t in e.copy_) || // special case: NaN
    Number.isNaN(n) && Number.isNaN(e.copy_[t]) || (e.copy_[t] = n, e.assigned_[t] = !0), !0;
  },
  deleteProperty(e, t) {
    return xa(e.base_, t) !== void 0 || t in e.base_ ? (e.assigned_[t] = !1, ka(e), _s(e)) : delete e.assigned_[t], e.copy_ && delete e.copy_[t], !0;
  },
  // Note: We never coerce `desc.value` into an Immer draft, because we can't make
  // the same guarantee in ES5 mode.
  getOwnPropertyDescriptor(e, t) {
    const n = Vt(e), r = Reflect.getOwnPropertyDescriptor(n, t);
    return r && {
      writable: !0,
      configurable: e.type_ !== 1 || t !== "length",
      enumerable: r.enumerable,
      value: n[t]
    };
  },
  defineProperty() {
    Pe(11);
  },
  getPrototypeOf(e) {
    return En(e.base_);
  },
  setPrototypeOf() {
    Pe(12);
  }
}, Bn = {};
Vn(Ls, (e, t) => {
  Bn[e] = function() {
    return arguments[0] = arguments[0][0], t.apply(this, arguments);
  };
});
Bn.deleteProperty = function(e, t) {
  return process.env.NODE_ENV !== "production" && isNaN(parseInt(t)) && Pe(13), Bn.set.call(this, e, t, void 0);
};
Bn.set = function(e, t, n) {
  return process.env.NODE_ENV !== "production" && t !== "length" && isNaN(parseInt(t)) && Pe(14), Ls.set.call(this, e[0], t, n, e[0]);
};
function xa(e, t) {
  const n = e[Ne];
  return (n ? Vt(n) : e)[t];
}
function gp(e, t, n) {
  var a;
  const r = Du(t, n);
  return r ? "value" in r ? r.value : (
    // This is a very special case, if the prop is a getter defined by the
    // prototype, we should invoke it with the draft as context!
    (a = r.get) == null ? void 0 : a.call(e.draft_)
  ) : void 0;
}
function Du(e, t) {
  if (!(t in e))
    return;
  let n = En(e);
  for (; n; ) {
    const r = Object.getOwnPropertyDescriptor(n, t);
    if (r)
      return r;
    n = En(n);
  }
}
function _s(e) {
  e.modified_ || (e.modified_ = !0, e.parent_ && _s(e.parent_));
}
function ka(e) {
  e.copy_ || (e.copy_ = ys(
    e.base_,
    e.scope_.immer_.useStrictShallowCopy_
  ));
}
var _p = class {
  constructor(e) {
    this.autoFreeze_ = !0, this.useStrictShallowCopy_ = !1, this.produce = (t, n, r) => {
      if (typeof t == "function" && typeof n != "function") {
        const s = n;
        n = t;
        const i = this;
        return function(c = s, ...u) {
          return i.produce(c, (d) => n.call(this, d, ...u));
        };
      }
      typeof n != "function" && Pe(6), r !== void 0 && typeof r != "function" && Pe(7);
      let a;
      if (nn(t)) {
        const s = ro(this), i = bs(t, void 0);
        let o = !0;
        try {
          a = n(i), o = !1;
        } finally {
          o ? vs(s) : gs(s);
        }
        return no(s, r), ao(a, s);
      } else if (!t || typeof t != "object") {
        if (a = n(t), a === void 0 && (a = t), a === Au && (a = void 0), this.autoFreeze_ && $s(a, !0), r) {
          const s = [], i = [];
          rn("Patches").generateReplacementPatches_(t, a, s, i), r(s, i);
        }
        return a;
      } else
        Pe(1, t);
    }, this.produceWithPatches = (t, n) => {
      if (typeof t == "function")
        return (i, ...o) => this.produceWithPatches(i, (c) => t(c, ...o));
      let r, a;
      return [this.produce(t, n, (i, o) => {
        r = i, a = o;
      }), r, a];
    }, typeof (e == null ? void 0 : e.autoFreeze) == "boolean" && this.setAutoFreeze(e.autoFreeze), typeof (e == null ? void 0 : e.useStrictShallowCopy) == "boolean" && this.setUseStrictShallowCopy(e.useStrictShallowCopy);
  }
  createDraft(e) {
    nn(e) || Pe(8), Cn(e) && (e = bp(e));
    const t = ro(this), n = bs(e, void 0);
    return n[Ne].isManual_ = !0, gs(t), n;
  }
  finishDraft(e, t) {
    const n = e && e[Ne];
    (!n || !n.isManual_) && Pe(9);
    const { scope_: r } = n;
    return no(r, t), ao(void 0, r);
  }
  /**
   * Pass true to automatically freeze all copies created by Immer.
   *
   * By default, auto-freezing is enabled.
   */
  setAutoFreeze(e) {
    this.autoFreeze_ = e;
  }
  /**
   * Pass true to enable strict shallow copy.
   *
   * By default, immer does not copy the object descriptors such as getter, setter and non-enumrable properties.
   */
  setUseStrictShallowCopy(e) {
    this.useStrictShallowCopy_ = e;
  }
  applyPatches(e, t) {
    let n;
    for (n = t.length - 1; n >= 0; n--) {
      const a = t[n];
      if (a.path.length === 0 && a.op === "replace") {
        e = a.value;
        break;
      }
    }
    n > -1 && (t = t.slice(n + 1));
    const r = rn("Patches").applyPatches_;
    return Cn(e) ? r(e, t) : this.produce(
      e,
      (a) => r(a, t)
    );
  }
};
function bs(e, t) {
  const n = Gr(e) ? rn("MapSet").proxyMap_(e, t) : Hr(e) ? rn("MapSet").proxySet_(e, t) : vp(e, t);
  return (t ? t.scope_ : Nu()).drafts_.push(n), n;
}
function bp(e) {
  return Cn(e) || Pe(10, e), ju(e);
}
function ju(e) {
  if (!nn(e) || Jr(e))
    return e;
  const t = e[Ne];
  let n;
  if (t) {
    if (!t.modified_)
      return t.base_;
    t.finalized_ = !0, n = ys(e, t.scope_.immer_.useStrictShallowCopy_);
  } else
    n = ys(e, !0);
  return Vn(n, (r, a) => {
    Ru(n, r, ju(a));
  }), t && (t.finalized_ = !1), n;
}
var De = new _p(), ie = De.produce;
De.produceWithPatches.bind(
  De
);
De.setAutoFreeze.bind(De);
De.setUseStrictShallowCopy.bind(De);
De.applyPatches.bind(De);
De.createDraft.bind(De);
De.finishDraft.bind(De);
var cr = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function wp(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var Lr = { exports: {} };
Lr.exports;
(function(e, t) {
  var n = 200, r = "__lodash_hash_undefined__", a = 1, s = 2, i = 9007199254740991, o = "[object Arguments]", c = "[object Array]", u = "[object AsyncFunction]", d = "[object Boolean]", h = "[object Date]", p = "[object Error]", v = "[object Function]", T = "[object GeneratorFunction]", g = "[object Map]", D = "[object Number]", j = "[object Null]", I = "[object Object]", b = "[object Promise]", R = "[object Proxy]", Q = "[object RegExp]", $ = "[object Set]", A = "[object String]", te = "[object Symbol]", qe = "[object Undefined]", K = "[object WeakMap]", le = "[object ArrayBuffer]", he = "[object DataView]", L = "[object Float32Array]", Be = "[object Float64Array]", Jn = "[object Int8Array]", Xr = "[object Int16Array]", Qr = "[object Int32Array]", ea = "[object Uint8Array]", Xu = "[object Uint8ClampedArray]", Qu = "[object Uint16Array]", ec = "[object Uint32Array]", tc = /[\\^$.*+?()[\]{}|]/g, nc = /^\[object .+?Constructor\]$/, rc = /^(?:0|[1-9]\d*)$/, ne = {};
  ne[L] = ne[Be] = ne[Jn] = ne[Xr] = ne[Qr] = ne[ea] = ne[Xu] = ne[Qu] = ne[ec] = !0, ne[o] = ne[c] = ne[le] = ne[d] = ne[he] = ne[h] = ne[p] = ne[v] = ne[g] = ne[D] = ne[I] = ne[Q] = ne[$] = ne[A] = ne[K] = !1;
  var zs = typeof cr == "object" && cr && cr.Object === Object && cr, ac = typeof self == "object" && self && self.Object === Object && self, lt = zs || ac || Function("return this")(), Us = t && !t.nodeType && t, Vs = Us && !0 && e && !e.nodeType && e, Ws = Vs && Vs.exports === Us, ta = Ws && zs.process, Bs = function() {
    try {
      return ta && ta.binding && ta.binding("util");
    } catch {
    }
  }(), Ks = Bs && Bs.isTypedArray;
  function sc(l, f) {
    for (var m = -1, k = l == null ? 0 : l.length, re = 0, Z = []; ++m < k; ) {
      var oe = l[m];
      f(oe, m, l) && (Z[re++] = oe);
    }
    return Z;
  }
  function ic(l, f) {
    for (var m = -1, k = f.length, re = l.length; ++m < k; )
      l[re + m] = f[m];
    return l;
  }
  function oc(l, f) {
    for (var m = -1, k = l == null ? 0 : l.length; ++m < k; )
      if (f(l[m], m, l))
        return !0;
    return !1;
  }
  function uc(l, f) {
    for (var m = -1, k = Array(l); ++m < l; )
      k[m] = f(m);
    return k;
  }
  function cc(l) {
    return function(f) {
      return l(f);
    };
  }
  function lc(l, f) {
    return l.has(f);
  }
  function dc(l, f) {
    return l == null ? void 0 : l[f];
  }
  function fc(l) {
    var f = -1, m = Array(l.size);
    return l.forEach(function(k, re) {
      m[++f] = [re, k];
    }), m;
  }
  function hc(l, f) {
    return function(m) {
      return l(f(m));
    };
  }
  function pc(l) {
    var f = -1, m = Array(l.size);
    return l.forEach(function(k) {
      m[++f] = k;
    }), m;
  }
  var mc = Array.prototype, yc = Function.prototype, Yn = Object.prototype, na = lt["__core-js_shared__"], Gs = yc.toString, He = Yn.hasOwnProperty, Hs = function() {
    var l = /[^.]+$/.exec(na && na.keys && na.keys.IE_PROTO || "");
    return l ? "Symbol(src)_1." + l : "";
  }(), Js = Yn.toString, vc = RegExp(
    "^" + Gs.call(He).replace(tc, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
  ), Ys = Ws ? lt.Buffer : void 0, Xn = lt.Symbol, Xs = lt.Uint8Array, Qs = Yn.propertyIsEnumerable, gc = mc.splice, Dt = Xn ? Xn.toStringTag : void 0, ei = Object.getOwnPropertySymbols, _c = Ys ? Ys.isBuffer : void 0, bc = hc(Object.keys, Object), ra = on(lt, "DataView"), In = on(lt, "Map"), aa = on(lt, "Promise"), sa = on(lt, "Set"), ia = on(lt, "WeakMap"), Rn = on(Object, "create"), wc = $t(ra), xc = $t(In), kc = $t(aa), Sc = $t(sa), Tc = $t(ia), ti = Xn ? Xn.prototype : void 0, oa = ti ? ti.valueOf : void 0;
  function jt(l) {
    var f = -1, m = l == null ? 0 : l.length;
    for (this.clear(); ++f < m; ) {
      var k = l[f];
      this.set(k[0], k[1]);
    }
  }
  function Pc() {
    this.__data__ = Rn ? Rn(null) : {}, this.size = 0;
  }
  function Oc(l) {
    var f = this.has(l) && delete this.__data__[l];
    return this.size -= f ? 1 : 0, f;
  }
  function Ec(l) {
    var f = this.__data__;
    if (Rn) {
      var m = f[l];
      return m === r ? void 0 : m;
    }
    return He.call(f, l) ? f[l] : void 0;
  }
  function Cc(l) {
    var f = this.__data__;
    return Rn ? f[l] !== void 0 : He.call(f, l);
  }
  function Ac(l, f) {
    var m = this.__data__;
    return this.size += this.has(l) ? 0 : 1, m[l] = Rn && f === void 0 ? r : f, this;
  }
  jt.prototype.clear = Pc, jt.prototype.delete = Oc, jt.prototype.get = Ec, jt.prototype.has = Cc, jt.prototype.set = Ac;
  function dt(l) {
    var f = -1, m = l == null ? 0 : l.length;
    for (this.clear(); ++f < m; ) {
      var k = l[f];
      this.set(k[0], k[1]);
    }
  }
  function Ic() {
    this.__data__ = [], this.size = 0;
  }
  function Rc(l) {
    var f = this.__data__, m = er(f, l);
    if (m < 0)
      return !1;
    var k = f.length - 1;
    return m == k ? f.pop() : gc.call(f, m, 1), --this.size, !0;
  }
  function Nc(l) {
    var f = this.__data__, m = er(f, l);
    return m < 0 ? void 0 : f[m][1];
  }
  function Dc(l) {
    return er(this.__data__, l) > -1;
  }
  function jc(l, f) {
    var m = this.__data__, k = er(m, l);
    return k < 0 ? (++this.size, m.push([l, f])) : m[k][1] = f, this;
  }
  dt.prototype.clear = Ic, dt.prototype.delete = Rc, dt.prototype.get = Nc, dt.prototype.has = Dc, dt.prototype.set = jc;
  function qt(l) {
    var f = -1, m = l == null ? 0 : l.length;
    for (this.clear(); ++f < m; ) {
      var k = l[f];
      this.set(k[0], k[1]);
    }
  }
  function qc() {
    this.size = 0, this.__data__ = {
      hash: new jt(),
      map: new (In || dt)(),
      string: new jt()
    };
  }
  function $c(l) {
    var f = tr(this, l).delete(l);
    return this.size -= f ? 1 : 0, f;
  }
  function Lc(l) {
    return tr(this, l).get(l);
  }
  function Mc(l) {
    return tr(this, l).has(l);
  }
  function Zc(l, f) {
    var m = tr(this, l), k = m.size;
    return m.set(l, f), this.size += m.size == k ? 0 : 1, this;
  }
  qt.prototype.clear = qc, qt.prototype.delete = $c, qt.prototype.get = Lc, qt.prototype.has = Mc, qt.prototype.set = Zc;
  function Qn(l) {
    var f = -1, m = l == null ? 0 : l.length;
    for (this.__data__ = new qt(); ++f < m; )
      this.add(l[f]);
  }
  function Fc(l) {
    return this.__data__.set(l, r), this;
  }
  function zc(l) {
    return this.__data__.has(l);
  }
  Qn.prototype.add = Qn.prototype.push = Fc, Qn.prototype.has = zc;
  function kt(l) {
    var f = this.__data__ = new dt(l);
    this.size = f.size;
  }
  function Uc() {
    this.__data__ = new dt(), this.size = 0;
  }
  function Vc(l) {
    var f = this.__data__, m = f.delete(l);
    return this.size = f.size, m;
  }
  function Wc(l) {
    return this.__data__.get(l);
  }
  function Bc(l) {
    return this.__data__.has(l);
  }
  function Kc(l, f) {
    var m = this.__data__;
    if (m instanceof dt) {
      var k = m.__data__;
      if (!In || k.length < n - 1)
        return k.push([l, f]), this.size = ++m.size, this;
      m = this.__data__ = new qt(k);
    }
    return m.set(l, f), this.size = m.size, this;
  }
  kt.prototype.clear = Uc, kt.prototype.delete = Vc, kt.prototype.get = Wc, kt.prototype.has = Bc, kt.prototype.set = Kc;
  function Gc(l, f) {
    var m = nr(l), k = !m && cl(l), re = !m && !k && ua(l), Z = !m && !k && !re && li(l), oe = m || k || re || Z, pe = oe ? uc(l.length, String) : [], ye = pe.length;
    for (var ae in l)
      (f || He.call(l, ae)) && !(oe && // Safari 9 has enumerable `arguments.length` in strict mode.
      (ae == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
      re && (ae == "offset" || ae == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
      Z && (ae == "buffer" || ae == "byteLength" || ae == "byteOffset") || // Skip index properties.
      al(ae, ye))) && pe.push(ae);
    return pe;
  }
  function er(l, f) {
    for (var m = l.length; m--; )
      if (ii(l[m][0], f))
        return m;
    return -1;
  }
  function Hc(l, f, m) {
    var k = f(l);
    return nr(l) ? k : ic(k, m(l));
  }
  function Nn(l) {
    return l == null ? l === void 0 ? qe : j : Dt && Dt in Object(l) ? nl(l) : ul(l);
  }
  function ni(l) {
    return Dn(l) && Nn(l) == o;
  }
  function ri(l, f, m, k, re) {
    return l === f ? !0 : l == null || f == null || !Dn(l) && !Dn(f) ? l !== l && f !== f : Jc(l, f, m, k, ri, re);
  }
  function Jc(l, f, m, k, re, Z) {
    var oe = nr(l), pe = nr(f), ye = oe ? c : St(l), ae = pe ? c : St(f);
    ye = ye == o ? I : ye, ae = ae == o ? I : ae;
    var Ae = ye == I, Ke = ae == I, ve = ye == ae;
    if (ve && ua(l)) {
      if (!ua(f))
        return !1;
      oe = !0, Ae = !1;
    }
    if (ve && !Ae)
      return Z || (Z = new kt()), oe || li(l) ? ai(l, f, m, k, re, Z) : el(l, f, ye, m, k, re, Z);
    if (!(m & a)) {
      var $e = Ae && He.call(l, "__wrapped__"), Le = Ke && He.call(f, "__wrapped__");
      if ($e || Le) {
        var Tt = $e ? l.value() : l, ft = Le ? f.value() : f;
        return Z || (Z = new kt()), re(Tt, ft, m, k, Z);
      }
    }
    return ve ? (Z || (Z = new kt()), tl(l, f, m, k, re, Z)) : !1;
  }
  function Yc(l) {
    if (!ci(l) || il(l))
      return !1;
    var f = oi(l) ? vc : nc;
    return f.test($t(l));
  }
  function Xc(l) {
    return Dn(l) && ui(l.length) && !!ne[Nn(l)];
  }
  function Qc(l) {
    if (!ol(l))
      return bc(l);
    var f = [];
    for (var m in Object(l))
      He.call(l, m) && m != "constructor" && f.push(m);
    return f;
  }
  function ai(l, f, m, k, re, Z) {
    var oe = m & a, pe = l.length, ye = f.length;
    if (pe != ye && !(oe && ye > pe))
      return !1;
    var ae = Z.get(l);
    if (ae && Z.get(f))
      return ae == f;
    var Ae = -1, Ke = !0, ve = m & s ? new Qn() : void 0;
    for (Z.set(l, f), Z.set(f, l); ++Ae < pe; ) {
      var $e = l[Ae], Le = f[Ae];
      if (k)
        var Tt = oe ? k(Le, $e, Ae, f, l, Z) : k($e, Le, Ae, l, f, Z);
      if (Tt !== void 0) {
        if (Tt)
          continue;
        Ke = !1;
        break;
      }
      if (ve) {
        if (!oc(f, function(ft, Lt) {
          if (!lc(ve, Lt) && ($e === ft || re($e, ft, m, k, Z)))
            return ve.push(Lt);
        })) {
          Ke = !1;
          break;
        }
      } else if (!($e === Le || re($e, Le, m, k, Z))) {
        Ke = !1;
        break;
      }
    }
    return Z.delete(l), Z.delete(f), Ke;
  }
  function el(l, f, m, k, re, Z, oe) {
    switch (m) {
      case he:
        if (l.byteLength != f.byteLength || l.byteOffset != f.byteOffset)
          return !1;
        l = l.buffer, f = f.buffer;
      case le:
        return !(l.byteLength != f.byteLength || !Z(new Xs(l), new Xs(f)));
      case d:
      case h:
      case D:
        return ii(+l, +f);
      case p:
        return l.name == f.name && l.message == f.message;
      case Q:
      case A:
        return l == f + "";
      case g:
        var pe = fc;
      case $:
        var ye = k & a;
        if (pe || (pe = pc), l.size != f.size && !ye)
          return !1;
        var ae = oe.get(l);
        if (ae)
          return ae == f;
        k |= s, oe.set(l, f);
        var Ae = ai(pe(l), pe(f), k, re, Z, oe);
        return oe.delete(l), Ae;
      case te:
        if (oa)
          return oa.call(l) == oa.call(f);
    }
    return !1;
  }
  function tl(l, f, m, k, re, Z) {
    var oe = m & a, pe = si(l), ye = pe.length, ae = si(f), Ae = ae.length;
    if (ye != Ae && !oe)
      return !1;
    for (var Ke = ye; Ke--; ) {
      var ve = pe[Ke];
      if (!(oe ? ve in f : He.call(f, ve)))
        return !1;
    }
    var $e = Z.get(l);
    if ($e && Z.get(f))
      return $e == f;
    var Le = !0;
    Z.set(l, f), Z.set(f, l);
    for (var Tt = oe; ++Ke < ye; ) {
      ve = pe[Ke];
      var ft = l[ve], Lt = f[ve];
      if (k)
        var di = oe ? k(Lt, ft, ve, f, l, Z) : k(ft, Lt, ve, l, f, Z);
      if (!(di === void 0 ? ft === Lt || re(ft, Lt, m, k, Z) : di)) {
        Le = !1;
        break;
      }
      Tt || (Tt = ve == "constructor");
    }
    if (Le && !Tt) {
      var rr = l.constructor, ar = f.constructor;
      rr != ar && "constructor" in l && "constructor" in f && !(typeof rr == "function" && rr instanceof rr && typeof ar == "function" && ar instanceof ar) && (Le = !1);
    }
    return Z.delete(l), Z.delete(f), Le;
  }
  function si(l) {
    return Hc(l, fl, rl);
  }
  function tr(l, f) {
    var m = l.__data__;
    return sl(f) ? m[typeof f == "string" ? "string" : "hash"] : m.map;
  }
  function on(l, f) {
    var m = dc(l, f);
    return Yc(m) ? m : void 0;
  }
  function nl(l) {
    var f = He.call(l, Dt), m = l[Dt];
    try {
      l[Dt] = void 0;
      var k = !0;
    } catch {
    }
    var re = Js.call(l);
    return k && (f ? l[Dt] = m : delete l[Dt]), re;
  }
  var rl = ei ? function(l) {
    return l == null ? [] : (l = Object(l), sc(ei(l), function(f) {
      return Qs.call(l, f);
    }));
  } : hl, St = Nn;
  (ra && St(new ra(new ArrayBuffer(1))) != he || In && St(new In()) != g || aa && St(aa.resolve()) != b || sa && St(new sa()) != $ || ia && St(new ia()) != K) && (St = function(l) {
    var f = Nn(l), m = f == I ? l.constructor : void 0, k = m ? $t(m) : "";
    if (k)
      switch (k) {
        case wc:
          return he;
        case xc:
          return g;
        case kc:
          return b;
        case Sc:
          return $;
        case Tc:
          return K;
      }
    return f;
  });
  function al(l, f) {
    return f = f ?? i, !!f && (typeof l == "number" || rc.test(l)) && l > -1 && l % 1 == 0 && l < f;
  }
  function sl(l) {
    var f = typeof l;
    return f == "string" || f == "number" || f == "symbol" || f == "boolean" ? l !== "__proto__" : l === null;
  }
  function il(l) {
    return !!Hs && Hs in l;
  }
  function ol(l) {
    var f = l && l.constructor, m = typeof f == "function" && f.prototype || Yn;
    return l === m;
  }
  function ul(l) {
    return Js.call(l);
  }
  function $t(l) {
    if (l != null) {
      try {
        return Gs.call(l);
      } catch {
      }
      try {
        return l + "";
      } catch {
      }
    }
    return "";
  }
  function ii(l, f) {
    return l === f || l !== l && f !== f;
  }
  var cl = ni(function() {
    return arguments;
  }()) ? ni : function(l) {
    return Dn(l) && He.call(l, "callee") && !Qs.call(l, "callee");
  }, nr = Array.isArray;
  function ll(l) {
    return l != null && ui(l.length) && !oi(l);
  }
  var ua = _c || pl;
  function dl(l, f) {
    return ri(l, f);
  }
  function oi(l) {
    if (!ci(l))
      return !1;
    var f = Nn(l);
    return f == v || f == T || f == u || f == R;
  }
  function ui(l) {
    return typeof l == "number" && l > -1 && l % 1 == 0 && l <= i;
  }
  function ci(l) {
    var f = typeof l;
    return l != null && (f == "object" || f == "function");
  }
  function Dn(l) {
    return l != null && typeof l == "object";
  }
  var li = Ks ? cc(Ks) : Xc;
  function fl(l) {
    return ll(l) ? Gc(l) : Qc(l);
  }
  function hl() {
    return [];
  }
  function pl() {
    return !1;
  }
  e.exports = dl;
})(Lr, Lr.exports);
var xp = Lr.exports;
const ws = /* @__PURE__ */ wp(xp), kp = (e, t, n) => {
  const r = n.logger, a = n.subjects ?? sp(), s = new ut(), i = yi([
    a.walletData,
    a.sharedData,
    a.loggedInTimestamp
  ]).pipe(
    Qe(([v, T, g]) => ({
      walletData: v,
      sharedData: T,
      loggedInTimestamp: g
    }))
  ), o = () => t.getData(e).map((v) => (v && (r == null || r.debug("readFromStorage")), v)), c = (v) => t.setData(
    e,
    ie(v, (T) => {
      T.walletData.proofs = [];
    })
  ).map(() => {
    r == null || r.trace("writeToStorage", v);
  }), u = (v) => {
    const { walletData: T, sharedData: g, loggedInTimestamp: D } = v;
    T && !ws(a.walletData.value, T) && a.walletData.next(T), g && a.sharedData.next(g), D !== void 0 && a.loggedInTimestamp.next(D);
  }, d = () => {
    ws(a.walletData.value, hs) || a.walletData.next(hs), a.sharedData.next({}), a.loggedInTimestamp.next("");
  };
  (() => o().andThen((v) => fe.fromPromise(
    ap.parseAsync(v),
    (T) => T
  )).mapErr(() => {
    r == null || r.debug("loadedCorruptedStateFromStorage"), d();
  }).map((v) => {
    if (v)
      return r == null || r.debug("initializeStateFromStorage"), u(
        ie(v, (T) => (T.walletData.persona = T.walletData.persona ?? void 0, T))
      );
    r == null || r.debug("initializeStateFromDefault"), d();
  }))(), s.add(i.pipe(yt(c)).subscribe()), s.add(
    i.pipe(
      vd(1),
      No(),
      B(() => {
        a.initialized.next(!0);
      })
    ).subscribe()
  );
  const p = () => ({
    walletData: a.walletData.value,
    sharedData: a.sharedData.value,
    loggedInTimestamp: a.loggedInTimestamp.value
  });
  return {
    setState: u,
    getState: p,
    walletData$: yi([
      a.initialized,
      a.walletData
    ]).pipe(
      fd(1),
      _t(([v]) => v),
      Qe(() => a.walletData.value)
    ),
    getWalletData: () => a.walletData.value,
    state$: a.initialized.pipe(
      _t((v) => v),
      yt(() => i)
    ),
    patchState: (v) => {
      u({ ...p(), ...v });
    },
    reset: d,
    stateInitialized$: a.initialized.asObservable(),
    destroy: () => {
      d(), s.unsubscribe();
    }
  };
}, Sp = () => ({
  onConnect: new Ze(),
  onDisconnect: new Ze(),
  onUpdateSharedData: new Ze(),
  connected: new El(1),
  requestItems: new se([]),
  onCancelRequestItem: new Ze(),
  accounts: new se([]),
  onShowPopover: new Ze(),
  status: new se(
    "default"
  ),
  loggedInTimestamp: new se(""),
  isMobile: new se(!1),
  isWalletLinked: new se(!1),
  isExtensionAvailable: new se(!1),
  fullWidth: new se(!1),
  activeTab: new se("sharing"),
  mode: new se("light"),
  theme: new se("radix-blue"),
  avatarUrl: new se(""),
  personaLabel: new se(""),
  personaData: new se([]),
  dAppName: new se(""),
  onLinkClick: new Ze()
}), Tp = () => /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(
  globalThis.navigator ? globalThis.navigator.userAgent : ""
), Pp = (e) => {
  import("./connect-button-761ff8de.mjs");
  const t = e.subjects || Sp(), n = e.logger, r = (o) => {
    o();
  }, a = e.onConnect || r, s = () => document.querySelector("radix-connect-button"), i = new ut();
  return i.add(
    Je(document, "onRender").pipe(
      Qe(() => s()),
      _t((o) => !!o),
      yt((o) => {
        n == null || n.debug("connectButtonDiscovered");
        const c = Je(o, "onConnect").pipe(
          B(() => {
            a((L) => {
              !o.isWalletLinked || !o.isExtensionAvailable || t.onConnect.next(L);
            });
          })
        ), u = Je(
          o,
          "onDisconnect"
        ).pipe(
          B(() => {
            t.onDisconnect.next();
          })
        ), d = Je(o, "onLinkClick").pipe(
          B((L) => {
            t.onLinkClick.next(L.detail);
          })
        ), h = Je(o, "onDestroy").pipe(
          B(() => {
            n == null || n.debug("connectButtonRemovedFromDOM");
          })
        ), p = Je(
          o,
          "onCancelRequestItem"
        ).pipe(
          B((L) => {
            const Be = L.detail.id;
            n == null || n.debug("onCancelRequestItem", { id: Be }), t.onCancelRequestItem.next(Be);
          })
        ), v = Je(
          o,
          "onUpdateSharedData"
        ).pipe(
          B(() => {
            n == null || n.debug("onUpdateSharedData"), t.onUpdateSharedData.next();
          })
        ), T = Je(
          o,
          "onShowPopover"
        ).pipe(
          B(() => {
            t.onShowPopover.next();
          })
        ), g = t.status.pipe(
          B((L) => o.status = L)
        ), D = t.mode.pipe(
          B((L) => o.mode = L)
        ), j = t.connected.pipe(
          B((L) => {
            o.connected = L;
          })
        ), I = t.isMobile.pipe(
          B((L) => {
            o.isMobile = L;
          })
        ), b = t.isWalletLinked.pipe(
          B((L) => {
            o.isWalletLinked = L;
          })
        ), R = t.isExtensionAvailable.pipe(
          B((L) => {
            o.isExtensionAvailable = L;
          })
        ), Q = t.loggedInTimestamp.pipe(
          B((L) => {
            o.loggedInTimestamp = L;
          })
        ), $ = t.activeTab.pipe(
          B((L) => {
            o.activeTab = L;
          })
        ), A = t.requestItems.pipe(
          B((L) => {
            o.requestItems = L;
          })
        ), te = t.accounts.pipe(
          B((L) => {
            o.accounts = L;
          })
        ), qe = t.personaData.pipe(
          B((L) => {
            o.personaData = L;
          })
        ), K = t.personaLabel.pipe(
          B((L) => {
            o.personaLabel = L;
          })
        ), le = t.dAppName.pipe(
          B((L) => {
            o.dAppName = L;
          })
        ), he = t.theme.pipe(
          B((L) => {
            o.theme = L;
          })
        );
        return vr(
          c,
          g,
          he,
          D,
          j,
          A,
          Q,
          I,
          $,
          b,
          R,
          u,
          p,
          te,
          qe,
          K,
          h,
          v,
          T,
          le,
          d
        );
      })
    ).subscribe()
  ), {
    onConnect$: t.onConnect.asObservable(),
    onDisconnect$: t.onDisconnect.asObservable(),
    onShowPopover$: t.onShowPopover.asObservable(),
    onUpdateSharedData$: t.onUpdateSharedData.asObservable(),
    onCancelRequestItem$: t.onCancelRequestItem.asObservable(),
    onLinkClick$: t.onLinkClick.asObservable(),
    setStatus: (o) => t.status.next(o),
    setTheme: (o) => t.theme.next(o),
    setMode: (o) => t.mode.next(o),
    setActiveTab: (o) => t.activeTab.next(o),
    setIsMobile: (o) => t.isMobile.next(o),
    setIsWalletLinked: (o) => t.isWalletLinked.next(o),
    setIsExtensionAvailable: (o) => t.isExtensionAvailable.next(o),
    setLoggedInTimestamp: (o) => t.loggedInTimestamp.next(o),
    setConnected: (o) => t.connected.next(o),
    setRequestItems: (o) => t.requestItems.next(o),
    setAccounts: (o) => t.accounts.next(o),
    setPersonaData: (o) => t.personaData.next(o),
    setPersonaLabel: (o) => t.personaLabel.next(o),
    setDappName: (o) => t.dAppName.next(o),
    destroy: () => {
      i.unsubscribe();
    }
  };
}, Op = (e) => {
  const t = e.logger, n = e.requestItemClient, r = e.walletSdk, a = e.gatewayClient, s = (u) => {
    const d = new Ze();
    return {
      eventCallback: (h) => {
        d.next(h);
      },
      requestControl: ({ cancelRequest: h, getRequest: p }) => {
        Ca(
          d.pipe(
            _t((v) => v === "receivedByWallet"),
            Qe(() => p()),
            B((v) => {
              v.items.discriminator === "transaction" && n.patch(u, { showCancel: !1 });
            })
          )
        ), Ca(
          e.onCancelRequestItem$.pipe(
            _t((v) => v === u),
            yt(() => (n.cancel(u), n.updateStatus({
              id: u,
              status: "fail",
              error: "userCancelledRequest"
            }), h()))
          )
        );
      }
    };
  }, i = (u, d) => r.request(u, s(d)).map((h) => (t == null || t.debug("walletSuccessResponse", h), h)).mapErr((h) => (t == null || t.debug("walletErrorResponse", h), n.updateStatus({
    id: d,
    status: "fail",
    error: h.error
  }), h)), o = new ut();
  return {
    request: i,
    sendTransaction: (u) => {
      const { id: d } = n.add("sendTransaction");
      return r.sendTransaction(u, s(d)).mapErr((h) => (n.updateStatus({
        id: d,
        status: "fail",
        error: h.error
      }), t == null || t.debug("walletErrorResponse", h), h)).andThen(
        ({ transactionIntentHash: h }) => a.pollTransactionStatus(h).map((p) => ({
          transactionIntentHash: h,
          status: p.status
        }))
      ).map((h) => (n.updateStatus({
        id: d,
        status: "success",
        transactionIntentHash: h.transactionIntentHash
      }), t == null || t.debug("walletSuccessResponse", h), h));
    },
    extensionStatus$: r.extensionStatus$,
    requestItems$: n.items$,
    resetRequestItems: n.reset,
    destroy: () => {
      n.destroy(), r.destroy(), o.unsubscribe();
    }
  };
};
var Ep = Object.defineProperty, Cp = (e, t, n) => t in e ? Ep(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, Xe = (e, t, n) => (Cp(e, typeof t != "symbol" ? t + "" : t, n), n);
const Ap = "https://rcnet.radixdlt.com".replace(/\/+$/, "");
class qu {
  constructor(t = {}) {
    this.configuration = t;
  }
  set config(t) {
    this.configuration = t;
  }
  get basePath() {
    return this.configuration.basePath != null ? this.configuration.basePath : Ap;
  }
  get fetchApi() {
    return this.configuration.fetchApi;
  }
  get middleware() {
    return this.configuration.middleware || [];
  }
  get queryParamsStringify() {
    return this.configuration.queryParamsStringify || $u;
  }
  get username() {
    return this.configuration.username;
  }
  get password() {
    return this.configuration.password;
  }
  get apiKey() {
    const t = this.configuration.apiKey;
    if (t)
      return typeof t == "function" ? t : () => t;
  }
  get accessToken() {
    const t = this.configuration.accessToken;
    if (t)
      return typeof t == "function" ? t : async () => t;
  }
  get headers() {
    return this.configuration.headers;
  }
  get credentials() {
    return this.configuration.credentials;
  }
}
const Ip = new qu();
class Yr {
  constructor(t = Ip) {
    Xe(this, "middleware"), Xe(this, "fetchApi", async (n, r) => {
      let a = { url: n, init: r };
      for (const i of this.middleware)
        i.pre && (a = await i.pre({
          fetch: this.fetchApi,
          ...a
        }) || a);
      let s;
      try {
        s = await (this.configuration.fetchApi || fetch)(a.url, a.init);
      } catch (i) {
        for (const o of this.middleware)
          o.onError && (s = await o.onError({
            fetch: this.fetchApi,
            url: a.url,
            init: a.init,
            error: i,
            response: s ? s.clone() : void 0
          }) || s);
        if (s === void 0)
          throw i;
      }
      for (const i of this.middleware)
        i.post && (s = await i.post({
          fetch: this.fetchApi,
          url: a.url,
          init: a.init,
          response: s.clone()
        }) || s);
      return s;
    }), this.configuration = t, this.middleware = t.middleware;
  }
  withMiddleware(...t) {
    const n = this.clone();
    return n.middleware = n.middleware.concat(...t), n;
  }
  withPreMiddleware(...t) {
    const n = t.map((r) => ({ pre: r }));
    return this.withMiddleware(...n);
  }
  withPostMiddleware(...t) {
    const n = t.map((r) => ({ post: r }));
    return this.withMiddleware(...n);
  }
  async request(t, n) {
    const { url: r, init: a } = await this.createFetchParams(t, n), s = await this.fetchApi(r, a);
    if (s && s.status >= 200 && s.status < 300)
      return s;
    throw await Mr.from(s);
  }
  async createFetchParams(t, n) {
    let r = this.configuration.basePath + t.path;
    t.query !== void 0 && Object.keys(t.query).length !== 0 && (r += "?" + this.configuration.queryParamsStringify(t.query));
    const a = Object.assign({}, this.configuration.headers, t.headers);
    Object.keys(a).forEach((u) => a[u] === void 0 ? delete a[u] : {});
    const s = typeof n == "function" ? n : async () => n, i = {
      method: t.method,
      headers: a,
      body: t.body,
      credentials: this.configuration.credentials
    }, o = {
      ...i,
      ...await s({
        init: i,
        context: t
      })
    }, c = {
      ...o,
      body: Np(o.body) || o.body instanceof URLSearchParams || Rp(o.body) ? o.body : JSON.stringify(o.body)
    };
    return { url: r, init: c };
  }
  clone() {
    const t = this.constructor, n = new t(this.configuration);
    return n.middleware = this.middleware.slice(), n;
  }
}
function Rp(e) {
  return typeof Blob < "u" && e instanceof Blob;
}
function Np(e) {
  return typeof FormData < "u" && e instanceof FormData;
}
class Mr extends Error {
  constructor(t, n, r) {
    super(r ? JSON.stringify(r) : "Unknown error occurred"), Xe(this, "name", "ResponseError"), this.fetchResponse = t, this.status = n, this.errorResponse = r;
  }
  static async from(t) {
    const n = t.status;
    try {
      const r = await t.json();
      return new Mr(t, n, r);
    } catch {
      return new Mr(t, n, void 0);
    }
  }
}
class _e extends Error {
  constructor(t, n) {
    super(n), Xe(this, "name", "RequiredError"), this.field = t;
  }
}
function y(e, t) {
  return e[t] != null;
}
function $u(e, t = "") {
  return Object.keys(e).map((n) => Lu(n, e[n], t)).filter((n) => n.length > 0).join("&");
}
function Lu(e, t, n = "") {
  const r = n + (n.length ? `[${e}]` : e);
  if (t instanceof Array) {
    const a = t.map((s) => encodeURIComponent(String(s))).join(`&${encodeURIComponent(r)}=`);
    return `${encodeURIComponent(r)}=${a}`;
  }
  if (t instanceof Set) {
    const a = Array.from(t);
    return Lu(e, a, n);
  }
  return t instanceof Date ? `${encodeURIComponent(r)}=${encodeURIComponent(t.toISOString())}` : t instanceof Object ? $u(t, r) : `${encodeURIComponent(r)}=${encodeURIComponent(String(t))}`;
}
class me {
  constructor(t, n = (r) => r) {
    this.raw = t, this.transformer = n;
  }
  async value() {
    return this.transformer(await this.raw.json());
  }
}
function je(e) {
  if (e !== void 0)
    return e === null ? null : {
      state_version: e.state_version,
      timestamp: e.timestamp === void 0 ? void 0 : e.timestamp === null ? null : e.timestamp.toISOString(),
      epoch: e.epoch,
      round: e.round
    };
}
function Dp(e) {
  return jp(e);
}
function jp(e, t) {
  return e == null ? e : {
    status: y(e, "status") ? e.status : void 0,
    fee_summary: y(e, "fee_summary") ? e.fee_summary : void 0,
    state_updates: y(e, "state_updates") ? e.state_updates : void 0,
    next_epoch: y(e, "next_epoch") ? e.next_epoch : void 0,
    output: y(e, "output") ? e.output : void 0,
    events: y(e, "events") ? e.events : void 0,
    error_message: y(e, "error_message") ? e.error_message : void 0
  };
}
function Ms(e) {
  return qp(e);
}
function qp(e, t) {
  return e;
}
function Mu(e) {
  return $p(e);
}
function $p(e, t) {
  return e == null ? e : {
    state_version: e.state_version,
    epoch: e.epoch,
    round: e.round,
    round_timestamp: e.round_timestamp,
    transaction_status: Ms(e.transaction_status),
    payload_hash_hex: y(e, "payload_hash_hex") ? e.payload_hash_hex : void 0,
    intent_hash_hex: y(e, "intent_hash_hex") ? e.intent_hash_hex : void 0,
    fee_paid: y(e, "fee_paid") ? e.fee_paid : void 0,
    affected_global_entities: y(e, "affected_global_entities") ? e.affected_global_entities : void 0,
    confirmed_at: y(e, "confirmed_at") ? e.confirmed_at === null ? null : new Date(e.confirmed_at) : void 0,
    error_message: y(e, "error_message") ? e.error_message : void 0,
    raw_hex: y(e, "raw_hex") ? e.raw_hex : void 0,
    receipt: y(e, "receipt") ? Dp(e.receipt) : void 0,
    message_hex: y(e, "message_hex") ? e.message_hex : void 0
  };
}
function Zs(e) {
  return Lp(e);
}
function Lp(e, t) {
  return e == null ? e : {
    owner: e.owner,
    entries: e.entries
  };
}
function Mp(e, t) {
  return e == null ? e : {
    type: e.type,
    values: e.values
  };
}
function Zp(e, t) {
  return e == null ? e : {
    type: e.type,
    value: e.value
  };
}
function Fp(e, t) {
  return e == null ? e : {
    type: e.type,
    values: e.values
  };
}
function zp(e, t) {
  return e == null ? e : {
    type: e.type,
    value: e.value
  };
}
function Up(e, t) {
  return e == null ? e : {
    type: e.type,
    values: e.values
  };
}
function Vp(e, t) {
  return e == null ? e : {
    type: e.type,
    value: e.value
  };
}
function Wp(e, t) {
  return e == null ? e : {
    type: e.type,
    values: e.values
  };
}
function Bp(e, t) {
  return e == null ? e : {
    type: e.type,
    value: e.value
  };
}
function Kp(e, t) {
  return e == null ? e : {
    type: e.type,
    values: e.values
  };
}
function Gp(e, t) {
  return e == null ? e : {
    type: e.type,
    value: e.value
  };
}
function Hp(e, t) {
  return e == null ? e : {
    type: e.type,
    values: e.values
  };
}
function Jp(e, t) {
  return e == null ? e : {
    type: e.type,
    value: e.value
  };
}
function Yp(e) {
  return Xp(e);
}
function Xp(e, t) {
  return e == null ? e : {
    resource_address: e.resource_address,
    non_fungible_id: e.non_fungible_id
  };
}
function Qp(e, t) {
  return e == null ? e : {
    type: e.type,
    values: e.values.map(Yp)
  };
}
function em(e, t) {
  return e == null ? e : {
    type: e.type,
    resource_address: e.resource_address,
    non_fungible_id: e.non_fungible_id
  };
}
function tm(e, t) {
  return e == null ? e : {
    type: e.type,
    values: e.values
  };
}
function nm(e, t) {
  return e == null ? e : {
    type: e.type,
    value: e.value
  };
}
function rm(e, t) {
  return e == null ? e : {
    type: e.type,
    values: e.values
  };
}
function am(e, t) {
  return e == null ? e : {
    type: e.type,
    value: e.value
  };
}
function sm(e, t) {
  return e == null ? e : {
    key_type: e.key_type,
    key_hex: e.key_hex
  };
}
function im(e) {
  if (e !== void 0)
    return e === null ? null : {
      key_type: e.key_type,
      key_hex: e.key_hex
    };
}
function om(e, t) {
  return e == null ? e : {
    key_type: e.key_type,
    key_hex: e.key_hex
  };
}
function um(e) {
  if (e !== void 0)
    return e === null ? null : {
      key_type: e.key_type,
      key_hex: e.key_hex
    };
}
function Fs(e) {
  return cm(e);
}
function cm(e, t) {
  if (e == null)
    return e;
  switch (e.key_type) {
    case "EcdsaSecp256k1":
      return { ...sm(e), key_type: "EcdsaSecp256k1" };
    case "EddsaEd25519":
      return { ...om(e), key_type: "EddsaEd25519" };
    default:
      throw new Error(`No variant of PublicKey exists with 'key_type=${e.key_type}'`);
  }
}
function io(e) {
  if (e !== void 0) {
    if (e === null)
      return null;
    switch (e.key_type) {
      case "EcdsaSecp256k1":
        return im(e);
      case "EddsaEd25519":
        return um(e);
      default:
        throw new Error(`No variant of PublicKey exists with 'key_type=${e.key_type}'`);
    }
  }
}
function lm(e, t) {
  return e == null ? e : {
    type: e.type,
    values: e.values.map(Fs)
  };
}
function dm(e, t) {
  return e == null ? e : {
    key_hash_type: e.key_hash_type,
    hash_hex: e.hash_hex
  };
}
function fm(e, t) {
  return e == null ? e : {
    key_hash_type: e.key_hash_type,
    hash_hex: e.hash_hex
  };
}
function Zu(e) {
  return hm(e);
}
function hm(e, t) {
  if (e == null)
    return e;
  switch (e.key_hash_type) {
    case "EcdsaSecp256k1":
      return { ...dm(e), key_hash_type: "EcdsaSecp256k1" };
    case "EddsaEd25519":
      return { ...fm(e), key_hash_type: "EddsaEd25519" };
    default:
      throw new Error(`No variant of PublicKeyHash exists with 'key_hash_type=${e.key_hash_type}'`);
  }
}
function pm(e, t) {
  return e == null ? e : {
    type: e.type,
    values: e.values.map(Zu)
  };
}
function mm(e, t) {
  return e == null ? e : {
    type: e.type,
    value: Zu(e.value)
  };
}
function ym(e, t) {
  return e == null ? e : {
    type: e.type,
    value: Fs(e.value)
  };
}
function vm(e, t) {
  return e == null ? e : {
    type: e.type,
    values: e.values
  };
}
function gm(e, t) {
  return e == null ? e : {
    type: e.type,
    value: e.value
  };
}
function _m(e, t) {
  return e == null ? e : {
    type: e.type,
    values: e.values
  };
}
function bm(e, t) {
  return e == null ? e : {
    type: e.type,
    value: e.value
  };
}
function wm(e, t) {
  return e == null ? e : {
    type: e.type,
    values: e.values
  };
}
function xm(e, t) {
  return e == null ? e : {
    type: e.type,
    value: e.value
  };
}
function km(e, t) {
  return e == null ? e : {
    type: e.type,
    value_hex: e.value_hex
  };
}
function Sm(e, t) {
  return e == null ? e : {
    type: e.type,
    value: e.value
  };
}
function Tm(e, t) {
  return e == null ? e : {
    type: e.type,
    values: e.values
  };
}
function Pm(e, t) {
  return e == null ? e : {
    type: e.type,
    value: e.value
  };
}
function Om(e) {
  return Em(e);
}
function Em(e, t) {
  if (e == null)
    return e;
  switch (e.type) {
    case "Bool":
      return { ...Zp(e), type: "Bool" };
    case "BoolArray":
      return { ...Mp(e), type: "BoolArray" };
    case "Decimal":
      return { ...zp(e), type: "Decimal" };
    case "DecimalArray":
      return { ...Fp(e), type: "DecimalArray" };
    case "GlobalAddress":
      return { ...Vp(e), type: "GlobalAddress" };
    case "GlobalAddressArray":
      return { ...Up(e), type: "GlobalAddressArray" };
    case "I32":
      return { ...Bp(e), type: "I32" };
    case "I32Array":
      return { ...Wp(e), type: "I32Array" };
    case "I64":
      return { ...Gp(e), type: "I64" };
    case "I64Array":
      return { ...Kp(e), type: "I64Array" };
    case "Instant":
      return { ...Jp(e), type: "Instant" };
    case "InstantArray":
      return { ...Hp(e), type: "InstantArray" };
    case "NonFungibleGlobalId":
      return { ...em(e), type: "NonFungibleGlobalId" };
    case "NonFungibleGlobalIdArray":
      return { ...Qp(e), type: "NonFungibleGlobalIdArray" };
    case "NonFungibleLocalId":
      return { ...nm(e), type: "NonFungibleLocalId" };
    case "NonFungibleLocalIdArray":
      return { ...tm(e), type: "NonFungibleLocalIdArray" };
    case "Origin":
      return { ...am(e), type: "Origin" };
    case "OriginArray":
      return { ...rm(e), type: "OriginArray" };
    case "PublicKey":
      return { ...ym(e), type: "PublicKey" };
    case "PublicKeyArray":
      return { ...lm(e), type: "PublicKeyArray" };
    case "PublicKeyHash":
      return { ...mm(e), type: "PublicKeyHash" };
    case "PublicKeyHashArray":
      return { ...pm(e), type: "PublicKeyHashArray" };
    case "String":
      return { ...gm(e), type: "String" };
    case "StringArray":
      return { ...vm(e), type: "StringArray" };
    case "U32":
      return { ...bm(e), type: "U32" };
    case "U32Array":
      return { ..._m(e), type: "U32Array" };
    case "U64":
      return { ...xm(e), type: "U64" };
    case "U64Array":
      return { ...wm(e), type: "U64Array" };
    case "U8":
      return { ...Sm(e), type: "U8" };
    case "U8Array":
      return { ...km(e), type: "U8Array" };
    case "Url":
      return { ...Pm(e), type: "Url" };
    case "UrlArray":
      return { ...Tm(e), type: "UrlArray" };
    default:
      throw new Error(`No variant of MetadataTypedValue exists with 'type=${e.type}'`);
  }
}
function Cm(e) {
  return Am(e);
}
function Am(e, t) {
  return e == null ? e : {
    raw_hex: e.raw_hex,
    raw_json: e.raw_json,
    typed: y(e, "typed") ? Om(e.typed) : void 0
  };
}
function Fu(e) {
  return Im(e);
}
function Im(e, t) {
  return e == null ? e : {
    key: e.key,
    value: Cm(e.value),
    is_locked: e.is_locked,
    last_updated_at_state_version: e.last_updated_at_state_version
  };
}
function an(e) {
  return Rm(e);
}
function Rm(e, t) {
  return e == null ? e : {
    total_count: y(e, "total_count") ? e.total_count : void 0,
    previous_cursor: y(e, "previous_cursor") ? e.previous_cursor : void 0,
    next_cursor: y(e, "next_cursor") ? e.next_cursor : void 0,
    items: e.items.map(Fu)
  };
}
function Nm(e, t) {
  return e == null ? e : {
    aggregation_level: e.aggregation_level,
    resource_address: e.resource_address,
    explicit_metadata: y(e, "explicit_metadata") ? an(e.explicit_metadata) : void 0,
    amount: e.amount,
    last_updated_at_state_version: e.last_updated_at_state_version
  };
}
function zu(e) {
  return Dm(e);
}
function Dm(e, t) {
  return e == null ? e : {
    vault_address: e.vault_address,
    amount: e.amount,
    last_updated_at_state_version: e.last_updated_at_state_version
  };
}
function jm(e) {
  return qm(e);
}
function qm(e, t) {
  return e == null ? e : {
    total_count: y(e, "total_count") ? e.total_count : void 0,
    previous_cursor: y(e, "previous_cursor") ? e.previous_cursor : void 0,
    next_cursor: y(e, "next_cursor") ? e.next_cursor : void 0,
    items: e.items.map(zu)
  };
}
function $m(e, t) {
  return e == null ? e : {
    aggregation_level: e.aggregation_level,
    resource_address: e.resource_address,
    explicit_metadata: y(e, "explicit_metadata") ? an(e.explicit_metadata) : void 0,
    vaults: jm(e.vaults)
  };
}
function Uu(e) {
  return Lm(e);
}
function Lm(e, t) {
  if (e == null)
    return e;
  switch (e.aggregation_level) {
    case "Global":
      return { ...Nm(e), aggregation_level: "Global" };
    case "Vault":
      return { ...$m(e), aggregation_level: "Vault" };
    default:
      throw new Error(`No variant of FungibleResourcesCollectionItem exists with 'aggregation_level=${e.aggregation_level}'`);
  }
}
function Mm(e) {
  return Zm(e);
}
function Zm(e, t) {
  return e == null ? e : {
    total_count: y(e, "total_count") ? e.total_count : void 0,
    previous_cursor: y(e, "previous_cursor") ? e.previous_cursor : void 0,
    next_cursor: y(e, "next_cursor") ? e.next_cursor : void 0,
    items: e.items.map(Uu)
  };
}
const Fm = {
  Global: "Global",
  Vault: "Vault"
};
function zm(e) {
  return Um(e);
}
function Um(e, t) {
  return e == null ? e : {
    release_version: e.release_version,
    open_api_schema_version: e.open_api_schema_version,
    image_tag: e.image_tag
  };
}
function Se(e) {
  return Vm(e);
}
function Vm(e, t) {
  return e == null ? e : {
    network: e.network,
    state_version: e.state_version,
    proposer_round_timestamp: e.proposer_round_timestamp,
    epoch: e.epoch,
    round: e.round
  };
}
function Wm(e) {
  return Bm(e);
}
function Bm(e, t) {
  return e == null ? e : {
    ledger_state: Se(e.ledger_state),
    release_info: zm(e.release_info)
  };
}
function Km(e) {
  return Gm(e);
}
function Gm(e, t) {
  return e == null ? e : {
    xrd: e.xrd,
    secp256k1_signature_virtual_badge: e.secp256k1_signature_virtual_badge,
    ed25519_signature_virtual_badge: e.ed25519_signature_virtual_badge,
    package_of_direct_caller_virtual_badge: e.package_of_direct_caller_virtual_badge,
    global_caller_virtual_badge: e.global_caller_virtual_badge,
    system_transaction_badge: e.system_transaction_badge,
    package_owner_badge: e.package_owner_badge,
    validator_owner_badge: e.validator_owner_badge,
    account_owner_badge: e.account_owner_badge,
    identity_owner_badge: e.identity_owner_badge,
    package_package: e.package_package,
    resource_package: e.resource_package,
    account_package: e.account_package,
    identity_package: e.identity_package,
    consensus_manager_package: e.consensus_manager_package,
    access_controller_package: e.access_controller_package,
    transaction_processor_package: e.transaction_processor_package,
    metadata_module_package: e.metadata_module_package,
    royalty_module_package: e.royalty_module_package,
    access_rules_package: e.access_rules_package,
    genesis_helper_package: e.genesis_helper_package,
    faucet_package: e.faucet_package,
    consensus_manager: e.consensus_manager,
    genesis_helper: e.genesis_helper,
    faucet: e.faucet
  };
}
function Hm(e) {
  return Jm(e);
}
function Jm(e, t) {
  return e == null ? e : {
    network_id: e.network_id,
    network_name: e.network_name,
    well_known_addresses: Km(e.well_known_addresses)
  };
}
function Vu(e) {
  return Ym(e);
}
function Ym(e, t) {
  return e;
}
function Xm(e) {
  return Qm(e);
}
function Qm(e, t) {
  return e == null ? e : {
    total_count: y(e, "total_count") ? e.total_count : void 0,
    previous_cursor: y(e, "previous_cursor") ? e.previous_cursor : void 0,
    next_cursor: y(e, "next_cursor") ? e.next_cursor : void 0,
    items: e.items
  };
}
function ey(e, t) {
  return e == null ? e : {
    aggregation_level: e.aggregation_level,
    resource_address: e.resource_address,
    explicit_metadata: y(e, "explicit_metadata") ? an(e.explicit_metadata) : void 0,
    amount: e.amount,
    last_updated_at_state_version: e.last_updated_at_state_version
  };
}
function Wu(e) {
  return ty(e);
}
function ty(e, t) {
  return e == null ? e : {
    total_count: e.total_count,
    previous_cursor: y(e, "previous_cursor") ? e.previous_cursor : void 0,
    next_cursor: y(e, "next_cursor") ? e.next_cursor : void 0,
    items: y(e, "items") ? e.items : void 0,
    vault_address: e.vault_address,
    last_updated_at_state_version: e.last_updated_at_state_version
  };
}
function ny(e) {
  return ry(e);
}
function ry(e, t) {
  return e == null ? e : {
    total_count: y(e, "total_count") ? e.total_count : void 0,
    previous_cursor: y(e, "previous_cursor") ? e.previous_cursor : void 0,
    next_cursor: y(e, "next_cursor") ? e.next_cursor : void 0,
    items: e.items.map(Wu)
  };
}
function ay(e, t) {
  return e == null ? e : {
    aggregation_level: e.aggregation_level,
    resource_address: e.resource_address,
    explicit_metadata: y(e, "explicit_metadata") ? an(e.explicit_metadata) : void 0,
    vaults: ny(e.vaults)
  };
}
function Bu(e) {
  return sy(e);
}
function sy(e, t) {
  if (e == null)
    return e;
  switch (e.aggregation_level) {
    case "Global":
      return { ...ey(e), aggregation_level: "Global" };
    case "Vault":
      return { ...ay(e), aggregation_level: "Vault" };
    default:
      throw new Error(`No variant of NonFungibleResourcesCollectionItem exists with 'aggregation_level=${e.aggregation_level}'`);
  }
}
function iy(e) {
  return oy(e);
}
function oy(e, t) {
  return e == null ? e : {
    total_count: y(e, "total_count") ? e.total_count : void 0,
    previous_cursor: y(e, "previous_cursor") ? e.previous_cursor : void 0,
    next_cursor: y(e, "next_cursor") ? e.next_cursor : void 0,
    items: e.items.map(Bu)
  };
}
function uy(e) {
  return cy(e);
}
function cy(e, t) {
  return e;
}
function ly(e) {
  return dy(e);
}
function dy(e, t) {
  return e == null ? e : {
    raw_hex: e.raw_hex,
    raw_json: e.raw_json
  };
}
function fy(e) {
  if (e !== void 0)
    return e === null ? null : {
      ancestor_identities: e.ancestor_identities,
      component_royalty_vault_balance: e.component_royalty_vault_balance,
      package_royalty_vault_balance: e.package_royalty_vault_balance,
      non_fungible_include_nfids: e.non_fungible_include_nfids,
      explicit_metadata: e.explicit_metadata
    };
}
function hy(e) {
  if (e !== void 0)
    return e === null ? null : {
      at_ledger_state: je(e.at_ledger_state),
      opt_ins: fy(e.opt_ins),
      addresses: e.addresses,
      aggregation_level: e.aggregation_level
    };
}
function py(e) {
  return my(e);
}
function my(e, t) {
  return e == null ? e : {
    parent_address: y(e, "parent_address") ? e.parent_address : void 0,
    owner_address: y(e, "owner_address") ? e.owner_address : void 0,
    global_address: y(e, "global_address") ? e.global_address : void 0
  };
}
function yy(e, t) {
  return e == null ? e : {
    type: e.type,
    package_address: y(e, "package_address") ? e.package_address : void 0,
    blueprint_name: e.blueprint_name,
    state: y(e, "state") ? e.state : void 0,
    access_rules: Zs(e.access_rules),
    royalty_vault_balance: y(e, "royalty_vault_balance") ? e.royalty_vault_balance : void 0
  };
}
function vy(e, t) {
  return e == null ? e : {
    type: e.type,
    access_rules: Zs(e.access_rules),
    divisibility: e.divisibility,
    total_supply: e.total_supply,
    total_minted: e.total_minted,
    total_burned: e.total_burned
  };
}
function gy(e, t) {
  return e == null ? e : {
    type: e.type
  };
}
function _y(e, t) {
  return e == null ? e : {
    type: e.type,
    access_rules: Zs(e.access_rules),
    non_fungible_id_type: Vu(e.non_fungible_id_type),
    total_supply: e.total_supply,
    total_minted: e.total_minted,
    total_burned: e.total_burned
  };
}
function by(e, t) {
  return e == null ? e : {
    type: e.type
  };
}
function wy(e) {
  return xy(e);
}
function xy(e, t) {
  return e == null ? e : {
    name: e.name,
    version: e.version,
    definition: e.definition,
    dependant_entities: y(e, "dependant_entities") ? e.dependant_entities : void 0,
    auth_template: y(e, "auth_template") ? e.auth_template : void 0,
    auth_template_is_locked: y(e, "auth_template_is_locked") ? e.auth_template_is_locked : void 0,
    royalty_config: y(e, "royalty_config") ? e.royalty_config : void 0,
    royalty_config_is_locked: y(e, "royalty_config_is_locked") ? e.royalty_config_is_locked : void 0
  };
}
function ky(e) {
  return Sy(e);
}
function Sy(e, t) {
  return e == null ? e : {
    total_count: y(e, "total_count") ? e.total_count : void 0,
    previous_cursor: y(e, "previous_cursor") ? e.previous_cursor : void 0,
    next_cursor: y(e, "next_cursor") ? e.next_cursor : void 0,
    items: e.items.map(wy)
  };
}
function Ty(e, t) {
  return e == null ? e : {
    type: e.type,
    vm_type: uy(e.vm_type),
    code_hash_hex: e.code_hash_hex,
    code_hex: y(e, "code_hex") ? e.code_hex : void 0,
    schema_hash_hex: e.schema_hash_hex,
    schema: y(e, "schema") ? e.schema : void 0,
    royalty_vault_balance: y(e, "royalty_vault_balance") ? e.royalty_vault_balance : void 0,
    blueprints: y(e, "blueprints") ? ky(e.blueprints) : void 0
  };
}
function Py(e) {
  return Oy(e);
}
function Oy(e, t) {
  if (e == null)
    return e;
  switch (e.type) {
    case "Component":
      return { ...yy(e), type: "Component" };
    case "FungibleResource":
      return { ...vy(e), type: "FungibleResource" };
    case "FungibleVault":
      return { ...gy(e), type: "FungibleVault" };
    case "NonFungibleResource":
      return { ..._y(e), type: "NonFungibleResource" };
    case "NonFungibleVault":
      return { ...by(e), type: "NonFungibleVault" };
    case "Package":
      return { ...Ty(e), type: "Package" };
    default:
      throw new Error(`No variant of StateEntityDetailsResponseItemDetails exists with 'type=${e.type}'`);
  }
}
function Ey(e) {
  return Cy(e);
}
function Cy(e, t) {
  return e == null ? e : {
    address: e.address,
    fungible_resources: y(e, "fungible_resources") ? Mm(e.fungible_resources) : void 0,
    non_fungible_resources: y(e, "non_fungible_resources") ? iy(e.non_fungible_resources) : void 0,
    ancestor_identities: y(e, "ancestor_identities") ? py(e.ancestor_identities) : void 0,
    metadata: an(e.metadata),
    explicit_metadata: y(e, "explicit_metadata") ? an(e.explicit_metadata) : void 0,
    details: y(e, "details") ? Py(e.details) : void 0
  };
}
function Ay(e) {
  return Iy(e);
}
function Iy(e, t) {
  return e == null ? e : {
    ledger_state: Se(e.ledger_state),
    items: e.items.map(Ey)
  };
}
function Ry(e) {
  if (e !== void 0)
    return e === null ? null : {
      at_ledger_state: je(e.at_ledger_state),
      cursor: e.cursor,
      limit_per_page: e.limit_per_page,
      address: e.address,
      resource_address: e.resource_address
    };
}
function Ny(e) {
  return Dy(e);
}
function Dy(e, t) {
  return e == null ? e : {
    ledger_state: Se(e.ledger_state),
    total_count: y(e, "total_count") ? e.total_count : void 0,
    previous_cursor: y(e, "previous_cursor") ? e.previous_cursor : void 0,
    next_cursor: y(e, "next_cursor") ? e.next_cursor : void 0,
    items: e.items.map(zu),
    address: e.address,
    resource_address: e.resource_address
  };
}
function jy(e) {
  if (e !== void 0)
    return e === null ? null : {
      explicit_metadata: e.explicit_metadata
    };
}
function qy(e) {
  if (e !== void 0)
    return e === null ? null : {
      at_ledger_state: je(e.at_ledger_state),
      cursor: e.cursor,
      limit_per_page: e.limit_per_page,
      address: e.address,
      aggregation_level: e.aggregation_level,
      opt_ins: jy(e.opt_ins)
    };
}
function $y(e) {
  return Ly(e);
}
function Ly(e, t) {
  return e == null ? e : {
    ledger_state: Se(e.ledger_state),
    total_count: y(e, "total_count") ? e.total_count : void 0,
    previous_cursor: y(e, "previous_cursor") ? e.previous_cursor : void 0,
    next_cursor: y(e, "next_cursor") ? e.next_cursor : void 0,
    items: e.items.map(Uu),
    address: e.address
  };
}
function My(e) {
  if (e !== void 0)
    return e === null ? null : {
      at_ledger_state: je(e.at_ledger_state),
      cursor: e.cursor,
      limit_per_page: e.limit_per_page,
      address: e.address
    };
}
function Zy(e) {
  return Fy(e);
}
function Fy(e, t) {
  return e == null ? e : {
    ledger_state: Se(e.ledger_state),
    total_count: y(e, "total_count") ? e.total_count : void 0,
    previous_cursor: y(e, "previous_cursor") ? e.previous_cursor : void 0,
    next_cursor: y(e, "next_cursor") ? e.next_cursor : void 0,
    items: e.items.map(Fu),
    address: e.address
  };
}
function zy(e) {
  if (e !== void 0)
    return e === null ? null : {
      at_ledger_state: je(e.at_ledger_state),
      cursor: e.cursor,
      limit_per_page: e.limit_per_page,
      address: e.address,
      vault_address: e.vault_address,
      resource_address: e.resource_address
    };
}
function Uy(e) {
  return Vy(e);
}
function Vy(e, t) {
  return e == null ? e : {
    ledger_state: Se(e.ledger_state),
    total_count: y(e, "total_count") ? e.total_count : void 0,
    previous_cursor: y(e, "previous_cursor") ? e.previous_cursor : void 0,
    next_cursor: y(e, "next_cursor") ? e.next_cursor : void 0,
    items: e.items,
    address: e.address,
    resource_address: e.resource_address
  };
}
function Wy(e) {
  if (e !== void 0)
    return e === null ? null : {
      non_fungible_include_nfids: e.non_fungible_include_nfids
    };
}
function By(e) {
  if (e !== void 0)
    return e === null ? null : {
      at_ledger_state: je(e.at_ledger_state),
      cursor: e.cursor,
      limit_per_page: e.limit_per_page,
      address: e.address,
      resource_address: e.resource_address,
      opt_ins: Wy(e.opt_ins)
    };
}
function Ky(e) {
  return Gy(e);
}
function Gy(e, t) {
  return e == null ? e : {
    ledger_state: Se(e.ledger_state),
    total_count: y(e, "total_count") ? e.total_count : void 0,
    previous_cursor: y(e, "previous_cursor") ? e.previous_cursor : void 0,
    next_cursor: y(e, "next_cursor") ? e.next_cursor : void 0,
    items: e.items.map(Wu),
    address: e.address,
    resource_address: e.resource_address
  };
}
function Hy(e) {
  if (e !== void 0)
    return e === null ? null : {
      non_fungible_include_nfids: e.non_fungible_include_nfids,
      explicit_metadata: e.explicit_metadata
    };
}
function Jy(e) {
  if (e !== void 0)
    return e === null ? null : {
      at_ledger_state: je(e.at_ledger_state),
      cursor: e.cursor,
      limit_per_page: e.limit_per_page,
      address: e.address,
      aggregation_level: e.aggregation_level,
      opt_ins: Hy(e.opt_ins)
    };
}
function Yy(e) {
  return Xy(e);
}
function Xy(e, t) {
  return e == null ? e : {
    ledger_state: Se(e.ledger_state),
    total_count: y(e, "total_count") ? e.total_count : void 0,
    previous_cursor: y(e, "previous_cursor") ? e.previous_cursor : void 0,
    next_cursor: y(e, "next_cursor") ? e.next_cursor : void 0,
    items: e.items.map(Bu),
    address: e.address
  };
}
function Qy(e) {
  if (e !== void 0)
    return e === null ? null : {
      at_ledger_state: je(e.at_ledger_state),
      resource_address: e.resource_address,
      non_fungible_ids: e.non_fungible_ids
    };
}
function ev(e) {
  return tv(e);
}
function tv(e, t) {
  return e == null ? e : {
    non_fungible_id: e.non_fungible_id,
    data: ly(e.data),
    last_updated_at_state_version: e.last_updated_at_state_version
  };
}
function nv(e) {
  return rv(e);
}
function rv(e, t) {
  return e == null ? e : {
    ledger_state: Se(e.ledger_state),
    resource_address: e.resource_address,
    non_fungible_id_type: Vu(e.non_fungible_id_type),
    non_fungible_ids: e.non_fungible_ids.map(ev)
  };
}
function av(e) {
  if (e !== void 0)
    return e === null ? null : {
      at_ledger_state: je(e.at_ledger_state),
      cursor: e.cursor,
      limit_per_page: e.limit_per_page,
      resource_address: e.resource_address
    };
}
function sv(e) {
  return iv(e);
}
function iv(e, t) {
  return e == null ? e : {
    ledger_state: Se(e.ledger_state),
    resource_address: e.resource_address,
    non_fungible_ids: Xm(e.non_fungible_ids)
  };
}
function ov(e) {
  if (e !== void 0)
    return e === null ? null : {
      at_ledger_state: je(e.at_ledger_state),
      cursor: e.cursor
    };
}
function uv(e) {
  return cv(e);
}
function cv(e, t) {
  return e == null ? e : {
    stake: e.stake,
    stake_percentage: e.stake_percentage,
    key: Fs(e.key)
  };
}
function lr(e) {
  return lv(e);
}
function lv(e, t) {
  return e == null ? e : {
    balance: e.balance,
    last_changed_at_state_version: e.last_changed_at_state_version,
    address: e.address
  };
}
function dv(e) {
  return fv(e);
}
function fv(e, t) {
  return e == null ? e : {
    address: e.address,
    stake_vault: lr(e.stake_vault),
    pending_xrd_withdraw_vault: lr(e.pending_xrd_withdraw_vault),
    locked_owner_stake_unit_vault: lr(e.locked_owner_stake_unit_vault),
    pending_owner_stake_unit_unlock_vault: lr(e.pending_owner_stake_unit_unlock_vault),
    state: y(e, "state") ? e.state : void 0,
    active_in_epoch: y(e, "active_in_epoch") ? uv(e.active_in_epoch) : void 0,
    metadata: an(e.metadata)
  };
}
function hv(e) {
  return pv(e);
}
function pv(e, t) {
  return e == null ? e : {
    total_count: y(e, "total_count") ? e.total_count : void 0,
    previous_cursor: y(e, "previous_cursor") ? e.previous_cursor : void 0,
    next_cursor: y(e, "next_cursor") ? e.next_cursor : void 0,
    items: e.items.map(dv)
  };
}
function mv(e) {
  return yv(e);
}
function yv(e, t) {
  return e == null ? e : {
    ledger_state: Se(e.ledger_state),
    validators: hv(e.validators)
  };
}
function vv(e) {
  if (e !== void 0)
    return e === null ? null : {
      event: e.event,
      emitter_address: e.emitter_address,
      resource_address: e.resource_address,
      quantity: e.quantity
    };
}
function Ku(e) {
  if (e !== void 0)
    return e === null ? null : {
      raw_hex: e.raw_hex,
      receipt_state_changes: e.receipt_state_changes,
      receipt_fee_summary: e.receipt_fee_summary,
      receipt_events: e.receipt_events,
      affected_global_entities: e.affected_global_entities
    };
}
function gv(e) {
  if (e !== void 0)
    return e === null ? null : {
      at_ledger_state: je(e.at_ledger_state),
      cursor: e.cursor,
      limit_per_page: e.limit_per_page,
      from_ledger_state: je(e.from_ledger_state),
      kind_filter: e.kind_filter,
      manifest_accounts_withdrawn_from_filter: e.manifest_accounts_withdrawn_from_filter,
      manifest_accounts_deposited_into_filter: e.manifest_accounts_deposited_into_filter,
      manifest_resources_filter: e.manifest_resources_filter,
      affected_global_entities_filter: e.affected_global_entities_filter,
      events_filter: e.events_filter === void 0 ? void 0 : e.events_filter.map(vv),
      order: e.order,
      opt_ins: Ku(e.opt_ins)
    };
}
function _v(e) {
  return bv(e);
}
function bv(e, t) {
  return e == null ? e : {
    ledger_state: Se(e.ledger_state),
    total_count: y(e, "total_count") ? e.total_count : void 0,
    previous_cursor: y(e, "previous_cursor") ? e.previous_cursor : void 0,
    next_cursor: y(e, "next_cursor") ? e.next_cursor : void 0,
    items: e.items.map(Mu)
  };
}
function wv(e) {
  if (e !== void 0)
    return e === null ? null : {
      at_ledger_state: je(e.at_ledger_state),
      intent_hash_hex: e.intent_hash_hex,
      opt_ins: Ku(e.opt_ins)
    };
}
function xv(e) {
  return kv(e);
}
function kv(e, t) {
  return e == null ? e : {
    ledger_state: Se(e.ledger_state),
    transaction: Mu(e.transaction)
  };
}
function Sv(e) {
  return Tv(e);
}
function Tv(e, t) {
  return e == null ? e : {
    ledger_state: Se(e.ledger_state)
  };
}
function Pv(e) {
  if (e !== void 0)
    return e === null ? null : {
      use_free_credit: e.use_free_credit,
      assume_all_signature_proofs: e.assume_all_signature_proofs,
      skip_epoch_check: e.skip_epoch_check
    };
}
function Ov(e) {
  if (e !== void 0)
    return e === null ? null : {
      manifest: e.manifest,
      blobs_hex: e.blobs_hex,
      start_epoch_inclusive: e.start_epoch_inclusive,
      end_epoch_exclusive: e.end_epoch_exclusive,
      notary_public_key: io(e.notary_public_key),
      notary_is_signatory: e.notary_is_signatory,
      tip_percentage: e.tip_percentage,
      nonce: e.nonce,
      signer_public_keys: e.signer_public_keys.map(io),
      flags: Pv(e.flags)
    };
}
function Ev(e) {
  return Cv(e);
}
function Cv(e, t) {
  return e == null ? e : {
    level: e.level,
    message: e.message
  };
}
function Av(e) {
  return Iv(e);
}
function Iv(e, t) {
  return e == null ? e : {
    encoded_receipt: e.encoded_receipt,
    receipt: e.receipt,
    resource_changes: e.resource_changes,
    logs: e.logs.map(Ev)
  };
}
function Rv(e) {
  if (e !== void 0)
    return e === null ? null : {
      intent_hash_hex: e.intent_hash_hex
    };
}
function Nv(e) {
  return Dv(e);
}
function Dv(e, t) {
  return e == null ? e : {
    payload_hash_hex: e.payload_hash_hex,
    status: Ms(e.status),
    error_message: y(e, "error_message") ? e.error_message : void 0
  };
}
function jv(e) {
  return qv(e);
}
function qv(e, t) {
  return e == null ? e : {
    ledger_state: Se(e.ledger_state),
    status: Ms(e.status),
    known_payloads: e.known_payloads.map(Nv),
    error_message: y(e, "error_message") ? e.error_message : void 0
  };
}
function $v(e) {
  if (e !== void 0)
    return e === null ? null : {
      notarized_transaction_hex: e.notarized_transaction_hex
    };
}
function Lv(e) {
  return Mv(e);
}
function Mv(e, t) {
  return e == null ? e : {
    duplicate: e.duplicate
  };
}
class Zv extends Yr {
  async streamTransactionsRaw(t, n) {
    if (t.streamTransactionsRequest === null || t.streamTransactionsRequest === void 0)
      throw new _e("streamTransactionsRequest", "Required parameter requestParameters.streamTransactionsRequest was null or undefined when calling streamTransactions.");
    const r = {}, a = {};
    a["Content-Type"] = "application/json";
    const s = await this.request({
      path: "/stream/transactions",
      method: "POST",
      headers: a,
      query: r,
      body: gv(t.streamTransactionsRequest)
    }, n);
    return new me(s, (i) => _v(i));
  }
  async streamTransactions(t, n) {
    return await (await this.streamTransactionsRaw(t, n)).value();
  }
}
class Fv extends Yr {
  async entityFungibleResourceVaultPageRaw(t, n) {
    if (t.stateEntityFungibleResourceVaultsPageRequest === null || t.stateEntityFungibleResourceVaultsPageRequest === void 0)
      throw new _e("stateEntityFungibleResourceVaultsPageRequest", "Required parameter requestParameters.stateEntityFungibleResourceVaultsPageRequest was null or undefined when calling entityFungibleResourceVaultPage.");
    const r = {}, a = {};
    a["Content-Type"] = "application/json";
    const s = await this.request({
      path: "/state/entity/page/fungible-vaults/",
      method: "POST",
      headers: a,
      query: r,
      body: Ry(t.stateEntityFungibleResourceVaultsPageRequest)
    }, n);
    return new me(s, (i) => Ny(i));
  }
  async entityFungibleResourceVaultPage(t, n) {
    return await (await this.entityFungibleResourceVaultPageRaw(t, n)).value();
  }
  async entityFungiblesPageRaw(t, n) {
    if (t.stateEntityFungiblesPageRequest === null || t.stateEntityFungiblesPageRequest === void 0)
      throw new _e("stateEntityFungiblesPageRequest", "Required parameter requestParameters.stateEntityFungiblesPageRequest was null or undefined when calling entityFungiblesPage.");
    const r = {}, a = {};
    a["Content-Type"] = "application/json";
    const s = await this.request({
      path: "/state/entity/page/fungibles/",
      method: "POST",
      headers: a,
      query: r,
      body: qy(t.stateEntityFungiblesPageRequest)
    }, n);
    return new me(s, (i) => $y(i));
  }
  async entityFungiblesPage(t, n) {
    return await (await this.entityFungiblesPageRaw(t, n)).value();
  }
  async entityMetadataPageRaw(t, n) {
    if (t.stateEntityMetadataPageRequest === null || t.stateEntityMetadataPageRequest === void 0)
      throw new _e("stateEntityMetadataPageRequest", "Required parameter requestParameters.stateEntityMetadataPageRequest was null or undefined when calling entityMetadataPage.");
    const r = {}, a = {};
    a["Content-Type"] = "application/json";
    const s = await this.request({
      path: "/state/entity/page/metadata",
      method: "POST",
      headers: a,
      query: r,
      body: My(t.stateEntityMetadataPageRequest)
    }, n);
    return new me(s, (i) => Zy(i));
  }
  async entityMetadataPage(t, n) {
    return await (await this.entityMetadataPageRaw(t, n)).value();
  }
  async entityNonFungibleIdsPageRaw(t, n) {
    if (t.stateEntityNonFungibleIdsPageRequest === null || t.stateEntityNonFungibleIdsPageRequest === void 0)
      throw new _e("stateEntityNonFungibleIdsPageRequest", "Required parameter requestParameters.stateEntityNonFungibleIdsPageRequest was null or undefined when calling entityNonFungibleIdsPage.");
    const r = {}, a = {};
    a["Content-Type"] = "application/json";
    const s = await this.request({
      path: "/state/entity/page/non-fungible-vault/ids",
      method: "POST",
      headers: a,
      query: r,
      body: zy(t.stateEntityNonFungibleIdsPageRequest)
    }, n);
    return new me(s, (i) => Uy(i));
  }
  async entityNonFungibleIdsPage(t, n) {
    return await (await this.entityNonFungibleIdsPageRaw(t, n)).value();
  }
  async entityNonFungibleResourceVaultPageRaw(t, n) {
    if (t.stateEntityNonFungibleResourceVaultsPageRequest === null || t.stateEntityNonFungibleResourceVaultsPageRequest === void 0)
      throw new _e("stateEntityNonFungibleResourceVaultsPageRequest", "Required parameter requestParameters.stateEntityNonFungibleResourceVaultsPageRequest was null or undefined when calling entityNonFungibleResourceVaultPage.");
    const r = {}, a = {};
    a["Content-Type"] = "application/json";
    const s = await this.request({
      path: "/state/entity/page/non-fungible-vaults/",
      method: "POST",
      headers: a,
      query: r,
      body: By(t.stateEntityNonFungibleResourceVaultsPageRequest)
    }, n);
    return new me(s, (i) => Ky(i));
  }
  async entityNonFungibleResourceVaultPage(t, n) {
    return await (await this.entityNonFungibleResourceVaultPageRaw(t, n)).value();
  }
  async entityNonFungiblesPageRaw(t, n) {
    if (t.stateEntityNonFungiblesPageRequest === null || t.stateEntityNonFungiblesPageRequest === void 0)
      throw new _e("stateEntityNonFungiblesPageRequest", "Required parameter requestParameters.stateEntityNonFungiblesPageRequest was null or undefined when calling entityNonFungiblesPage.");
    const r = {}, a = {};
    a["Content-Type"] = "application/json";
    const s = await this.request({
      path: "/state/entity/page/non-fungibles/",
      method: "POST",
      headers: a,
      query: r,
      body: Jy(t.stateEntityNonFungiblesPageRequest)
    }, n);
    return new me(s, (i) => Yy(i));
  }
  async entityNonFungiblesPage(t, n) {
    return await (await this.entityNonFungiblesPageRaw(t, n)).value();
  }
  async nonFungibleDataRaw(t, n) {
    if (t.stateNonFungibleDataRequest === null || t.stateNonFungibleDataRequest === void 0)
      throw new _e("stateNonFungibleDataRequest", "Required parameter requestParameters.stateNonFungibleDataRequest was null or undefined when calling nonFungibleData.");
    const r = {}, a = {};
    a["Content-Type"] = "application/json";
    const s = await this.request({
      path: "/state/non-fungible/data",
      method: "POST",
      headers: a,
      query: r,
      body: Qy(t.stateNonFungibleDataRequest)
    }, n);
    return new me(s, (i) => nv(i));
  }
  async nonFungibleData(t, n) {
    return await (await this.nonFungibleDataRaw(t, n)).value();
  }
  async nonFungibleIdsRaw(t, n) {
    if (t.stateNonFungibleIdsRequest === null || t.stateNonFungibleIdsRequest === void 0)
      throw new _e("stateNonFungibleIdsRequest", "Required parameter requestParameters.stateNonFungibleIdsRequest was null or undefined when calling nonFungibleIds.");
    const r = {}, a = {};
    a["Content-Type"] = "application/json";
    const s = await this.request({
      path: "/state/non-fungible/ids",
      method: "POST",
      headers: a,
      query: r,
      body: av(t.stateNonFungibleIdsRequest)
    }, n);
    return new me(s, (i) => sv(i));
  }
  async nonFungibleIds(t, n) {
    return await (await this.nonFungibleIdsRaw(t, n)).value();
  }
  async stateEntityDetailsRaw(t, n) {
    if (t.stateEntityDetailsRequest === null || t.stateEntityDetailsRequest === void 0)
      throw new _e("stateEntityDetailsRequest", "Required parameter requestParameters.stateEntityDetailsRequest was null or undefined when calling stateEntityDetails.");
    const r = {}, a = {};
    a["Content-Type"] = "application/json";
    const s = await this.request({
      path: "/state/entity/details",
      method: "POST",
      headers: a,
      query: r,
      body: hy(t.stateEntityDetailsRequest)
    }, n);
    return new me(s, (i) => Ay(i));
  }
  async stateEntityDetails(t, n) {
    return await (await this.stateEntityDetailsRaw(t, n)).value();
  }
  async stateValidatorsListRaw(t, n) {
    if (t.stateValidatorsListRequest === null || t.stateValidatorsListRequest === void 0)
      throw new _e("stateValidatorsListRequest", "Required parameter requestParameters.stateValidatorsListRequest was null or undefined when calling stateValidatorsList.");
    const r = {}, a = {};
    a["Content-Type"] = "application/json";
    const s = await this.request({
      path: "/state/validators/list",
      method: "POST",
      headers: a,
      query: r,
      body: ov(t.stateValidatorsListRequest)
    }, n);
    return new me(s, (i) => mv(i));
  }
  async stateValidatorsList(t, n) {
    return await (await this.stateValidatorsListRaw(t, n)).value();
  }
}
class zv extends Yr {
  async gatewayStatusRaw(t) {
    const n = {}, r = {}, a = await this.request({
      path: "/status/gateway-status",
      method: "POST",
      headers: r,
      query: n
    }, t);
    return new me(a, (s) => Wm(s));
  }
  async gatewayStatus(t) {
    return await (await this.gatewayStatusRaw(t)).value();
  }
  async networkConfigurationRaw(t) {
    const n = {}, r = {}, a = await this.request({
      path: "/status/network-configuration",
      method: "POST",
      headers: r,
      query: n
    }, t);
    return new me(a, (s) => Hm(s));
  }
  async networkConfiguration(t) {
    return await (await this.networkConfigurationRaw(t)).value();
  }
}
class Uv extends Yr {
  async transactionCommittedDetailsRaw(t, n) {
    if (t.transactionCommittedDetailsRequest === null || t.transactionCommittedDetailsRequest === void 0)
      throw new _e("transactionCommittedDetailsRequest", "Required parameter requestParameters.transactionCommittedDetailsRequest was null or undefined when calling transactionCommittedDetails.");
    const r = {}, a = {};
    a["Content-Type"] = "application/json";
    const s = await this.request({
      path: "/transaction/committed-details",
      method: "POST",
      headers: a,
      query: r,
      body: wv(t.transactionCommittedDetailsRequest)
    }, n);
    return new me(s, (i) => xv(i));
  }
  async transactionCommittedDetails(t, n) {
    return await (await this.transactionCommittedDetailsRaw(t, n)).value();
  }
  async transactionConstructionRaw(t) {
    const n = {}, r = {}, a = await this.request({
      path: "/transaction/construction",
      method: "POST",
      headers: r,
      query: n
    }, t);
    return new me(a, (s) => Sv(s));
  }
  async transactionConstruction(t) {
    return await (await this.transactionConstructionRaw(t)).value();
  }
  async transactionPreviewRaw(t, n) {
    if (t.transactionPreviewRequest === null || t.transactionPreviewRequest === void 0)
      throw new _e("transactionPreviewRequest", "Required parameter requestParameters.transactionPreviewRequest was null or undefined when calling transactionPreview.");
    const r = {}, a = {};
    a["Content-Type"] = "application/json";
    const s = await this.request({
      path: "/transaction/preview",
      method: "POST",
      headers: a,
      query: r,
      body: Ov(t.transactionPreviewRequest)
    }, n);
    return new me(s, (i) => Av(i));
  }
  async transactionPreview(t, n) {
    return await (await this.transactionPreviewRaw(t, n)).value();
  }
  async transactionStatusRaw(t, n) {
    if (t.transactionStatusRequest === null || t.transactionStatusRequest === void 0)
      throw new _e("transactionStatusRequest", "Required parameter requestParameters.transactionStatusRequest was null or undefined when calling transactionStatus.");
    const r = {}, a = {};
    a["Content-Type"] = "application/json";
    const s = await this.request({
      path: "/transaction/status",
      method: "POST",
      headers: a,
      query: r,
      body: Rv(t.transactionStatusRequest)
    }, n);
    return new me(s, (i) => jv(i));
  }
  async transactionStatus(t, n) {
    return await (await this.transactionStatusRaw(t, n)).value();
  }
  async transactionSubmitRaw(t, n) {
    if (t.transactionSubmitRequest === null || t.transactionSubmitRequest === void 0)
      throw new _e("transactionSubmitRequest", "Required parameter requestParameters.transactionSubmitRequest was null or undefined when calling transactionSubmit.");
    const r = {}, a = {};
    a["Content-Type"] = "application/json";
    const s = await this.request({
      path: "/transaction/submit",
      method: "POST",
      headers: a,
      query: r,
      body: $v(t.transactionSubmitRequest)
    }, n);
    return new me(s, (i) => Lv(i));
  }
  async transactionSubmit(t, n) {
    return await (await this.transactionSubmitRaw(t, n)).value();
  }
}
const oo = (e, t) => {
  const n = [];
  for (let r = 0, a = e.length; r < a; r += t)
    n.push(e.slice(r, r + t));
  return n;
}, Sa = async (e, t) => {
  let n = t;
  const r = [];
  do {
    const a = await e(n);
    r.push(...a.items), n = a.next_cursor;
  } while (n);
  return r;
};
class Vv {
  constructor(t, n) {
    this.innerClient = t, this.configuration = n;
  }
  async getEntityDetailsVaultAggregated(t, n) {
    var r, a, s, i, o;
    const c = Array.isArray(t);
    if (c && t.length === 0)
      return Promise.resolve([]);
    if (c && t.length > this.configuration.maxAddressesCount) {
      const d = oo(t, this.configuration.maxAddressesCount);
      return Promise.all(
        d.map((h) => this.getEntityDetailsVaultAggregated(h))
      ).then((h) => h.flat());
    }
    const { items: u } = await this.innerClient.stateEntityDetails({
      stateEntityDetailsRequest: {
        addresses: c ? t : [t],
        aggregation_level: Fm.Vault,
        opt_ins: {
          ancestor_identities: (r = n == null ? void 0 : n.ancestorIdentities) != null ? r : !1,
          component_royalty_vault_balance: (a = n == null ? void 0 : n.componentRoyaltyVaultBalance) != null ? a : !1,
          package_royalty_vault_balance: (s = n == null ? void 0 : n.packageRoyaltyVaultBalance) != null ? s : !1,
          non_fungible_include_nfids: (i = n == null ? void 0 : n.nonFungibleIncludeNfids) != null ? i : !0,
          explicit_metadata: (o = n == null ? void 0 : n.explicitMetadata) != null ? o : []
        }
      }
    });
    return c ? u : u[0];
  }
  async getEntityMetadata(t, n) {
    return this.innerClient.entityMetadataPage({
      stateEntityMetadataPageRequest: {
        address: t,
        cursor: n
      }
    });
  }
  async getAllEntityMetadata(t, n) {
    return Sa(
      this.getEntityMetadata.bind(this, t),
      n
    );
  }
  async getValidators(t) {
    return this.innerClient.stateValidatorsList({
      stateValidatorsListRequest: {
        cursor: t || null
      }
    }).then(({ validators: n }) => n);
  }
  async getAllValidators(t) {
    return Sa(this.getValidators.bind(this), t);
  }
  async getNonFungibleIds(t, n) {
    return this.innerClient.nonFungibleIds({
      stateNonFungibleIdsRequest: {
        resource_address: t,
        cursor: n
      }
    }).then(({ non_fungible_ids: r }) => r);
  }
  async getAllNonFungibleIds(t, n) {
    return Sa(
      this.getNonFungibleIds.bind(this, t),
      n
    );
  }
  async getNonFungibleData(t, n) {
    const r = Array.isArray(n);
    if (r && n.length === 0)
      return Promise.resolve([]);
    if (r && n.length > this.configuration.maxNftIdsCount) {
      const s = oo(n, this.configuration.maxNftIdsCount);
      return Promise.all(
        s.map((i) => this.getNonFungibleData(t, i))
      ).then((i) => i.flat());
    }
    const { non_fungible_ids: a } = await this.innerClient.nonFungibleData({
      stateNonFungibleDataRequest: {
        resource_address: t,
        non_fungible_ids: r ? n : [n]
      }
    });
    return r ? a : a[0];
  }
}
class Wv {
  constructor(t) {
    this.innerClient = t;
  }
  getCurrent() {
    return this.innerClient.gatewayStatus();
  }
  getNetworkConfiguration() {
    return this.innerClient.networkConfiguration();
  }
}
class Bv {
  constructor(t) {
    this.innerClient = t;
  }
  getTransactionsList(t, n) {
    return this.innerClient.streamTransactions({
      streamTransactionsRequest: {
        cursor: n,
        affected_global_entities_filter: t
      }
    });
  }
}
class Kv {
  constructor(t) {
    this.innerClient = t;
  }
  getStatus(t) {
    return this.innerClient.transactionStatus({
      transactionStatusRequest: {
        intent_hash_hex: t
      }
    });
  }
  getCommittedDetails(t, n) {
    var r, a, s, i, o;
    return this.innerClient.transactionCommittedDetails({
      transactionCommittedDetailsRequest: {
        intent_hash_hex: t,
        opt_ins: {
          raw_hex: (r = n == null ? void 0 : n.rawHex) != null ? r : !0,
          receipt_events: (a = n == null ? void 0 : n.receiptEvents) != null ? a : !0,
          receipt_fee_summary: (s = n == null ? void 0 : n.receiptFeeSummary) != null ? s : !0,
          receipt_state_changes: (i = n == null ? void 0 : n.receiptStateChanges) != null ? i : !0,
          affected_global_entities: (o = n == null ? void 0 : n.affectedGlobalEntities) != null ? o : !0
        }
      }
    });
  }
}
const Gv = 20, Hv = 29;
class Jv extends qu {
  constructor(t) {
    super(t), Xe(this, "extendedConfiguration"), this.extendedConfiguration = t;
  }
  get maxAddressesCount() {
    return this.extendedConfiguration.maxAddressesCount || Gv;
  }
  get maxNftIdsCount() {
    return this.extendedConfiguration.maxNftIdsCount || Hv;
  }
}
const Yv = (e) => e ? e.endsWith("/") ? e == null ? void 0 : e.slice(0, -1) : e : "", Mt = {
  Mainnet: 1,
  Stokenet: 2,
  Alphanet: 10,
  Betanet: 11,
  Kisharnet: 12,
  Ansharnet: 13,
  Gilganet: 32,
  Enkinet: 33,
  Hammunet: 34,
  Nergalnet: 35,
  Mardunet: 36,
  LocalNet: 240,
  InternalTestNet: 241,
  Simulator: 242,
  RCnetV1: 12,
  RCnetV2: 13
}, Xv = {
  Kisharnet: {
    networkName: "Kisharnet",
    networkId: Mt.Kisharnet,
    gatewayUrl: "https://kisharnet-gateway.radixdlt.com",
    dashboardUrl: "https://kisharnet-dashboard.radixdlt.com"
  },
  Ansharnet: {
    networkName: "Ansharnet",
    networkId: Mt.Ansharnet,
    gatewayUrl: "https://ansharnet-gateway.radixdlt.com",
    dashboardUrl: "https://ansharnet-dashboard.radixdlt.com"
  },
  Gilganet: {
    networkName: "Gilganet",
    networkId: Mt.Gilganet,
    gatewayUrl: "https://gilganet-gateway.radixdlt.com",
    dashboardUrl: ""
  },
  Enkinet: {
    networkName: "Enkinet",
    networkId: Mt.Enkinet,
    gatewayUrl: "https://enkinet-gateway.radixdlt.com",
    dashboardUrl: "https://enkinet-dashboard.rdx-works-main.extratools.works"
  },
  Hammunet: {
    networkName: "Hammunet",
    networkId: Mt.Hammunet,
    gatewayUrl: "https://hammunet-gateway.radixdlt.com:443",
    dashboardUrl: "https://hammunet-dashboard.rdx-works-main.extratools.works"
  },
  RCnetV1: {
    networkName: "RCnetV1",
    networkId: Mt.RCnetV1,
    gatewayUrl: "https://rcnet.radixdlt.com",
    dashboardUrl: "https://rcnet-dashboard.radixdlt.com"
  },
  RCnetV2: {
    networkName: "RCNetV2",
    networkId: Mt.RCnetV2,
    gatewayUrl: "https://ansharnet-gateway.radixdlt.com",
    dashboardUrl: "https://rcnet-v2-dashboard.radixdlt.com"
  }
}, uo = Object.values(Xv).reduce(
  (e, t) => (e[t.networkId] = t, e),
  {}
);
class Zr {
  constructor(t) {
    Xe(this, "state"), Xe(this, "stream"), Xe(this, "status"), Xe(this, "transaction"), Xe(this, "lowLevel"), this.lowLevel = {
      state: new Fv(t),
      stream: new Zv(t),
      status: new zv(t),
      transaction: new Uv(t)
    }, this.state = new Vv(this.lowLevel.state, t), this.stream = new Bv(this.lowLevel.stream), this.status = new Wv(this.lowLevel.status), this.transaction = new Kv(this.lowLevel.transaction);
  }
  static initialize(t) {
    const n = Zr.constructConfiguration(t);
    return new Zr(n);
  }
  static constructConfiguration(t) {
    var n;
    const r = Yv(t == null ? void 0 : t.basePath);
    return new Jv({
      ...t,
      basePath: r,
      headers: {
        ...(n = t == null ? void 0 : t.headers) != null ? n : {},
        ...t != null && t.dAppDefinitionAddress ? { "dapp-definition-address": t.dAppDefinitionAddress } : {}
      }
    });
  }
}
const ht = (e) => e, Qv = ({
  basePath: e
}) => {
  const { transaction: t, state: n, status: r } = Zr.initialize({
    basePath: e
  });
  return {
    getTransactionStatus: (d) => fe.fromPromise(
      t.getStatus(d),
      ht
    ),
    getTransactionDetails: (d) => fe.fromPromise(
      t.getCommittedDetails(d),
      ht
    ),
    getEntityDetails: (d) => fe.fromPromise(
      n.getEntityDetailsVaultAggregated(d),
      ht
    ),
    getEntitiesDetails: (d) => fe.fromPromise(
      n.getEntityDetailsVaultAggregated(d),
      ht
    ),
    getEntityNonFungibleIds: ({
      accountAddress: d,
      nftAddress: h,
      vaultAddress: p
    }) => fe.fromPromise(
      n.innerClient.entityNonFungibleIdsPage({
        stateEntityNonFungibleIdsPageRequest: {
          address: d,
          vault_address: p,
          resource_address: h
        }
      }),
      ht
    ),
    getNetworkConfiguration: () => fe.fromPromise(r.getNetworkConfiguration(), ht),
    transactionApi: t,
    stateApi: n,
    statusApi: r
  };
}, eg = ({
  maxDelayTime: e = 1e4,
  multiplier: t = 3,
  timeout: n,
  interval: r = 1e3
} = {}) => {
  const a = new Ze();
  let s = 0;
  const i = vr(
    Io(0),
    a.pipe(
      Qe(() => (s = s + 1, s))
    )
  ).pipe(
    yt((c) => {
      const u = c * r * t, d = u > e ? e : u;
      return Aa(d).pipe(Qe(() => ge(c)));
    })
  ), o = n ? vr(
    i,
    Aa(n).pipe(
      Qe(() => vt(Xt("failedToPollSubmittedTransaction", "")))
    )
  ) : i;
  return { trigger: a, withBackoff$: o };
}, tg = (e) => {
  var n;
  const t = (n = e == null ? void 0 : e.value) == null ? void 0 : n.typed;
  return {
    stringified: t != null && t.value ? (t == null ? void 0 : t.value) || "" : t == null ? void 0 : t.values.join(", ")
  };
}, ng = ({
  gatewayApi: e,
  logger: t,
  retryConfig: n
}) => ({ pollTransactionStatus: (a) => {
  const s = eg(n), i = /* @__PURE__ */ new Set([
    "CommittedSuccess",
    "CommittedFailure",
    "Rejected"
  ]);
  return fe.fromPromise(
    Ca(
      s.withBackoff$.pipe(
        yt((o) => o.isErr() ? [o] : (t == null || t.debug(`pollingTxStatus retry #${o.value + 1}`), e.getTransactionStatus(a).map((c) => {
          if (i.has(c.status))
            return c;
          s.trigger.next();
        }).mapErr((c) => (t == null || t.debug(c), Xt("failedToPollSubmittedTransaction", ""))))),
        _t(
          (o) => o.isOk() && !!o.value || o.isErr()
        ),
        No()
      )
    ),
    (o) => o
  ).andThen((o) => o);
}, gatewayApi: e }), rg = () => ({
  initialized: new se(!1),
  onChange: new Ze(),
  items: new se([])
}), ag = (e, t, n) => {
  const r = n.logger, a = /* @__PURE__ */ new Set(), s = new ut(), i = /* @__PURE__ */ new Map(), o = n.subjects || rg(), c = `${e}:requestItemStore`;
  t.getData(c).map((b) => {
    b && Object.keys(b).forEach((R) => {
      a.add(R), i.set(R, b[R]);
    }), o.items.next(I());
  });
  const u = (b, R) => o.onChange.next({ oldValue: b, newValue: R }), d = (b) => ({
    type: b,
    status: "pending",
    timestamp: Date.now(),
    id: crypto.randomUUID(),
    showCancel: !0
  }), h = (b) => {
    const R = d(b);
    return i.set(R.id, R), a.add(R.id), u(void 0, R), r == null || r.trace("addRequestItem", {
      id: R.id,
      status: R.status
    }), R;
  }, p = (b) => {
    if (i.has(b)) {
      const R = i.get(b);
      i.delete(b), a.delete(b), u(R, void 0), r == null || r.trace("removeRequestItem", b);
    }
  }, v = (b, R) => {
    const Q = i.get(b);
    if (Q) {
      const $ = {
        ...Q,
        ...R
      };
      i.set(b, $), u(Q, $), r == null || r.trace("patchRequestItemStatus", $);
    }
  }, T = (b) => {
    i.has(b) && (v(b, { status: "fail", error: $n.canceledByUser }), r == null || r.trace("cancelRequestItem", b));
  }, g = () => {
    i.clear(), a.clear(), u(void 0, void 0), r == null || r.trace("resetRequestItems");
  }, D = ({
    id: b,
    status: R,
    error: Q,
    transactionIntentHash: $
  }) => {
    const A = i.get(b);
    if (A) {
      const te = {
        ...A,
        status: R
      };
      te.status === "fail" && (te.error = Q), te.status === "success" && te.type === "sendTransaction" && (te.transactionIntentHash = $), i.set(b, te), u(A, te), r == null || r.trace("updateRequestItemStatus", te);
    }
  }, j = () => [...a].reverse(), I = () => j().map((b) => ({ id: b, ...i.get(b) })).filter((b) => !!b);
  return s.add(
    o.onChange.pipe(
      Qe(() => I()),
      B((b) => o.items.next(b)),
      B(() => {
        const b = Array.from(i.entries());
        t.setData(
          c,
          Object.fromEntries(
            b.filter(([, R]) => R.status !== "pending")
          )
        );
      })
    ).subscribe()
  ), {
    add: h,
    remove: p,
    cancel: T,
    updateStatus: D,
    patch: v,
    reset: g,
    destroy: () => {
      s.unsubscribe();
    },
    items$: o.items.asObservable(),
    change$: o.onChange.asObservable()
  };
}, sg = (e) => {
  try {
    return ge(JSON.parse(e));
  } catch (t) {
    return vt(ht(t));
  }
}, ig = () => {
  const e = (n) => new Promise((r, a) => {
    try {
      const s = localStorage.getItem(n);
      return r(s || void 0);
    } catch (s) {
      return a(s);
    }
  }), t = (n, r) => new Promise((a, s) => {
    try {
      return localStorage.setItem(n, JSON.stringify(r)), a();
    } catch (i) {
      return s(i);
    }
  });
  return {
    getData: (n) => fe.fromPromise(e(n), ht).andThen(
      (r) => r ? sg(r) : ge(void 0)
    ),
    setData: (n, r) => fe.fromPromise(t(n, r), ht)
  };
}, og = (e) => (t) => {
  var r, a, s;
  let n = [];
  if (e.discriminator === "authorizedRequest") {
    const i = ((r = e.oneTimeAccounts) == null ? void 0 : r.accounts) ?? [], o = ((a = e.ongoingAccounts) == null ? void 0 : a.accounts) ?? [];
    n = [...i, ...o];
  } else
    e.discriminator === "unauthorizedRequest" && (n = ((s = e.oneTimeAccounts) == null ? void 0 : s.accounts) ?? []);
  return ie(t, (i) => {
    i.accounts = n;
  });
}, Ta = (e) => {
  const t = [];
  return e.name && t.push({
    entry: "fullName",
    fields: e.name
  }), e.emailAddresses && t.push({
    entry: "emailAddresses",
    fields: e.emailAddresses
  }), e.phoneNumbers && t.push({
    entry: "phoneNumbers",
    fields: e.phoneNumbers
  }), t;
}, ug = (e) => (t) => ie(t, (n) => {
  e.discriminator === "authorizedRequest" ? (e.oneTimePersonaData && (n.personaData = Ta(e.oneTimePersonaData)), e.ongoingPersonaData && (n.personaData = Ta(e.ongoingPersonaData))) : e.discriminator === "unauthorizedRequest" && e.oneTimePersonaData && (n.personaData = Ta(e.oneTimePersonaData));
}), cg = (e) => (t) => ie(t, (n) => {
  var r;
  e.discriminator === "authorizedRequest" && (n.persona = (r = e.auth) == null ? void 0 : r.persona);
}), lg = (e) => (t) => ie(t, (n) => {
  var r, a, s, i, o, c;
  if (n.proofs = [], e.discriminator === "authorizedRequest") {
    if (e.auth.discriminator === "loginWithChallenge" && n.proofs.push({
      challenge: e.auth.challenge,
      proof: e.auth.proof,
      address: e.auth.persona.identityAddress,
      type: hn.persona
    }), (r = e.ongoingAccounts) != null && r.challenge && ((a = e.ongoingAccounts.proofs) != null && a.length)) {
      const u = e.ongoingAccounts.challenge, d = e.ongoingAccounts.proofs.map(
        ({ accountAddress: h, proof: p }) => ({
          proof: p,
          address: h,
          challenge: u,
          type: hn.account
        })
      );
      n.proofs.push(...d);
    }
    if ((s = e.oneTimeAccounts) != null && s.challenge && ((i = e.oneTimeAccounts.proofs) != null && i.length)) {
      const u = e.oneTimeAccounts.challenge, d = e.oneTimeAccounts.proofs.map(
        ({ accountAddress: h, proof: p }) => ({
          proof: p,
          address: h,
          challenge: u,
          type: hn.account
        })
      );
      n.proofs.push(...d);
    }
  }
  if (e.discriminator === "unauthorizedRequest" && (o = e.oneTimeAccounts) != null && o.challenge && (c = e.oneTimeAccounts.proofs) != null && c.length) {
    const u = e.oneTimeAccounts.challenge, d = e.oneTimeAccounts.proofs.map(
      ({ accountAddress: h, proof: p }) => ({
        proof: p,
        address: h,
        challenge: u,
        type: hn.account
      })
    );
    n.proofs.push(...d);
  }
}), dg = (e) => ge({
  accounts: [],
  personaData: [],
  proofs: [],
  persona: void 0
}).map(og(e)).map(ug(e)).map(cg(e)).map(lg(e));
be({
  accounts: be({
    numberOfAccounts: nt,
    reset: Ye(),
    oneTime: Ye(),
    challenge: Ge().optional()
  }).optional(),
  personaData: be({
    fullName: Ye().optional(),
    phoneNumbers: nt.optional(),
    emailAddresses: nt.optional(),
    reset: Ye(),
    oneTime: Ye().optional()
  }).optional(),
  persona: be({
    identityAddress: Ge().optional(),
    label: Ge().optional(),
    challenge: Ge().optional()
  }).optional()
});
const fg = (e) => {
  const { persona: t, accounts: n, personaData: r } = e, a = !!t, s = (n == null ? void 0 : n.reset) || (r == null ? void 0 : r.reset), i = n && !(n != null && n.oneTime), o = r && !(r != null && r.oneTime);
  return !!(s || i || o || a);
}, hg = (e) => {
  var t, n, r;
  return (t = e.persona) != null && t.challenge ? {
    discriminator: "loginWithChallenge",
    challenge: e.persona.challenge
  } : (n = e.persona) != null && n.identityAddress ? {
    discriminator: "usePersona",
    identityAddress: (r = e.persona) == null ? void 0 : r.identityAddress
  } : {
    discriminator: "loginWithoutChallenge"
  };
}, Gu = (e) => (t) => {
  var a, s;
  const n = { ...t }, { accounts: r } = e;
  if (r) {
    const i = {
      challenge: r.challenge,
      numberOfAccounts: r.numberOfAccounts
    }, o = n.discriminator === "authorizedRequest" && !((a = e.accounts) != null && a.oneTime), c = n.discriminator === "authorizedRequest";
    (s = e.accounts) != null && s.oneTime ? n.oneTimeAccounts = i : (o || c) && (n.ongoingAccounts = i);
  }
  return n;
}, Hu = (e) => (t) => {
  var r, a;
  const n = { ...t };
  if (e.personaData) {
    const {
      fullName: s,
      phoneNumbers: i,
      emailAddresses: o
    } = e.personaData;
    (r = e.personaData) != null && r.oneTime && (n.oneTimePersonaData = {
      isRequestingName: s,
      numberOfRequestedPhoneNumbers: i,
      numberOfRequestedEmailAddresses: o
    });
    const c = n.discriminator === "authorizedRequest" && !((a = e.personaData) != null && a.oneTime), u = n.discriminator === "authorizedRequest";
    (c || u) && (n.ongoingPersonaData = {
      isRequestingName: s,
      numberOfRequestedPhoneNumbers: i,
      numberOfRequestedEmailAddresses: o
    });
  }
  return n;
}, pg = (e) => (t) => {
  const { accounts: n, personaData: r } = e;
  return {
    ...t,
    reset: { accounts: !!(n != null && n.reset), personaData: !!(r != null && r.reset) }
  };
}, mg = (e) => ge({
  discriminator: "unauthorizedRequest"
}).map(Gu(e)).map(Hu(e)), yg = (e) => ge({
  discriminator: "authorizedRequest",
  auth: hg(e)
}).map(Gu(e)).map(Hu(e)).map(pg(e)), vg = (e, t) => ge(
  e ? ie(t, (n) => {
    n.accounts && (n.accounts.oneTime = !1, n.accounts.reset = !1), n.personaData && (n.personaData.oneTime = !1, n.personaData.reset = !1);
  }) : t
), gg = (e, t) => vg(e, t).andThen(
  (n) => fg(n) ? yg(n) : mg(n)
), _g = ({
  dataRequestState: e,
  isConnect: t,
  challenge: n,
  oneTime: r,
  stateClient: a
}) => gg(
  t,
  ie({}, (s) => {
    var i;
    if (e.accounts && (s.accounts = {
      numberOfAccounts: e.accounts.numberOfAccounts || {
        quantifier: "atLeast",
        quantity: 1
      },
      oneTime: r,
      reset: !!e.accounts.reset,
      challenge: e.accounts.withProof ? n : void 0
    }), e.personaData && (s.personaData = {
      ...e.personaData,
      reset: !!e.personaData.reset,
      oneTime: r
    }), !r) {
      const o = a.getState().walletData.persona;
      a.getState().walletData.persona && (s.persona = o), (i = e.persona) != null && i.withProof && (s.persona = { ...s.persona ?? {}, challenge: n }), Object.values(e).length === 0 && (s.persona = { challenge: void 0 });
    }
  })
), bg = (e, t) => {
  var n, r, a, s, i, o, c, u, d;
  if (e.discriminator === "authorizedRequest") {
    const h = ((n = e.reset) == null ? void 0 : n.accounts) || ((r = e.reset) == null ? void 0 : r.personaData), p = !!(e.oneTimeAccounts || e.oneTimePersonaData), v = e.auth.discriminator === "loginWithChallenge" || !!((a = e.oneTimeAccounts) != null && a.challenge) || !!((s = e.ongoingAccounts) != null && s.challenge);
    if (h || p || v)
      return !1;
    let T = !1;
    if (e.ongoingAccounts) {
      const { quantifier: g, quantity: D } = e.ongoingAccounts.numberOfAccounts;
      T = ((o = (i = t.sharedData) == null ? void 0 : i.ongoingAccounts) == null ? void 0 : o.quantifier) === g && ((u = (c = t.sharedData) == null ? void 0 : c.ongoingAccounts) == null ? void 0 : u.quantity) === D;
    }
    return e.ongoingPersonaData && (T = ws(
      e.ongoingPersonaData,
      (d = t.sharedData) == null ? void 0 : d.ongoingPersonaData
    )), T;
  }
  return !1;
}, wg = (e, t) => e.discriminator === "authorizedRequest" ? ie({}, (n) => {
  e.ongoingAccounts && (n.ongoingAccounts = e.ongoingAccounts.numberOfAccounts), e.ongoingPersonaData && (n.ongoingPersonaData = e.ongoingPersonaData);
}) : t, xg = (e) => ie({}, (t) => {
  e.ongoingAccounts && (t.accounts = {
    numberOfAccounts: e.ongoingAccounts,
    withProof: !1,
    reset: !0
  }), e.ongoingPersonaData && (t.personaData = {
    ...e.ongoingPersonaData,
    reset: !0
  });
}), kg = ({
  stateClient: e,
  requestItemClient: t,
  walletClient: n,
  useCache: r,
  dataRequestStateClient: a
}) => {
  let s, i;
  const o = (g) => {
    var D, j;
    return ((D = g.accounts) == null ? void 0 : D.withProof) || ((j = g.persona) == null ? void 0 : j.withProof);
  }, c = (g) => {
    if (!o(g))
      return Qi(void 0);
    if (!s)
      throw new Error("Expected proof but no challenge generator provided");
    return s();
  }, u = (g) => {
    s = () => fe.fromPromise(g(), () => ({
      error: "GenerateChallengeError",
      message: "Failed to generate challenge"
    }));
  }, d = (g) => {
    i = (D) => fe.fromPromise(g(D), () => ({
      error: "LoginRejectedByDapp",
      message: "Login rejected by dApp"
    }));
  }, h = (...g) => p({
    dataRequestState: a.toDataRequestState(...g),
    isConnect: !1,
    oneTime: !0
  }), p = ({
    isConnect: g,
    oneTime: D,
    dataRequestState: j
  }) => ge(j).asyncAndThen(
    (I) => c(I).andThen(
      (b) => _g({
        dataRequestState: I,
        isConnect: g,
        challenge: b,
        oneTime: D,
        stateClient: e
      })
    )
  ).andThen((I) => {
    const b = e.getState();
    if (bg(I, b) && r)
      return Qi(b.walletData);
    const R = !e.getState().walletData.persona && I.discriminator === "authorizedRequest", { id: Q } = t.add(
      R ? "loginRequest" : "dataRequest"
    );
    return n.request(I, Q).mapErr(
      ({ error: $, message: A }) => ({
        error: $,
        message: A
      })
    ).andThen(dg).andThen(($) => i ? i($).map(() => (t.updateStatus({ id: Q, status: "success" }), $)).mapErr((A) => (t.updateStatus({
      id: Q,
      status: "fail",
      error: A.error
    }), A)) : (t.updateStatus({ id: Q, status: "success" }), ge($))).map(($) => (D || e.setState({
      loggedInTimestamp: Date.now().toString(),
      walletData: $,
      sharedData: wg(
        I,
        e.getState().sharedData
      )
    }), $));
  });
  return {
    provideChallengeGenerator: u,
    provideDataRequestControl: d,
    sendOneTimeRequest: h,
    setState: (...g) => (a.setState(...g), {
      sendRequest: () => p({
        dataRequestState: a.getState(),
        isConnect: !1,
        oneTime: !1
      })
    }),
    sendRequest: ({
      isConnect: g,
      oneTime: D
    }) => p({
      isConnect: g,
      oneTime: D,
      dataRequestState: a.getState()
    }),
    updateSharedData: () => p({
      dataRequestState: xg(
        e.getState().sharedData
      ),
      isConnect: !1,
      oneTime: !1
    })
  };
}, Sg = (e) => {
  var s;
  const t = e.accounts ?? [], n = ((s = e == null ? void 0 : e.persona) == null ? void 0 : s.label) ?? "", r = !!(e != null && e.persona), a = e.personaData.map((i) => {
    if (i.entry === "fullName") {
      const { variant: o, givenNames: c, familyName: u, nickname: d } = i.fields;
      return {
        value: o === "western" ? `${c}${d ? ` "${d}" ` : " "}${u}` : `${u}${d ? ` "${d}" ` : " "}${c}`,
        field: "fullName"
      };
    } else {
      if (i.entry === "emailAddresses")
        return {
          // currently only one email address is supported
          value: i.fields[0],
          field: "emailAddress"
        };
      if (i.entry === "phoneNumbers")
        return {
          // currently only one phone number is supported
          value: i.fields[0],
          field: "phoneNumber"
        };
    }
  }).filter(
    (i) => !!i && !!i.value.trim()
  );
  return { accounts: t, personaLabel: n, connected: r, personaData: a };
}, Tg = (e) => {
  const t = new se(e), n = () => t.next(e), r = (u) => t.next(u), a = () => t.getValue(), s = (...u) => u.filter((d) => typeof d._toObject == "function").reduce(
    (d, h) => ({
      ...d,
      ...h._toObject()
    }),
    {}
  );
  return {
    reset: n,
    setState: (...u) => {
      u.length === 0 ? n() : r(s(...u));
    },
    getState: a,
    patchState: (...u) => {
      u.length !== 0 && r({ ...a(), ...s(...u) });
    },
    removeState: (...u) => {
      r(
        ie(a(), (d) => {
          u.forEach((h) => {
            delete d[h];
          });
        })
      );
    },
    toDataRequestState: s,
    state$: t.asObservable()
  };
}, Hg = (e) => {
  const {
    dAppDefinitionAddress: t,
    networkId: n,
    providers: r,
    logger: a,
    onDisconnect: s,
    explorer: i,
    gatewayBaseUrl: o,
    useCache: c = !0
  } = e || {}, u = `rdt:${t}:${n}`, d = new se(
    t
  ), h = new ut(), p = (r == null ? void 0 : r.connectButton) ?? Pp({
    logger: a
  });
  p.setIsMobile(Tp());
  const v = (r == null ? void 0 : r.gatewayClient) ?? ng({
    logger: a,
    gatewayApi: Qv({
      basePath: o ?? uo[n].gatewayUrl,
      dAppDefinitionAddress: t
    })
  }), T = (r == null ? void 0 : r.storageClient) ?? ig(), g = (r == null ? void 0 : r.walletSdk) ?? Dh({
    logger: a,
    networkId: n,
    dAppDefinitionAddress: t
  }), D = (r == null ? void 0 : r.requestItemClient) ?? ag(u, T, {
    logger: a
  }), j = (r == null ? void 0 : r.walletClient) ?? Op({
    logger: a,
    onCancelRequestItem$: p.onCancelRequestItem$,
    walletSdk: g,
    gatewayClient: v,
    requestItemClient: D
  }), I = (r == null ? void 0 : r.stateClient) ?? kp(u, T, {
    logger: a
  }), b = (r == null ? void 0 : r.dataRequestStateClient) ?? Tg({}), R = (r == null ? void 0 : r.dataRequestClient) ?? kg({
    stateClient: I,
    requestItemClient: D,
    walletClient: j,
    useCache: c,
    dataRequestStateClient: b
  });
  h.add(
    d.pipe(
      _t((K) => !!K),
      yt(
        (K) => v.gatewayApi.getEntityDetails(K).map(
          (le) => tg(
            le == null ? void 0 : le.metadata.items.find((he) => he.key === "name")
          ).stringified
        ).map((le) => {
          p.setDappName(le ?? "Unnamed dApp");
        })
      )
    ).subscribe()
  ), h.add(
    j.extensionStatus$.pipe(
      B((K) => {
        p.setIsExtensionAvailable(
          K.isExtensionAvailable
        ), p.setIsWalletLinked(K.isWalletLinked);
      })
    ).subscribe()
  ), h.add(
    p.onConnect$.pipe(
      yt(() => (I.reset(), R.sendRequest({
        isConnect: !0,
        oneTime: !1
      })))
    ).subscribe()
  ), h.add(
    p.onLinkClick$.pipe(
      B(({ type: K, data: le }) => {
        if (["account", "transaction"].includes(K)) {
          const { baseUrl: he, transactionPath: L, accountsPath: Be } = i ?? {
            baseUrl: uo[n].dashboardUrl,
            transactionPath: "/transaction/",
            accountsPath: "/account/"
          };
          if (!he || !window)
            return;
          const Jn = `${he}${K === "transaction" ? L : Be}${le}`;
          window.open(Jn);
        } else
          K === "setupGuide" ? window.open(
            "https://docs-babylon.radixdlt.com/main/getting-started-developers/wallet/wallet-and-connector-installation.html"
          ) : K === "showQrCode" && g.openPopup();
      })
    ).subscribe()
  ), h.add(
    p.onShowPopover$.pipe(
      da(j.requestItems$),
      B(([K, le]) => {
        le.filter((he) => he.status === "pending").length > 0 && p.setActiveTab("requests");
      })
    ).subscribe()
  ), h.add(
    p.onDisconnect$.pipe(
      B(() => {
        I.reset(), j.resetRequestItems(), s && s();
      })
    ).subscribe()
  ), h.add(
    I.state$.pipe(
      B((K) => {
        const { personaData: le, accounts: he, personaLabel: L, connected: Be } = Sg(K.walletData);
        p.setLoggedInTimestamp(K.loggedInTimestamp), p.setAccounts(he), p.setPersonaData(le), p.setPersonaLabel(L), p.setConnected(Be);
      })
    ).subscribe()
  ), h.add(
    j.requestItems$.pipe(B((K) => p.setRequestItems(K))).subscribe()
  ), h.add(
    D.change$.pipe(
      da(D.items$),
      B(([, K]) => {
        K.find((he) => he.status === "pending") && p.setStatus("pending");
      }),
      zr(([K]) => {
        var L, Be;
        const le = (L = K.newValue) == null ? void 0 : L.status;
        return ((Be = K.oldValue) == null ? void 0 : Be.status) === "pending" && (le === "success" || le === "fail") ? (p.setStatus(
          le === "success" ? "success" : "error"
        ), Aa(2e3).pipe(
          da(j.requestItems$),
          B(([Jn, Xr]) => {
            const Qr = Xr.find(
              (ea) => ea.status === "pending"
            );
            p.setStatus(
              Qr ? "pending" : "default"
            );
          })
        )) : Io();
      })
    ).subscribe()
  ), h.add(
    vr(p.onUpdateSharedData$).pipe(yt(() => R.updateSharedData())).subscribe()
  );
  const Q = {
    state: v.gatewayApi.stateApi,
    status: v.gatewayApi.statusApi,
    transaction: v.gatewayApi.transactionApi
  }, $ = {
    setRequestData: R.setState,
    sendRequest: () => R.sendRequest({
      isConnect: !1,
      oneTime: !1
    }),
    provideChallengeGenerator: (K) => R.provideChallengeGenerator(K),
    dataRequestControl: (K) => {
      R.provideDataRequestControl(K);
    },
    updateSharedData: () => R.updateSharedData(),
    sendOneTimeRequest: R.sendOneTimeRequest,
    sendTransaction: j.sendTransaction,
    walletData$: I.walletData$,
    getWalletData: () => I.getWalletData()
  }, A = {
    setTheme: p.setTheme,
    setMode: p.setMode
  };
  return {
    walletApi: $,
    gatewayApi: Q,
    buttonApi: A,
    disconnect: () => {
      j.resetRequestItems(), I.reset();
    },
    destroy: () => {
      I.destroy(), j.destroy(), h.unsubscribe(), p.destroy();
    }
  };
};
be({
  numberOfAccounts: nt,
  withProof: Ye().optional(),
  reset: Ye().optional()
});
const Ju = () => {
  let t = ie({
    numberOfAccounts: { quantifier: "atLeast", quantity: 1 }
  }, () => {
  });
  const o = {
    atLeast: (c) => (t = ie(t, (u) => {
      u.numberOfAccounts.quantifier = "atLeast", u.numberOfAccounts.quantity = c;
    }), o),
    exactly: (c) => (t = ie(t, (u) => {
      u.numberOfAccounts.quantifier = "exactly", u.numberOfAccounts.quantity = c;
    }), o),
    withProof: (c = !0) => (t = ie(t, (u) => {
      u.withProof = c;
    }), o),
    reset: (c = !0) => (t = ie(t, (u) => {
      u.reset = c;
    }), o),
    _toObject: () => ({
      accounts: t
    })
  };
  return o;
};
be({
  withProof: Ye().optional()
});
const Pg = (e = {
  withProof: !1
}) => {
  let t = ie(e, () => {
  });
  const a = {
    withProof: (s = !0) => (t = ie(t, (i) => {
      i.withProof = s;
    }), a),
    _toObject: () => ({
      persona: t
    })
  };
  return a;
};
be({
  fullName: Ye(),
  emailAddresses: nt,
  phoneNumbers: nt,
  reset: Ye()
}).partial();
const Yu = (e = {}) => {
  let t = ie(e, () => {
  });
  const n = (u = !0) => (t = ie(t, (d) => {
    d.fullName = u;
  }), c), r = (u) => ({
    atLeast: (d) => (t = ie(t, (h) => {
      h[u] = { quantifier: "atLeast", quantity: d };
    }), c),
    exactly: (d) => (t = ie(t, (h) => {
      h[u] = { quantifier: "exactly", quantity: d };
    }), c)
  }), c = {
    fullName: n,
    emailAddresses: (u = !0) => (r("emailAddresses").exactly(u ? 1 : 0), c),
    phoneNumbers: (u = !0) => (r("phoneNumbers").exactly(u ? 1 : 0), c),
    reset: (u = !0) => (t = ie(t, (d) => {
      d.reset = u;
    }), c),
    _toObject: () => ({
      personaData: t
    })
  };
  return c;
}, Og = (e) => ({
  _toObject: () => ({ ...e })
}), Jg = {
  accounts: Ju,
  personaData: Yu,
  persona: Pg,
  config: Og
}, Yg = {
  accounts: Ju,
  personaData: Yu
};
export {
  Fo as Account,
  Md as AccountProof,
  Wa as AccountsRequestItem,
  Ba as AccountsRequestResponseItem,
  Bd as AuthLoginRequestItem,
  of as AuthLoginRequestResponseItem,
  Wd as AuthLoginWithChallengeRequestItem,
  sf as AuthLoginWithChallengeRequestResponseItem,
  Vd as AuthLoginWithoutChallengeRequestItem,
  af as AuthLoginWithoutChallengeRequestResponseItem,
  Kd as AuthRequestItem,
  cf as AuthRequestResponseItem,
  Ud as AuthUsePersonaRequestItem,
  ef as CancelRequest,
  Jg as DataRequestBuilder,
  Tg as DataRequestStateClient,
  Wg as ExtensionInteraction,
  Vg as LoginRequestResponseItem,
  mf as MessageLifeCycleEvent,
  Bg as MessageLifeCycleExtensionStatusEvent,
  Uo as Metadata,
  nt as NumberOfValues,
  Yg as OneTimeDataRequestBuilder,
  Gn as Persona,
  zo as PersonaDataName,
  Zd as PersonaDataNameVariant,
  xr as PersonaDataRequestItem,
  Ka as PersonaDataRequestResponseItem,
  Kn as Proof,
  Hg as RadixDappToolkit,
  ap as RdtState,
  Fd as ResetRequestItem,
  Jd as SendTransactionItem,
  Xd as SendTransactionResponseItem,
  rp as SharedData,
  Yh as SignedChallenge,
  Jh as SignedChallengeAccount,
  Hh as SignedChallengePersona,
  Gd as WalletAuthorizedRequestItems,
  lf as WalletAuthorizedRequestResponseItems,
  np as WalletData,
  tp as WalletDataPersonaData,
  Qh as WalletDataPersonaDataEmailAddresses,
  Xh as WalletDataPersonaDataFullName,
  ep as WalletDataPersonaDataPhoneNumbersAddresses,
  nf as WalletInteraction,
  pf as WalletInteractionFailureResponse,
  tf as WalletInteractionItems,
  Vo as WalletInteractionResponse,
  hf as WalletInteractionSuccessResponse,
  Hd as WalletRequestItems,
  df as WalletRequestResponseItems,
  Dh as WalletSdk,
  Yd as WalletTransactionItems,
  zd as WalletUnauthorizedRequestItems,
  Og as config,
  Gg as createLogger,
  Xt as createSdkError,
  $n as errorType,
  ir as eventType,
  ln as messageLifeCycleEventType,
  $i as personaDataFullNameVariant,
  hn as proofType,
  vf as sdkError,
  hs as walletDataDefault,
  Kg as walletInteractionFactoryV2
};
