import "./chunk-76J2PTFD.js";

// node_modules/@radixdlt/wallet-sdk/dist/wallet-sdk.mjs
function ct(r, e, t, n) {
  function i(s) {
    return s instanceof t ? s : new t(function(a) {
      a(s);
    });
  }
  return new (t || (t = Promise))(function(s, a) {
    function o(l) {
      try {
        c(n.next(l));
      } catch (p) {
        a(p);
      }
    }
    function u(l) {
      try {
        c(n.throw(l));
      } catch (p) {
        a(p);
      }
    }
    function c(l) {
      l.done ? s(l.value) : i(l.value).then(o, u);
    }
    c((n = n.apply(r, e || [])).next());
  });
}
function ut(r, e) {
  var t = { label: 0, sent: function() {
    if (s[0] & 1)
      throw s[1];
    return s[1];
  }, trys: [], ops: [] }, n, i, s, a;
  return a = { next: o(0), throw: o(1), return: o(2) }, typeof Symbol == "function" && (a[Symbol.iterator] = function() {
    return this;
  }), a;
  function o(c) {
    return function(l) {
      return u([c, l]);
    };
  }
  function u(c) {
    if (n)
      throw new TypeError("Generator is already executing.");
    for (; t; )
      try {
        if (n = 1, i && (s = c[0] & 2 ? i.return : c[0] ? i.throw || ((s = i.return) && s.call(i), 0) : i.next) && !(s = s.call(i, c[1])).done)
          return s;
        switch (i = 0, s && (c = [c[0] & 2, s.value]), c[0]) {
          case 0:
          case 1:
            s = c;
            break;
          case 4:
            return t.label++, { value: c[1], done: false };
          case 5:
            t.label++, i = c[1], c = [0];
            continue;
          case 7:
            c = t.ops.pop(), t.trys.pop();
            continue;
          default:
            if (s = t.trys, !(s = s.length > 0 && s[s.length - 1]) && (c[0] === 6 || c[0] === 2)) {
              t = 0;
              continue;
            }
            if (c[0] === 3 && (!s || c[1] > s[0] && c[1] < s[3])) {
              t.label = c[1];
              break;
            }
            if (c[0] === 6 && t.label < s[1]) {
              t.label = s[1], s = c;
              break;
            }
            if (s && t.label < s[2]) {
              t.label = s[2], t.ops.push(c);
              break;
            }
            s[2] && t.ops.pop(), t.trys.pop();
            continue;
        }
        c = e.call(r, t);
      } catch (l) {
        c = [6, l], i = 0;
      } finally {
        n = s = 0;
      }
    if (c[0] & 5)
      throw c[1];
    return { value: c[0] ? c[1] : void 0, done: true };
  }
}
function Be(r, e) {
  var t = typeof Symbol == "function" && r[Symbol.iterator];
  if (!t)
    return r;
  var n = t.call(r), i, s = [], a;
  try {
    for (; (e === void 0 || e-- > 0) && !(i = n.next()).done; )
      s.push(i.value);
  } catch (o) {
    a = { error: o };
  } finally {
    try {
      i && !i.done && (t = n.return) && t.call(n);
    } finally {
      if (a)
        throw a.error;
    }
  }
  return s;
}
function ue(r, e, t) {
  if (t || arguments.length === 2)
    for (var n = 0, i = e.length, s; n < i; n++)
      (s || !(n in e)) && (s || (s = Array.prototype.slice.call(e, 0, n)), s[n] = e[n]);
  return r.concat(s || Array.prototype.slice.call(e));
}
var Mr = {
  withStackTrace: false
};
var lr = function(r, e, t) {
  t === void 0 && (t = Mr);
  var n = e.isOk() ? { type: "Ok", value: e.value } : { type: "Err", value: e.error }, i = t.withStackTrace ? new Error().stack : void 0;
  return {
    data: n,
    message: r,
    stack: i
  };
};
var G = (
  /** @class */
  function() {
    function r(e) {
      this._promise = e;
    }
    return r.fromSafePromise = function(e) {
      var t = e.then(function(n) {
        return new ae(n);
      });
      return new r(t);
    }, r.fromPromise = function(e, t) {
      var n = e.then(function(i) {
        return new ae(i);
      }).catch(function(i) {
        return new oe(t(i));
      });
      return new r(n);
    }, r.combine = function(e) {
      return Qr(e);
    }, r.combineWithAllErrors = function(e) {
      return en(e);
    }, r.prototype.map = function(e) {
      var t = this;
      return new r(this._promise.then(function(n) {
        return ct(t, void 0, void 0, function() {
          var i;
          return ut(this, function(s) {
            switch (s.label) {
              case 0:
                return n.isErr() ? [2, new oe(n.error)] : (i = ae.bind, [4, e(n.value)]);
              case 1:
                return [2, new (i.apply(ae, [void 0, s.sent()]))()];
            }
          });
        });
      }));
    }, r.prototype.mapErr = function(e) {
      var t = this;
      return new r(this._promise.then(function(n) {
        return ct(t, void 0, void 0, function() {
          var i;
          return ut(this, function(s) {
            switch (s.label) {
              case 0:
                return n.isOk() ? [2, new ae(n.value)] : (i = oe.bind, [4, e(n.error)]);
              case 1:
                return [2, new (i.apply(oe, [void 0, s.sent()]))()];
            }
          });
        });
      }));
    }, r.prototype.andThen = function(e) {
      return new r(this._promise.then(function(t) {
        if (t.isErr())
          return new oe(t.error);
        var n = e(t.value);
        return n instanceof r ? n._promise : n;
      }));
    }, r.prototype.orElse = function(e) {
      var t = this;
      return new r(this._promise.then(function(n) {
        return ct(t, void 0, void 0, function() {
          return ut(this, function(i) {
            return n.isErr() ? [2, e(n.error)] : [2, new ae(n.value)];
          });
        });
      }));
    }, r.prototype.match = function(e, t) {
      return this._promise.then(function(n) {
        return n.match(e, t);
      });
    }, r.prototype.unwrapOr = function(e) {
      return this._promise.then(function(t) {
        return t.unwrapOr(e);
      });
    }, r.prototype.then = function(e, t) {
      return this._promise.then(e, t);
    }, r;
  }()
);
var Jt = function(r) {
  return new G(Promise.resolve(new oe(r)));
};
G.fromPromise;
G.fromSafePromise;
var Xr = function(r) {
  return function(e) {
    return ue(ue([], Be(e), false), [r], false);
  };
};
var dr = function(r) {
  return r.reduce(function(e, t) {
    return e.isOk() ? t.isErr() ? q(t.error) : e.map(Xr(t.value)) : e;
  }, j([]));
};
var Qr = function(r) {
  return G.fromSafePromise(Promise.all(r)).andThen(dr);
};
var fr = function(r) {
  return r.reduce(function(e, t) {
    return t.isErr() ? e.isErr() ? q(ue(ue([], Be(e.error), false), [t.error], false)) : q([t.error]) : e.isErr() ? e : j(ue(ue([], Be(e.value), false), [t.value], false));
  }, j([]));
};
var en = function(r) {
  return G.fromSafePromise(Promise.all(r)).andThen(fr);
};
var vt;
(function(r) {
  function e(i, s) {
    return function() {
      for (var a = [], o = 0; o < arguments.length; o++)
        a[o] = arguments[o];
      try {
        var u = i.apply(void 0, ue([], Be(a), false));
        return j(u);
      } catch (c) {
        return q(s ? s(c) : c);
      }
    };
  }
  r.fromThrowable = e;
  function t(i) {
    return dr(i);
  }
  r.combine = t;
  function n(i) {
    return fr(i);
  }
  r.combineWithAllErrors = n;
})(vt || (vt = {}));
var j = function(r) {
  return new ae(r);
};
var q = function(r) {
  return new oe(r);
};
var ae = (
  /** @class */
  function() {
    function r(e) {
      this.value = e;
    }
    return r.prototype.isOk = function() {
      return true;
    }, r.prototype.isErr = function() {
      return !this.isOk();
    }, r.prototype.map = function(e) {
      return j(e(this.value));
    }, r.prototype.mapErr = function(e) {
      return j(this.value);
    }, r.prototype.andThen = function(e) {
      return e(this.value);
    }, r.prototype.orElse = function(e) {
      return j(this.value);
    }, r.prototype.asyncAndThen = function(e) {
      return e(this.value);
    }, r.prototype.asyncMap = function(e) {
      return G.fromSafePromise(e(this.value));
    }, r.prototype.unwrapOr = function(e) {
      return this.value;
    }, r.prototype.match = function(e, t) {
      return e(this.value);
    }, r.prototype._unsafeUnwrap = function(e) {
      return this.value;
    }, r.prototype._unsafeUnwrapErr = function(e) {
      throw lr("Called `_unsafeUnwrapErr` on an Ok", this, e);
    }, r;
  }()
);
var oe = (
  /** @class */
  function() {
    function r(e) {
      this.error = e;
    }
    return r.prototype.isOk = function() {
      return false;
    }, r.prototype.isErr = function() {
      return !this.isOk();
    }, r.prototype.map = function(e) {
      return q(this.error);
    }, r.prototype.mapErr = function(e) {
      return q(e(this.error));
    }, r.prototype.andThen = function(e) {
      return q(this.error);
    }, r.prototype.orElse = function(e) {
      return e(this.error);
    }, r.prototype.asyncAndThen = function(e) {
      return Jt(this.error);
    }, r.prototype.asyncMap = function(e) {
      return Jt(this.error);
    }, r.prototype.unwrapOr = function(e) {
      return e;
    }, r.prototype.match = function(e, t) {
      return t(this.error);
    }, r.prototype._unsafeUnwrap = function(e) {
      throw lr("Called `_unsafeUnwrap` on an Err", this, e);
    }, r.prototype._unsafeUnwrapErr = function(e) {
      return this.error;
    }, r;
  }()
);
vt.fromThrowable;
var T;
(function(r) {
  r.assertEqual = (i) => i;
  function e(i) {
  }
  r.assertIs = e;
  function t(i) {
    throw new Error();
  }
  r.assertNever = t, r.arrayToEnum = (i) => {
    const s = {};
    for (const a of i)
      s[a] = a;
    return s;
  }, r.getValidEnumValues = (i) => {
    const s = r.objectKeys(i).filter((o) => typeof i[i[o]] != "number"), a = {};
    for (const o of s)
      a[o] = i[o];
    return r.objectValues(a);
  }, r.objectValues = (i) => r.objectKeys(i).map(function(s) {
    return i[s];
  }), r.objectKeys = typeof Object.keys == "function" ? (i) => Object.keys(i) : (i) => {
    const s = [];
    for (const a in i)
      Object.prototype.hasOwnProperty.call(i, a) && s.push(a);
    return s;
  }, r.find = (i, s) => {
    for (const a of i)
      if (s(a))
        return a;
  }, r.isInteger = typeof Number.isInteger == "function" ? (i) => Number.isInteger(i) : (i) => typeof i == "number" && isFinite(i) && Math.floor(i) === i;
  function n(i, s = " | ") {
    return i.map((a) => typeof a == "string" ? `'${a}'` : a).join(s);
  }
  r.joinValues = n, r.jsonStringifyReplacer = (i, s) => typeof s == "bigint" ? s.toString() : s;
})(T || (T = {}));
var Mt;
(function(r) {
  r.mergeShapes = (e, t) => ({
    ...e,
    ...t
    // second overwrites first
  });
})(Mt || (Mt = {}));
var f = T.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]);
var ce = (r) => {
  switch (typeof r) {
    case "undefined":
      return f.undefined;
    case "string":
      return f.string;
    case "number":
      return isNaN(r) ? f.nan : f.number;
    case "boolean":
      return f.boolean;
    case "function":
      return f.function;
    case "bigint":
      return f.bigint;
    case "symbol":
      return f.symbol;
    case "object":
      return Array.isArray(r) ? f.array : r === null ? f.null : r.then && typeof r.then == "function" && r.catch && typeof r.catch == "function" ? f.promise : typeof Map < "u" && r instanceof Map ? f.map : typeof Set < "u" && r instanceof Set ? f.set : typeof Date < "u" && r instanceof Date ? f.date : f.object;
    default:
      return f.unknown;
  }
};
var d = T.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]);
var F = class extends Error {
  constructor(e) {
    super(), this.issues = [], this.addIssue = (n) => {
      this.issues = [...this.issues, n];
    }, this.addIssues = (n = []) => {
      this.issues = [...this.issues, ...n];
    };
    const t = new.target.prototype;
    Object.setPrototypeOf ? Object.setPrototypeOf(this, t) : this.__proto__ = t, this.name = "ZodError", this.issues = e;
  }
  get errors() {
    return this.issues;
  }
  format(e) {
    const t = e || function(s) {
      return s.message;
    }, n = { _errors: [] }, i = (s) => {
      for (const a of s.issues)
        if (a.code === "invalid_union")
          a.unionErrors.map(i);
        else if (a.code === "invalid_return_type")
          i(a.returnTypeError);
        else if (a.code === "invalid_arguments")
          i(a.argumentsError);
        else if (a.path.length === 0)
          n._errors.push(t(a));
        else {
          let o = n, u = 0;
          for (; u < a.path.length; ) {
            const c = a.path[u];
            u === a.path.length - 1 ? (o[c] = o[c] || { _errors: [] }, o[c]._errors.push(t(a))) : o[c] = o[c] || { _errors: [] }, o = o[c], u++;
          }
        }
    };
    return i(this), n;
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, T.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(e = (t) => t.message) {
    const t = {}, n = [];
    for (const i of this.issues)
      i.path.length > 0 ? (t[i.path[0]] = t[i.path[0]] || [], t[i.path[0]].push(e(i))) : n.push(e(i));
    return { formErrors: n, fieldErrors: t };
  }
  get formErrors() {
    return this.flatten();
  }
};
F.create = (r) => new F(r);
var ze = (r, e) => {
  let t;
  switch (r.code) {
    case d.invalid_type:
      r.received === f.undefined ? t = "Required" : t = `Expected ${r.expected}, received ${r.received}`;
      break;
    case d.invalid_literal:
      t = `Invalid literal value, expected ${JSON.stringify(r.expected, T.jsonStringifyReplacer)}`;
      break;
    case d.unrecognized_keys:
      t = `Unrecognized key(s) in object: ${T.joinValues(r.keys, ", ")}`;
      break;
    case d.invalid_union:
      t = "Invalid input";
      break;
    case d.invalid_union_discriminator:
      t = `Invalid discriminator value. Expected ${T.joinValues(r.options)}`;
      break;
    case d.invalid_enum_value:
      t = `Invalid enum value. Expected ${T.joinValues(r.options)}, received '${r.received}'`;
      break;
    case d.invalid_arguments:
      t = "Invalid function arguments";
      break;
    case d.invalid_return_type:
      t = "Invalid function return type";
      break;
    case d.invalid_date:
      t = "Invalid date";
      break;
    case d.invalid_string:
      typeof r.validation == "object" ? "includes" in r.validation ? (t = `Invalid input: must include "${r.validation.includes}"`, typeof r.validation.position == "number" && (t = `${t} at one or more positions greater than or equal to ${r.validation.position}`)) : "startsWith" in r.validation ? t = `Invalid input: must start with "${r.validation.startsWith}"` : "endsWith" in r.validation ? t = `Invalid input: must end with "${r.validation.endsWith}"` : T.assertNever(r.validation) : r.validation !== "regex" ? t = `Invalid ${r.validation}` : t = "Invalid";
      break;
    case d.too_small:
      r.type === "array" ? t = `Array must contain ${r.exact ? "exactly" : r.inclusive ? "at least" : "more than"} ${r.minimum} element(s)` : r.type === "string" ? t = `String must contain ${r.exact ? "exactly" : r.inclusive ? "at least" : "over"} ${r.minimum} character(s)` : r.type === "number" ? t = `Number must be ${r.exact ? "exactly equal to " : r.inclusive ? "greater than or equal to " : "greater than "}${r.minimum}` : r.type === "date" ? t = `Date must be ${r.exact ? "exactly equal to " : r.inclusive ? "greater than or equal to " : "greater than "}${new Date(Number(r.minimum))}` : t = "Invalid input";
      break;
    case d.too_big:
      r.type === "array" ? t = `Array must contain ${r.exact ? "exactly" : r.inclusive ? "at most" : "less than"} ${r.maximum} element(s)` : r.type === "string" ? t = `String must contain ${r.exact ? "exactly" : r.inclusive ? "at most" : "under"} ${r.maximum} character(s)` : r.type === "number" ? t = `Number must be ${r.exact ? "exactly" : r.inclusive ? "less than or equal to" : "less than"} ${r.maximum}` : r.type === "bigint" ? t = `BigInt must be ${r.exact ? "exactly" : r.inclusive ? "less than or equal to" : "less than"} ${r.maximum}` : r.type === "date" ? t = `Date must be ${r.exact ? "exactly" : r.inclusive ? "smaller than or equal to" : "smaller than"} ${new Date(Number(r.maximum))}` : t = "Invalid input";
      break;
    case d.custom:
      t = "Invalid input";
      break;
    case d.invalid_intersection_types:
      t = "Intersection results could not be merged";
      break;
    case d.not_multiple_of:
      t = `Number must be a multiple of ${r.multipleOf}`;
      break;
    case d.not_finite:
      t = "Number must be finite";
      break;
    default:
      t = e.defaultError, T.assertNever(r);
  }
  return { message: t };
};
var tn = ze;
function gt() {
  return tn;
}
var _t = (r) => {
  const { data: e, path: t, errorMaps: n, issueData: i } = r, s = [...t, ...i.path || []], a = {
    ...i,
    path: s
  };
  let o = "";
  const u = n.filter((c) => !!c).slice().reverse();
  for (const c of u)
    o = c(a, { data: e, defaultError: o }).message;
  return {
    ...i,
    path: s,
    message: i.message || o
  };
};
function h(r, e) {
  const t = _t({
    issueData: e,
    data: r.data,
    path: r.path,
    errorMaps: [
      r.common.contextualErrorMap,
      r.schemaErrorMap,
      gt(),
      ze
      // then global default map
    ].filter((n) => !!n)
  });
  r.common.issues.push(t);
}
var Z = class _Z {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    this.value === "valid" && (this.value = "dirty");
  }
  abort() {
    this.value !== "aborted" && (this.value = "aborted");
  }
  static mergeArray(e, t) {
    const n = [];
    for (const i of t) {
      if (i.status === "aborted")
        return g;
      i.status === "dirty" && e.dirty(), n.push(i.value);
    }
    return { status: e.value, value: n };
  }
  static async mergeObjectAsync(e, t) {
    const n = [];
    for (const i of t)
      n.push({
        key: await i.key,
        value: await i.value
      });
    return _Z.mergeObjectSync(e, n);
  }
  static mergeObjectSync(e, t) {
    const n = {};
    for (const i of t) {
      const { key: s, value: a } = i;
      if (s.status === "aborted" || a.status === "aborted")
        return g;
      s.status === "dirty" && e.dirty(), a.status === "dirty" && e.dirty(), (typeof a.value < "u" || i.alwaysSet) && (n[s.value] = a.value);
    }
    return { status: e.value, value: n };
  }
};
var g = Object.freeze({
  status: "aborted"
});
var rn = (r) => ({ status: "dirty", value: r });
var D = (r) => ({ status: "valid", value: r });
var Xt = (r) => r.status === "aborted";
var Qt = (r) => r.status === "dirty";
var wt = (r) => r.status === "valid";
var bt = (r) => typeof Promise < "u" && r instanceof Promise;
var m;
(function(r) {
  r.errToObj = (e) => typeof e == "string" ? { message: e } : e || {}, r.toString = (e) => typeof e == "string" ? e : e == null ? void 0 : e.message;
})(m || (m = {}));
var H = class {
  constructor(e, t, n, i) {
    this._cachedPath = [], this.parent = e, this.data = t, this._path = n, this._key = i;
  }
  get path() {
    return this._cachedPath.length || (this._key instanceof Array ? this._cachedPath.push(...this._path, ...this._key) : this._cachedPath.push(...this._path, this._key)), this._cachedPath;
  }
};
var er = (r, e) => {
  if (wt(e))
    return { success: true, data: e.value };
  if (!r.common.issues.length)
    throw new Error("Validation failed but no issues detected.");
  return {
    success: false,
    get error() {
      if (this._error)
        return this._error;
      const t = new F(r.common.issues);
      return this._error = t, this._error;
    }
  };
};
function _(r) {
  if (!r)
    return {};
  const { errorMap: e, invalid_type_error: t, required_error: n, description: i } = r;
  if (e && (t || n))
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  return e ? { errorMap: e, description: i } : { errorMap: (a, o) => a.code !== "invalid_type" ? { message: o.defaultError } : typeof o.data > "u" ? { message: n ?? o.defaultError } : { message: t ?? o.defaultError }, description: i };
}
var b = class {
  constructor(e) {
    this.spa = this.safeParseAsync, this._def = e, this.parse = this.parse.bind(this), this.safeParse = this.safeParse.bind(this), this.parseAsync = this.parseAsync.bind(this), this.safeParseAsync = this.safeParseAsync.bind(this), this.spa = this.spa.bind(this), this.refine = this.refine.bind(this), this.refinement = this.refinement.bind(this), this.superRefine = this.superRefine.bind(this), this.optional = this.optional.bind(this), this.nullable = this.nullable.bind(this), this.nullish = this.nullish.bind(this), this.array = this.array.bind(this), this.promise = this.promise.bind(this), this.or = this.or.bind(this), this.and = this.and.bind(this), this.transform = this.transform.bind(this), this.brand = this.brand.bind(this), this.default = this.default.bind(this), this.catch = this.catch.bind(this), this.describe = this.describe.bind(this), this.pipe = this.pipe.bind(this), this.isNullable = this.isNullable.bind(this), this.isOptional = this.isOptional.bind(this);
  }
  get description() {
    return this._def.description;
  }
  _getType(e) {
    return ce(e.data);
  }
  _getOrReturnCtx(e, t) {
    return t || {
      common: e.parent.common,
      data: e.data,
      parsedType: ce(e.data),
      schemaErrorMap: this._def.errorMap,
      path: e.path,
      parent: e.parent
    };
  }
  _processInputParams(e) {
    return {
      status: new Z(),
      ctx: {
        common: e.parent.common,
        data: e.data,
        parsedType: ce(e.data),
        schemaErrorMap: this._def.errorMap,
        path: e.path,
        parent: e.parent
      }
    };
  }
  _parseSync(e) {
    const t = this._parse(e);
    if (bt(t))
      throw new Error("Synchronous parse encountered promise.");
    return t;
  }
  _parseAsync(e) {
    const t = this._parse(e);
    return Promise.resolve(t);
  }
  parse(e, t) {
    const n = this.safeParse(e, t);
    if (n.success)
      return n.data;
    throw n.error;
  }
  safeParse(e, t) {
    var n;
    const i = {
      common: {
        issues: [],
        async: (n = t == null ? void 0 : t.async) !== null && n !== void 0 ? n : false,
        contextualErrorMap: t == null ? void 0 : t.errorMap
      },
      path: (t == null ? void 0 : t.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: e,
      parsedType: ce(e)
    }, s = this._parseSync({ data: e, path: i.path, parent: i });
    return er(i, s);
  }
  async parseAsync(e, t) {
    const n = await this.safeParseAsync(e, t);
    if (n.success)
      return n.data;
    throw n.error;
  }
  async safeParseAsync(e, t) {
    const n = {
      common: {
        issues: [],
        contextualErrorMap: t == null ? void 0 : t.errorMap,
        async: true
      },
      path: (t == null ? void 0 : t.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: e,
      parsedType: ce(e)
    }, i = this._parse({ data: e, path: n.path, parent: n }), s = await (bt(i) ? i : Promise.resolve(i));
    return er(n, s);
  }
  refine(e, t) {
    const n = (i) => typeof t == "string" || typeof t > "u" ? { message: t } : typeof t == "function" ? t(i) : t;
    return this._refinement((i, s) => {
      const a = e(i), o = () => s.addIssue({
        code: d.custom,
        ...n(i)
      });
      return typeof Promise < "u" && a instanceof Promise ? a.then((u) => u ? true : (o(), false)) : a ? true : (o(), false);
    });
  }
  refinement(e, t) {
    return this._refinement((n, i) => e(n) ? true : (i.addIssue(typeof t == "function" ? t(n, i) : t), false));
  }
  _refinement(e) {
    return new X({
      schema: this,
      typeName: y.ZodEffects,
      effect: { type: "refinement", refinement: e }
    });
  }
  superRefine(e) {
    return this._refinement(e);
  }
  optional() {
    return re.create(this, this._def);
  }
  nullable() {
    return ke.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return K.create(this, this._def);
  }
  promise() {
    return Ne.create(this, this._def);
  }
  or(e) {
    return Ke.create([this, e], this._def);
  }
  and(e) {
    return He.create(this, e, this._def);
  }
  transform(e) {
    return new X({
      ..._(this._def),
      schema: this,
      typeName: y.ZodEffects,
      effect: { type: "transform", transform: e }
    });
  }
  default(e) {
    const t = typeof e == "function" ? e : () => e;
    return new Xe({
      ..._(this._def),
      innerType: this,
      defaultValue: t,
      typeName: y.ZodDefault
    });
  }
  brand() {
    return new mn({
      typeName: y.ZodBranded,
      type: this,
      ..._(this._def)
    });
  }
  catch(e) {
    const t = typeof e == "function" ? e : () => e;
    return new Ct({
      ..._(this._def),
      innerType: this,
      catchValue: t,
      typeName: y.ZodCatch
    });
  }
  describe(e) {
    const t = this.constructor;
    return new t({
      ...this._def,
      description: e
    });
  }
  pipe(e) {
    return nt.create(this, e);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
};
var nn = /^c[^\s-]{8,}$/i;
var sn = /^[a-z][a-z0-9]*$/;
var an = /[0-9A-HJKMNP-TV-Z]{26}/;
var on = /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[a-f0-9]{4}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i;
var cn = /^(([^<>()[\]\\.,;:\s@\"]+(\.[^<>()[\]\\.,;:\s@\"]+)*)|(\".+\"))@((\[(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\])|(\[IPv6:(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))\])|([A-Za-z0-9]([A-Za-z0-9-]*[A-Za-z0-9])*(\.[A-Za-z]{2,})+))$/;
var un = /^(\p{Extended_Pictographic}|\p{Emoji_Component})+$/u;
var ln = /^(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))$/;
var dn = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/;
var fn = (r) => r.precision ? r.offset ? new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${r.precision}}(([+-]\\d{2}(:?\\d{2})?)|Z)$`) : new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${r.precision}}Z$`) : r.precision === 0 ? r.offset ? new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(([+-]\\d{2}(:?\\d{2})?)|Z)$") : new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}Z$") : r.offset ? new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(([+-]\\d{2}(:?\\d{2})?)|Z)$") : new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?Z$");
function hn(r, e) {
  return !!((e === "v4" || !e) && ln.test(r) || (e === "v6" || !e) && dn.test(r));
}
var J = class _J extends b {
  constructor() {
    super(...arguments), this._regex = (e, t, n) => this.refinement((i) => e.test(i), {
      validation: t,
      code: d.invalid_string,
      ...m.errToObj(n)
    }), this.nonempty = (e) => this.min(1, m.errToObj(e)), this.trim = () => new _J({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    }), this.toLowerCase = () => new _J({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    }), this.toUpperCase = () => new _J({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  _parse(e) {
    if (this._def.coerce && (e.data = String(e.data)), this._getType(e) !== f.string) {
      const s = this._getOrReturnCtx(e);
      return h(
        s,
        {
          code: d.invalid_type,
          expected: f.string,
          received: s.parsedType
        }
        //
      ), g;
    }
    const n = new Z();
    let i;
    for (const s of this._def.checks)
      if (s.kind === "min")
        e.data.length < s.value && (i = this._getOrReturnCtx(e, i), h(i, {
          code: d.too_small,
          minimum: s.value,
          type: "string",
          inclusive: true,
          exact: false,
          message: s.message
        }), n.dirty());
      else if (s.kind === "max")
        e.data.length > s.value && (i = this._getOrReturnCtx(e, i), h(i, {
          code: d.too_big,
          maximum: s.value,
          type: "string",
          inclusive: true,
          exact: false,
          message: s.message
        }), n.dirty());
      else if (s.kind === "length") {
        const a = e.data.length > s.value, o = e.data.length < s.value;
        (a || o) && (i = this._getOrReturnCtx(e, i), a ? h(i, {
          code: d.too_big,
          maximum: s.value,
          type: "string",
          inclusive: true,
          exact: true,
          message: s.message
        }) : o && h(i, {
          code: d.too_small,
          minimum: s.value,
          type: "string",
          inclusive: true,
          exact: true,
          message: s.message
        }), n.dirty());
      } else if (s.kind === "email")
        cn.test(e.data) || (i = this._getOrReturnCtx(e, i), h(i, {
          validation: "email",
          code: d.invalid_string,
          message: s.message
        }), n.dirty());
      else if (s.kind === "emoji")
        un.test(e.data) || (i = this._getOrReturnCtx(e, i), h(i, {
          validation: "emoji",
          code: d.invalid_string,
          message: s.message
        }), n.dirty());
      else if (s.kind === "uuid")
        on.test(e.data) || (i = this._getOrReturnCtx(e, i), h(i, {
          validation: "uuid",
          code: d.invalid_string,
          message: s.message
        }), n.dirty());
      else if (s.kind === "cuid")
        nn.test(e.data) || (i = this._getOrReturnCtx(e, i), h(i, {
          validation: "cuid",
          code: d.invalid_string,
          message: s.message
        }), n.dirty());
      else if (s.kind === "cuid2")
        sn.test(e.data) || (i = this._getOrReturnCtx(e, i), h(i, {
          validation: "cuid2",
          code: d.invalid_string,
          message: s.message
        }), n.dirty());
      else if (s.kind === "ulid")
        an.test(e.data) || (i = this._getOrReturnCtx(e, i), h(i, {
          validation: "ulid",
          code: d.invalid_string,
          message: s.message
        }), n.dirty());
      else if (s.kind === "url")
        try {
          new URL(e.data);
        } catch {
          i = this._getOrReturnCtx(e, i), h(i, {
            validation: "url",
            code: d.invalid_string,
            message: s.message
          }), n.dirty();
        }
      else
        s.kind === "regex" ? (s.regex.lastIndex = 0, s.regex.test(e.data) || (i = this._getOrReturnCtx(e, i), h(i, {
          validation: "regex",
          code: d.invalid_string,
          message: s.message
        }), n.dirty())) : s.kind === "trim" ? e.data = e.data.trim() : s.kind === "includes" ? e.data.includes(s.value, s.position) || (i = this._getOrReturnCtx(e, i), h(i, {
          code: d.invalid_string,
          validation: { includes: s.value, position: s.position },
          message: s.message
        }), n.dirty()) : s.kind === "toLowerCase" ? e.data = e.data.toLowerCase() : s.kind === "toUpperCase" ? e.data = e.data.toUpperCase() : s.kind === "startsWith" ? e.data.startsWith(s.value) || (i = this._getOrReturnCtx(e, i), h(i, {
          code: d.invalid_string,
          validation: { startsWith: s.value },
          message: s.message
        }), n.dirty()) : s.kind === "endsWith" ? e.data.endsWith(s.value) || (i = this._getOrReturnCtx(e, i), h(i, {
          code: d.invalid_string,
          validation: { endsWith: s.value },
          message: s.message
        }), n.dirty()) : s.kind === "datetime" ? fn(s).test(e.data) || (i = this._getOrReturnCtx(e, i), h(i, {
          code: d.invalid_string,
          validation: "datetime",
          message: s.message
        }), n.dirty()) : s.kind === "ip" ? hn(e.data, s.version) || (i = this._getOrReturnCtx(e, i), h(i, {
          validation: "ip",
          code: d.invalid_string,
          message: s.message
        }), n.dirty()) : T.assertNever(s);
    return { status: n.value, value: e.data };
  }
  _addCheck(e) {
    return new _J({
      ...this._def,
      checks: [...this._def.checks, e]
    });
  }
  email(e) {
    return this._addCheck({ kind: "email", ...m.errToObj(e) });
  }
  url(e) {
    return this._addCheck({ kind: "url", ...m.errToObj(e) });
  }
  emoji(e) {
    return this._addCheck({ kind: "emoji", ...m.errToObj(e) });
  }
  uuid(e) {
    return this._addCheck({ kind: "uuid", ...m.errToObj(e) });
  }
  cuid(e) {
    return this._addCheck({ kind: "cuid", ...m.errToObj(e) });
  }
  cuid2(e) {
    return this._addCheck({ kind: "cuid2", ...m.errToObj(e) });
  }
  ulid(e) {
    return this._addCheck({ kind: "ulid", ...m.errToObj(e) });
  }
  ip(e) {
    return this._addCheck({ kind: "ip", ...m.errToObj(e) });
  }
  datetime(e) {
    var t;
    return typeof e == "string" ? this._addCheck({
      kind: "datetime",
      precision: null,
      offset: false,
      message: e
    }) : this._addCheck({
      kind: "datetime",
      precision: typeof (e == null ? void 0 : e.precision) > "u" ? null : e == null ? void 0 : e.precision,
      offset: (t = e == null ? void 0 : e.offset) !== null && t !== void 0 ? t : false,
      ...m.errToObj(e == null ? void 0 : e.message)
    });
  }
  regex(e, t) {
    return this._addCheck({
      kind: "regex",
      regex: e,
      ...m.errToObj(t)
    });
  }
  includes(e, t) {
    return this._addCheck({
      kind: "includes",
      value: e,
      position: t == null ? void 0 : t.position,
      ...m.errToObj(t == null ? void 0 : t.message)
    });
  }
  startsWith(e, t) {
    return this._addCheck({
      kind: "startsWith",
      value: e,
      ...m.errToObj(t)
    });
  }
  endsWith(e, t) {
    return this._addCheck({
      kind: "endsWith",
      value: e,
      ...m.errToObj(t)
    });
  }
  min(e, t) {
    return this._addCheck({
      kind: "min",
      value: e,
      ...m.errToObj(t)
    });
  }
  max(e, t) {
    return this._addCheck({
      kind: "max",
      value: e,
      ...m.errToObj(t)
    });
  }
  length(e, t) {
    return this._addCheck({
      kind: "length",
      value: e,
      ...m.errToObj(t)
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((e) => e.kind === "datetime");
  }
  get isEmail() {
    return !!this._def.checks.find((e) => e.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((e) => e.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((e) => e.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((e) => e.kind === "uuid");
  }
  get isCUID() {
    return !!this._def.checks.find((e) => e.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((e) => e.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((e) => e.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((e) => e.kind === "ip");
  }
  get minLength() {
    let e = null;
    for (const t of this._def.checks)
      t.kind === "min" && (e === null || t.value > e) && (e = t.value);
    return e;
  }
  get maxLength() {
    let e = null;
    for (const t of this._def.checks)
      t.kind === "max" && (e === null || t.value < e) && (e = t.value);
    return e;
  }
};
J.create = (r) => {
  var e;
  return new J({
    checks: [],
    typeName: y.ZodString,
    coerce: (e = r == null ? void 0 : r.coerce) !== null && e !== void 0 ? e : false,
    ..._(r)
  });
};
function pn(r, e) {
  const t = (r.toString().split(".")[1] || "").length, n = (e.toString().split(".")[1] || "").length, i = t > n ? t : n, s = parseInt(r.toFixed(i).replace(".", "")), a = parseInt(e.toFixed(i).replace(".", ""));
  return s % a / Math.pow(10, i);
}
var we = class _we extends b {
  constructor() {
    super(...arguments), this.min = this.gte, this.max = this.lte, this.step = this.multipleOf;
  }
  _parse(e) {
    if (this._def.coerce && (e.data = Number(e.data)), this._getType(e) !== f.number) {
      const s = this._getOrReturnCtx(e);
      return h(s, {
        code: d.invalid_type,
        expected: f.number,
        received: s.parsedType
      }), g;
    }
    let n;
    const i = new Z();
    for (const s of this._def.checks)
      s.kind === "int" ? T.isInteger(e.data) || (n = this._getOrReturnCtx(e, n), h(n, {
        code: d.invalid_type,
        expected: "integer",
        received: "float",
        message: s.message
      }), i.dirty()) : s.kind === "min" ? (s.inclusive ? e.data < s.value : e.data <= s.value) && (n = this._getOrReturnCtx(e, n), h(n, {
        code: d.too_small,
        minimum: s.value,
        type: "number",
        inclusive: s.inclusive,
        exact: false,
        message: s.message
      }), i.dirty()) : s.kind === "max" ? (s.inclusive ? e.data > s.value : e.data >= s.value) && (n = this._getOrReturnCtx(e, n), h(n, {
        code: d.too_big,
        maximum: s.value,
        type: "number",
        inclusive: s.inclusive,
        exact: false,
        message: s.message
      }), i.dirty()) : s.kind === "multipleOf" ? pn(e.data, s.value) !== 0 && (n = this._getOrReturnCtx(e, n), h(n, {
        code: d.not_multiple_of,
        multipleOf: s.value,
        message: s.message
      }), i.dirty()) : s.kind === "finite" ? Number.isFinite(e.data) || (n = this._getOrReturnCtx(e, n), h(n, {
        code: d.not_finite,
        message: s.message
      }), i.dirty()) : T.assertNever(s);
    return { status: i.value, value: e.data };
  }
  gte(e, t) {
    return this.setLimit("min", e, true, m.toString(t));
  }
  gt(e, t) {
    return this.setLimit("min", e, false, m.toString(t));
  }
  lte(e, t) {
    return this.setLimit("max", e, true, m.toString(t));
  }
  lt(e, t) {
    return this.setLimit("max", e, false, m.toString(t));
  }
  setLimit(e, t, n, i) {
    return new _we({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind: e,
          value: t,
          inclusive: n,
          message: m.toString(i)
        }
      ]
    });
  }
  _addCheck(e) {
    return new _we({
      ...this._def,
      checks: [...this._def.checks, e]
    });
  }
  int(e) {
    return this._addCheck({
      kind: "int",
      message: m.toString(e)
    });
  }
  positive(e) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: false,
      message: m.toString(e)
    });
  }
  negative(e) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: false,
      message: m.toString(e)
    });
  }
  nonpositive(e) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: true,
      message: m.toString(e)
    });
  }
  nonnegative(e) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: true,
      message: m.toString(e)
    });
  }
  multipleOf(e, t) {
    return this._addCheck({
      kind: "multipleOf",
      value: e,
      message: m.toString(t)
    });
  }
  finite(e) {
    return this._addCheck({
      kind: "finite",
      message: m.toString(e)
    });
  }
  safe(e) {
    return this._addCheck({
      kind: "min",
      inclusive: true,
      value: Number.MIN_SAFE_INTEGER,
      message: m.toString(e)
    })._addCheck({
      kind: "max",
      inclusive: true,
      value: Number.MAX_SAFE_INTEGER,
      message: m.toString(e)
    });
  }
  get minValue() {
    let e = null;
    for (const t of this._def.checks)
      t.kind === "min" && (e === null || t.value > e) && (e = t.value);
    return e;
  }
  get maxValue() {
    let e = null;
    for (const t of this._def.checks)
      t.kind === "max" && (e === null || t.value < e) && (e = t.value);
    return e;
  }
  get isInt() {
    return !!this._def.checks.find((e) => e.kind === "int" || e.kind === "multipleOf" && T.isInteger(e.value));
  }
  get isFinite() {
    let e = null, t = null;
    for (const n of this._def.checks) {
      if (n.kind === "finite" || n.kind === "int" || n.kind === "multipleOf")
        return true;
      n.kind === "min" ? (t === null || n.value > t) && (t = n.value) : n.kind === "max" && (e === null || n.value < e) && (e = n.value);
    }
    return Number.isFinite(t) && Number.isFinite(e);
  }
};
we.create = (r) => new we({
  checks: [],
  typeName: y.ZodNumber,
  coerce: (r == null ? void 0 : r.coerce) || false,
  ..._(r)
});
var be = class _be extends b {
  constructor() {
    super(...arguments), this.min = this.gte, this.max = this.lte;
  }
  _parse(e) {
    if (this._def.coerce && (e.data = BigInt(e.data)), this._getType(e) !== f.bigint) {
      const s = this._getOrReturnCtx(e);
      return h(s, {
        code: d.invalid_type,
        expected: f.bigint,
        received: s.parsedType
      }), g;
    }
    let n;
    const i = new Z();
    for (const s of this._def.checks)
      s.kind === "min" ? (s.inclusive ? e.data < s.value : e.data <= s.value) && (n = this._getOrReturnCtx(e, n), h(n, {
        code: d.too_small,
        type: "bigint",
        minimum: s.value,
        inclusive: s.inclusive,
        message: s.message
      }), i.dirty()) : s.kind === "max" ? (s.inclusive ? e.data > s.value : e.data >= s.value) && (n = this._getOrReturnCtx(e, n), h(n, {
        code: d.too_big,
        type: "bigint",
        maximum: s.value,
        inclusive: s.inclusive,
        message: s.message
      }), i.dirty()) : s.kind === "multipleOf" ? e.data % s.value !== BigInt(0) && (n = this._getOrReturnCtx(e, n), h(n, {
        code: d.not_multiple_of,
        multipleOf: s.value,
        message: s.message
      }), i.dirty()) : T.assertNever(s);
    return { status: i.value, value: e.data };
  }
  gte(e, t) {
    return this.setLimit("min", e, true, m.toString(t));
  }
  gt(e, t) {
    return this.setLimit("min", e, false, m.toString(t));
  }
  lte(e, t) {
    return this.setLimit("max", e, true, m.toString(t));
  }
  lt(e, t) {
    return this.setLimit("max", e, false, m.toString(t));
  }
  setLimit(e, t, n, i) {
    return new _be({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind: e,
          value: t,
          inclusive: n,
          message: m.toString(i)
        }
      ]
    });
  }
  _addCheck(e) {
    return new _be({
      ...this._def,
      checks: [...this._def.checks, e]
    });
  }
  positive(e) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: false,
      message: m.toString(e)
    });
  }
  negative(e) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: false,
      message: m.toString(e)
    });
  }
  nonpositive(e) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: true,
      message: m.toString(e)
    });
  }
  nonnegative(e) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: true,
      message: m.toString(e)
    });
  }
  multipleOf(e, t) {
    return this._addCheck({
      kind: "multipleOf",
      value: e,
      message: m.toString(t)
    });
  }
  get minValue() {
    let e = null;
    for (const t of this._def.checks)
      t.kind === "min" && (e === null || t.value > e) && (e = t.value);
    return e;
  }
  get maxValue() {
    let e = null;
    for (const t of this._def.checks)
      t.kind === "max" && (e === null || t.value < e) && (e = t.value);
    return e;
  }
};
be.create = (r) => {
  var e;
  return new be({
    checks: [],
    typeName: y.ZodBigInt,
    coerce: (e = r == null ? void 0 : r.coerce) !== null && e !== void 0 ? e : false,
    ..._(r)
  });
};
var xt = class extends b {
  _parse(e) {
    if (this._def.coerce && (e.data = !!e.data), this._getType(e) !== f.boolean) {
      const n = this._getOrReturnCtx(e);
      return h(n, {
        code: d.invalid_type,
        expected: f.boolean,
        received: n.parsedType
      }), g;
    }
    return D(e.data);
  }
};
xt.create = (r) => new xt({
  typeName: y.ZodBoolean,
  coerce: (r == null ? void 0 : r.coerce) || false,
  ..._(r)
});
var Pe = class _Pe extends b {
  _parse(e) {
    if (this._def.coerce && (e.data = new Date(e.data)), this._getType(e) !== f.date) {
      const s = this._getOrReturnCtx(e);
      return h(s, {
        code: d.invalid_type,
        expected: f.date,
        received: s.parsedType
      }), g;
    }
    if (isNaN(e.data.getTime())) {
      const s = this._getOrReturnCtx(e);
      return h(s, {
        code: d.invalid_date
      }), g;
    }
    const n = new Z();
    let i;
    for (const s of this._def.checks)
      s.kind === "min" ? e.data.getTime() < s.value && (i = this._getOrReturnCtx(e, i), h(i, {
        code: d.too_small,
        message: s.message,
        inclusive: true,
        exact: false,
        minimum: s.value,
        type: "date"
      }), n.dirty()) : s.kind === "max" ? e.data.getTime() > s.value && (i = this._getOrReturnCtx(e, i), h(i, {
        code: d.too_big,
        message: s.message,
        inclusive: true,
        exact: false,
        maximum: s.value,
        type: "date"
      }), n.dirty()) : T.assertNever(s);
    return {
      status: n.value,
      value: new Date(e.data.getTime())
    };
  }
  _addCheck(e) {
    return new _Pe({
      ...this._def,
      checks: [...this._def.checks, e]
    });
  }
  min(e, t) {
    return this._addCheck({
      kind: "min",
      value: e.getTime(),
      message: m.toString(t)
    });
  }
  max(e, t) {
    return this._addCheck({
      kind: "max",
      value: e.getTime(),
      message: m.toString(t)
    });
  }
  get minDate() {
    let e = null;
    for (const t of this._def.checks)
      t.kind === "min" && (e === null || t.value > e) && (e = t.value);
    return e != null ? new Date(e) : null;
  }
  get maxDate() {
    let e = null;
    for (const t of this._def.checks)
      t.kind === "max" && (e === null || t.value < e) && (e = t.value);
    return e != null ? new Date(e) : null;
  }
};
Pe.create = (r) => new Pe({
  checks: [],
  coerce: (r == null ? void 0 : r.coerce) || false,
  typeName: y.ZodDate,
  ..._(r)
});
var kt = class extends b {
  _parse(e) {
    if (this._getType(e) !== f.symbol) {
      const n = this._getOrReturnCtx(e);
      return h(n, {
        code: d.invalid_type,
        expected: f.symbol,
        received: n.parsedType
      }), g;
    }
    return D(e.data);
  }
};
kt.create = (r) => new kt({
  typeName: y.ZodSymbol,
  ..._(r)
});
var je = class extends b {
  _parse(e) {
    if (this._getType(e) !== f.undefined) {
      const n = this._getOrReturnCtx(e);
      return h(n, {
        code: d.invalid_type,
        expected: f.undefined,
        received: n.parsedType
      }), g;
    }
    return D(e.data);
  }
};
je.create = (r) => new je({
  typeName: y.ZodUndefined,
  ..._(r)
});
var Fe = class extends b {
  _parse(e) {
    if (this._getType(e) !== f.null) {
      const n = this._getOrReturnCtx(e);
      return h(n, {
        code: d.invalid_type,
        expected: f.null,
        received: n.parsedType
      }), g;
    }
    return D(e.data);
  }
};
Fe.create = (r) => new Fe({
  typeName: y.ZodNull,
  ..._(r)
});
var St = class extends b {
  constructor() {
    super(...arguments), this._any = true;
  }
  _parse(e) {
    return D(e.data);
  }
};
St.create = (r) => new St({
  typeName: y.ZodAny,
  ..._(r)
});
var ge = class extends b {
  constructor() {
    super(...arguments), this._unknown = true;
  }
  _parse(e) {
    return D(e.data);
  }
};
ge.create = (r) => new ge({
  typeName: y.ZodUnknown,
  ..._(r)
});
var ie = class extends b {
  _parse(e) {
    const t = this._getOrReturnCtx(e);
    return h(t, {
      code: d.invalid_type,
      expected: f.never,
      received: t.parsedType
    }), g;
  }
};
ie.create = (r) => new ie({
  typeName: y.ZodNever,
  ..._(r)
});
var Tt = class extends b {
  _parse(e) {
    if (this._getType(e) !== f.undefined) {
      const n = this._getOrReturnCtx(e);
      return h(n, {
        code: d.invalid_type,
        expected: f.void,
        received: n.parsedType
      }), g;
    }
    return D(e.data);
  }
};
Tt.create = (r) => new Tt({
  typeName: y.ZodVoid,
  ..._(r)
});
var K = class _K extends b {
  _parse(e) {
    const { ctx: t, status: n } = this._processInputParams(e), i = this._def;
    if (t.parsedType !== f.array)
      return h(t, {
        code: d.invalid_type,
        expected: f.array,
        received: t.parsedType
      }), g;
    if (i.exactLength !== null) {
      const a = t.data.length > i.exactLength.value, o = t.data.length < i.exactLength.value;
      (a || o) && (h(t, {
        code: a ? d.too_big : d.too_small,
        minimum: o ? i.exactLength.value : void 0,
        maximum: a ? i.exactLength.value : void 0,
        type: "array",
        inclusive: true,
        exact: true,
        message: i.exactLength.message
      }), n.dirty());
    }
    if (i.minLength !== null && t.data.length < i.minLength.value && (h(t, {
      code: d.too_small,
      minimum: i.minLength.value,
      type: "array",
      inclusive: true,
      exact: false,
      message: i.minLength.message
    }), n.dirty()), i.maxLength !== null && t.data.length > i.maxLength.value && (h(t, {
      code: d.too_big,
      maximum: i.maxLength.value,
      type: "array",
      inclusive: true,
      exact: false,
      message: i.maxLength.message
    }), n.dirty()), t.common.async)
      return Promise.all([...t.data].map((a, o) => i.type._parseAsync(new H(t, a, t.path, o)))).then((a) => Z.mergeArray(n, a));
    const s = [...t.data].map((a, o) => i.type._parseSync(new H(t, a, t.path, o)));
    return Z.mergeArray(n, s);
  }
  get element() {
    return this._def.type;
  }
  min(e, t) {
    return new _K({
      ...this._def,
      minLength: { value: e, message: m.toString(t) }
    });
  }
  max(e, t) {
    return new _K({
      ...this._def,
      maxLength: { value: e, message: m.toString(t) }
    });
  }
  length(e, t) {
    return new _K({
      ...this._def,
      exactLength: { value: e, message: m.toString(t) }
    });
  }
  nonempty(e) {
    return this.min(1, e);
  }
};
K.create = (r, e) => new K({
  type: r,
  minLength: null,
  maxLength: null,
  exactLength: null,
  typeName: y.ZodArray,
  ..._(e)
});
function pe(r) {
  if (r instanceof A) {
    const e = {};
    for (const t in r.shape) {
      const n = r.shape[t];
      e[t] = re.create(pe(n));
    }
    return new A({
      ...r._def,
      shape: () => e
    });
  } else
    return r instanceof K ? new K({
      ...r._def,
      type: pe(r.element)
    }) : r instanceof re ? re.create(pe(r.unwrap())) : r instanceof ke ? ke.create(pe(r.unwrap())) : r instanceof M ? M.create(r.items.map((e) => pe(e))) : r;
}
var A = class _A extends b {
  constructor() {
    super(...arguments), this._cached = null, this.nonstrict = this.passthrough, this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const e = this._def.shape(), t = T.objectKeys(e);
    return this._cached = { shape: e, keys: t };
  }
  _parse(e) {
    if (this._getType(e) !== f.object) {
      const c = this._getOrReturnCtx(e);
      return h(c, {
        code: d.invalid_type,
        expected: f.object,
        received: c.parsedType
      }), g;
    }
    const { status: n, ctx: i } = this._processInputParams(e), { shape: s, keys: a } = this._getCached(), o = [];
    if (!(this._def.catchall instanceof ie && this._def.unknownKeys === "strip"))
      for (const c in i.data)
        a.includes(c) || o.push(c);
    const u = [];
    for (const c of a) {
      const l = s[c], p = i.data[c];
      u.push({
        key: { status: "valid", value: c },
        value: l._parse(new H(i, p, i.path, c)),
        alwaysSet: c in i.data
      });
    }
    if (this._def.catchall instanceof ie) {
      const c = this._def.unknownKeys;
      if (c === "passthrough")
        for (const l of o)
          u.push({
            key: { status: "valid", value: l },
            value: { status: "valid", value: i.data[l] }
          });
      else if (c === "strict")
        o.length > 0 && (h(i, {
          code: d.unrecognized_keys,
          keys: o
        }), n.dirty());
      else if (c !== "strip")
        throw new Error("Internal ZodObject error: invalid unknownKeys value.");
    } else {
      const c = this._def.catchall;
      for (const l of o) {
        const p = i.data[l];
        u.push({
          key: { status: "valid", value: l },
          value: c._parse(
            new H(i, p, i.path, l)
            //, ctx.child(key), value, getParsedType(value)
          ),
          alwaysSet: l in i.data
        });
      }
    }
    return i.common.async ? Promise.resolve().then(async () => {
      const c = [];
      for (const l of u) {
        const p = await l.key;
        c.push({
          key: p,
          value: await l.value,
          alwaysSet: l.alwaysSet
        });
      }
      return c;
    }).then((c) => Z.mergeObjectSync(n, c)) : Z.mergeObjectSync(n, u);
  }
  get shape() {
    return this._def.shape();
  }
  strict(e) {
    return m.errToObj, new _A({
      ...this._def,
      unknownKeys: "strict",
      ...e !== void 0 ? {
        errorMap: (t, n) => {
          var i, s, a, o;
          const u = (a = (s = (i = this._def).errorMap) === null || s === void 0 ? void 0 : s.call(i, t, n).message) !== null && a !== void 0 ? a : n.defaultError;
          return t.code === "unrecognized_keys" ? {
            message: (o = m.errToObj(e).message) !== null && o !== void 0 ? o : u
          } : {
            message: u
          };
        }
      } : {}
    });
  }
  strip() {
    return new _A({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new _A({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  // const AugmentFactory =
  //   <Def extends ZodObjectDef>(def: Def) =>
  //   <Augmentation extends ZodRawShape>(
  //     augmentation: Augmentation
  //   ): ZodObject<
  //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
  //     Def["unknownKeys"],
  //     Def["catchall"]
  //   > => {
  //     return new ZodObject({
  //       ...def,
  //       shape: () => ({
  //         ...def.shape(),
  //         ...augmentation,
  //       }),
  //     }) as any;
  //   };
  extend(e) {
    return new _A({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...e
      })
    });
  }
  /**
   * Prior to zod@1.0.12 there was a bug in the
   * inferred type of merged objects. Please
   * upgrade if you are experiencing issues.
   */
  merge(e) {
    return new _A({
      unknownKeys: e._def.unknownKeys,
      catchall: e._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...e._def.shape()
      }),
      typeName: y.ZodObject
    });
  }
  // merge<
  //   Incoming extends AnyZodObject,
  //   Augmentation extends Incoming["shape"],
  //   NewOutput extends {
  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
  //       ? Augmentation[k]["_output"]
  //       : k extends keyof Output
  //       ? Output[k]
  //       : never;
  //   },
  //   NewInput extends {
  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
  //       ? Augmentation[k]["_input"]
  //       : k extends keyof Input
  //       ? Input[k]
  //       : never;
  //   }
  // >(
  //   merging: Incoming
  // ): ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"],
  //   NewOutput,
  //   NewInput
  // > {
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  setKey(e, t) {
    return this.augment({ [e]: t });
  }
  // merge<Incoming extends AnyZodObject>(
  //   merging: Incoming
  // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
  // ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"]
  // > {
  //   // const mergedShape = objectUtil.mergeShapes(
  //   //   this._def.shape(),
  //   //   merging._def.shape()
  //   // );
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  catchall(e) {
    return new _A({
      ...this._def,
      catchall: e
    });
  }
  pick(e) {
    const t = {};
    return T.objectKeys(e).forEach((n) => {
      e[n] && this.shape[n] && (t[n] = this.shape[n]);
    }), new _A({
      ...this._def,
      shape: () => t
    });
  }
  omit(e) {
    const t = {};
    return T.objectKeys(this.shape).forEach((n) => {
      e[n] || (t[n] = this.shape[n]);
    }), new _A({
      ...this._def,
      shape: () => t
    });
  }
  /**
   * @deprecated
   */
  deepPartial() {
    return pe(this);
  }
  partial(e) {
    const t = {};
    return T.objectKeys(this.shape).forEach((n) => {
      const i = this.shape[n];
      e && !e[n] ? t[n] = i : t[n] = i.optional();
    }), new _A({
      ...this._def,
      shape: () => t
    });
  }
  required(e) {
    const t = {};
    return T.objectKeys(this.shape).forEach((n) => {
      if (e && !e[n])
        t[n] = this.shape[n];
      else {
        let s = this.shape[n];
        for (; s instanceof re; )
          s = s._def.innerType;
        t[n] = s;
      }
    }), new _A({
      ...this._def,
      shape: () => t
    });
  }
  keyof() {
    return hr(T.objectKeys(this.shape));
  }
};
A.create = (r, e) => new A({
  shape: () => r,
  unknownKeys: "strip",
  catchall: ie.create(),
  typeName: y.ZodObject,
  ..._(e)
});
A.strictCreate = (r, e) => new A({
  shape: () => r,
  unknownKeys: "strict",
  catchall: ie.create(),
  typeName: y.ZodObject,
  ..._(e)
});
A.lazycreate = (r, e) => new A({
  shape: r,
  unknownKeys: "strip",
  catchall: ie.create(),
  typeName: y.ZodObject,
  ..._(e)
});
var Ke = class extends b {
  _parse(e) {
    const { ctx: t } = this._processInputParams(e), n = this._def.options;
    function i(s) {
      for (const o of s)
        if (o.result.status === "valid")
          return o.result;
      for (const o of s)
        if (o.result.status === "dirty")
          return t.common.issues.push(...o.ctx.common.issues), o.result;
      const a = s.map((o) => new F(o.ctx.common.issues));
      return h(t, {
        code: d.invalid_union,
        unionErrors: a
      }), g;
    }
    if (t.common.async)
      return Promise.all(n.map(async (s) => {
        const a = {
          ...t,
          common: {
            ...t.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await s._parseAsync({
            data: t.data,
            path: t.path,
            parent: a
          }),
          ctx: a
        };
      })).then(i);
    {
      let s;
      const a = [];
      for (const u of n) {
        const c = {
          ...t,
          common: {
            ...t.common,
            issues: []
          },
          parent: null
        }, l = u._parseSync({
          data: t.data,
          path: t.path,
          parent: c
        });
        if (l.status === "valid")
          return l;
        l.status === "dirty" && !s && (s = { result: l, ctx: c }), c.common.issues.length && a.push(c.common.issues);
      }
      if (s)
        return t.common.issues.push(...s.ctx.common.issues), s.result;
      const o = a.map((u) => new F(u));
      return h(t, {
        code: d.invalid_union,
        unionErrors: o
      }), g;
    }
  }
  get options() {
    return this._def.options;
  }
};
Ke.create = (r, e) => new Ke({
  options: r,
  typeName: y.ZodUnion,
  ..._(e)
});
var We = (r) => r instanceof Ge ? We(r.schema) : r instanceof X ? We(r.innerType()) : r instanceof Je ? [r.value] : r instanceof de ? r.options : r instanceof Me ? Object.keys(r.enum) : r instanceof Xe ? We(r._def.innerType) : r instanceof je ? [void 0] : r instanceof Fe ? [null] : null;
var zt = class _zt extends b {
  _parse(e) {
    const { ctx: t } = this._processInputParams(e);
    if (t.parsedType !== f.object)
      return h(t, {
        code: d.invalid_type,
        expected: f.object,
        received: t.parsedType
      }), g;
    const n = this.discriminator, i = t.data[n], s = this.optionsMap.get(i);
    return s ? t.common.async ? s._parseAsync({
      data: t.data,
      path: t.path,
      parent: t
    }) : s._parseSync({
      data: t.data,
      path: t.path,
      parent: t
    }) : (h(t, {
      code: d.invalid_union_discriminator,
      options: Array.from(this.optionsMap.keys()),
      path: [n]
    }), g);
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  /**
   * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
   * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
   * have a different value for each object in the union.
   * @param discriminator the name of the discriminator property
   * @param types an array of object schemas
   * @param params
   */
  static create(e, t, n) {
    const i = /* @__PURE__ */ new Map();
    for (const s of t) {
      const a = We(s.shape[e]);
      if (!a)
        throw new Error(`A discriminator value for key \`${e}\` could not be extracted from all schema options`);
      for (const o of a) {
        if (i.has(o))
          throw new Error(`Discriminator property ${String(e)} has duplicate value ${String(o)}`);
        i.set(o, s);
      }
    }
    return new _zt({
      typeName: y.ZodDiscriminatedUnion,
      discriminator: e,
      options: t,
      optionsMap: i,
      ..._(n)
    });
  }
};
function Et(r, e) {
  const t = ce(r), n = ce(e);
  if (r === e)
    return { valid: true, data: r };
  if (t === f.object && n === f.object) {
    const i = T.objectKeys(e), s = T.objectKeys(r).filter((o) => i.indexOf(o) !== -1), a = { ...r, ...e };
    for (const o of s) {
      const u = Et(r[o], e[o]);
      if (!u.valid)
        return { valid: false };
      a[o] = u.data;
    }
    return { valid: true, data: a };
  } else if (t === f.array && n === f.array) {
    if (r.length !== e.length)
      return { valid: false };
    const i = [];
    for (let s = 0; s < r.length; s++) {
      const a = r[s], o = e[s], u = Et(a, o);
      if (!u.valid)
        return { valid: false };
      i.push(u.data);
    }
    return { valid: true, data: i };
  } else
    return t === f.date && n === f.date && +r == +e ? { valid: true, data: r } : { valid: false };
}
var He = class extends b {
  _parse(e) {
    const { status: t, ctx: n } = this._processInputParams(e), i = (s, a) => {
      if (Xt(s) || Xt(a))
        return g;
      const o = Et(s.value, a.value);
      return o.valid ? ((Qt(s) || Qt(a)) && t.dirty(), { status: t.value, value: o.data }) : (h(n, {
        code: d.invalid_intersection_types
      }), g);
    };
    return n.common.async ? Promise.all([
      this._def.left._parseAsync({
        data: n.data,
        path: n.path,
        parent: n
      }),
      this._def.right._parseAsync({
        data: n.data,
        path: n.path,
        parent: n
      })
    ]).then(([s, a]) => i(s, a)) : i(this._def.left._parseSync({
      data: n.data,
      path: n.path,
      parent: n
    }), this._def.right._parseSync({
      data: n.data,
      path: n.path,
      parent: n
    }));
  }
};
He.create = (r, e, t) => new He({
  left: r,
  right: e,
  typeName: y.ZodIntersection,
  ..._(t)
});
var M = class _M extends b {
  _parse(e) {
    const { status: t, ctx: n } = this._processInputParams(e);
    if (n.parsedType !== f.array)
      return h(n, {
        code: d.invalid_type,
        expected: f.array,
        received: n.parsedType
      }), g;
    if (n.data.length < this._def.items.length)
      return h(n, {
        code: d.too_small,
        minimum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      }), g;
    !this._def.rest && n.data.length > this._def.items.length && (h(n, {
      code: d.too_big,
      maximum: this._def.items.length,
      inclusive: true,
      exact: false,
      type: "array"
    }), t.dirty());
    const s = [...n.data].map((a, o) => {
      const u = this._def.items[o] || this._def.rest;
      return u ? u._parse(new H(n, a, n.path, o)) : null;
    }).filter((a) => !!a);
    return n.common.async ? Promise.all(s).then((a) => Z.mergeArray(t, a)) : Z.mergeArray(t, s);
  }
  get items() {
    return this._def.items;
  }
  rest(e) {
    return new _M({
      ...this._def,
      rest: e
    });
  }
};
M.create = (r, e) => {
  if (!Array.isArray(r))
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  return new M({
    items: r,
    typeName: y.ZodTuple,
    rest: null,
    ..._(e)
  });
};
var Ye = class _Ye extends b {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(e) {
    const { status: t, ctx: n } = this._processInputParams(e);
    if (n.parsedType !== f.object)
      return h(n, {
        code: d.invalid_type,
        expected: f.object,
        received: n.parsedType
      }), g;
    const i = [], s = this._def.keyType, a = this._def.valueType;
    for (const o in n.data)
      i.push({
        key: s._parse(new H(n, o, n.path, o)),
        value: a._parse(new H(n, n.data[o], n.path, o))
      });
    return n.common.async ? Z.mergeObjectAsync(t, i) : Z.mergeObjectSync(t, i);
  }
  get element() {
    return this._def.valueType;
  }
  static create(e, t, n) {
    return t instanceof b ? new _Ye({
      keyType: e,
      valueType: t,
      typeName: y.ZodRecord,
      ..._(n)
    }) : new _Ye({
      keyType: J.create(),
      valueType: e,
      typeName: y.ZodRecord,
      ..._(t)
    });
  }
};
var It = class extends b {
  _parse(e) {
    const { status: t, ctx: n } = this._processInputParams(e);
    if (n.parsedType !== f.map)
      return h(n, {
        code: d.invalid_type,
        expected: f.map,
        received: n.parsedType
      }), g;
    const i = this._def.keyType, s = this._def.valueType, a = [...n.data.entries()].map(([o, u], c) => ({
      key: i._parse(new H(n, o, n.path, [c, "key"])),
      value: s._parse(new H(n, u, n.path, [c, "value"]))
    }));
    if (n.common.async) {
      const o = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (const u of a) {
          const c = await u.key, l = await u.value;
          if (c.status === "aborted" || l.status === "aborted")
            return g;
          (c.status === "dirty" || l.status === "dirty") && t.dirty(), o.set(c.value, l.value);
        }
        return { status: t.value, value: o };
      });
    } else {
      const o = /* @__PURE__ */ new Map();
      for (const u of a) {
        const c = u.key, l = u.value;
        if (c.status === "aborted" || l.status === "aborted")
          return g;
        (c.status === "dirty" || l.status === "dirty") && t.dirty(), o.set(c.value, l.value);
      }
      return { status: t.value, value: o };
    }
  }
};
It.create = (r, e, t) => new It({
  valueType: e,
  keyType: r,
  typeName: y.ZodMap,
  ..._(t)
});
var xe = class _xe extends b {
  _parse(e) {
    const { status: t, ctx: n } = this._processInputParams(e);
    if (n.parsedType !== f.set)
      return h(n, {
        code: d.invalid_type,
        expected: f.set,
        received: n.parsedType
      }), g;
    const i = this._def;
    i.minSize !== null && n.data.size < i.minSize.value && (h(n, {
      code: d.too_small,
      minimum: i.minSize.value,
      type: "set",
      inclusive: true,
      exact: false,
      message: i.minSize.message
    }), t.dirty()), i.maxSize !== null && n.data.size > i.maxSize.value && (h(n, {
      code: d.too_big,
      maximum: i.maxSize.value,
      type: "set",
      inclusive: true,
      exact: false,
      message: i.maxSize.message
    }), t.dirty());
    const s = this._def.valueType;
    function a(u) {
      const c = /* @__PURE__ */ new Set();
      for (const l of u) {
        if (l.status === "aborted")
          return g;
        l.status === "dirty" && t.dirty(), c.add(l.value);
      }
      return { status: t.value, value: c };
    }
    const o = [...n.data.values()].map((u, c) => s._parse(new H(n, u, n.path, c)));
    return n.common.async ? Promise.all(o).then((u) => a(u)) : a(o);
  }
  min(e, t) {
    return new _xe({
      ...this._def,
      minSize: { value: e, message: m.toString(t) }
    });
  }
  max(e, t) {
    return new _xe({
      ...this._def,
      maxSize: { value: e, message: m.toString(t) }
    });
  }
  size(e, t) {
    return this.min(e, t).max(e, t);
  }
  nonempty(e) {
    return this.min(1, e);
  }
};
xe.create = (r, e) => new xe({
  valueType: r,
  minSize: null,
  maxSize: null,
  typeName: y.ZodSet,
  ..._(e)
});
var Re = class _Re extends b {
  constructor() {
    super(...arguments), this.validate = this.implement;
  }
  _parse(e) {
    const { ctx: t } = this._processInputParams(e);
    if (t.parsedType !== f.function)
      return h(t, {
        code: d.invalid_type,
        expected: f.function,
        received: t.parsedType
      }), g;
    function n(o, u) {
      return _t({
        data: o,
        path: t.path,
        errorMaps: [
          t.common.contextualErrorMap,
          t.schemaErrorMap,
          gt(),
          ze
        ].filter((c) => !!c),
        issueData: {
          code: d.invalid_arguments,
          argumentsError: u
        }
      });
    }
    function i(o, u) {
      return _t({
        data: o,
        path: t.path,
        errorMaps: [
          t.common.contextualErrorMap,
          t.schemaErrorMap,
          gt(),
          ze
        ].filter((c) => !!c),
        issueData: {
          code: d.invalid_return_type,
          returnTypeError: u
        }
      });
    }
    const s = { errorMap: t.common.contextualErrorMap }, a = t.data;
    return this._def.returns instanceof Ne ? D(async (...o) => {
      const u = new F([]), c = await this._def.args.parseAsync(o, s).catch((v) => {
        throw u.addIssue(n(o, v)), u;
      }), l = await a(...c);
      return await this._def.returns._def.type.parseAsync(l, s).catch((v) => {
        throw u.addIssue(i(l, v)), u;
      });
    }) : D((...o) => {
      const u = this._def.args.safeParse(o, s);
      if (!u.success)
        throw new F([n(o, u.error)]);
      const c = a(...u.data), l = this._def.returns.safeParse(c, s);
      if (!l.success)
        throw new F([i(c, l.error)]);
      return l.data;
    });
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...e) {
    return new _Re({
      ...this._def,
      args: M.create(e).rest(ge.create())
    });
  }
  returns(e) {
    return new _Re({
      ...this._def,
      returns: e
    });
  }
  implement(e) {
    return this.parse(e);
  }
  strictImplement(e) {
    return this.parse(e);
  }
  static create(e, t, n) {
    return new _Re({
      args: e || M.create([]).rest(ge.create()),
      returns: t || ge.create(),
      typeName: y.ZodFunction,
      ..._(n)
    });
  }
};
var Ge = class extends b {
  get schema() {
    return this._def.getter();
  }
  _parse(e) {
    const { ctx: t } = this._processInputParams(e);
    return this._def.getter()._parse({ data: t.data, path: t.path, parent: t });
  }
};
Ge.create = (r, e) => new Ge({
  getter: r,
  typeName: y.ZodLazy,
  ..._(e)
});
var Je = class extends b {
  _parse(e) {
    if (e.data !== this._def.value) {
      const t = this._getOrReturnCtx(e);
      return h(t, {
        received: t.data,
        code: d.invalid_literal,
        expected: this._def.value
      }), g;
    }
    return { status: "valid", value: e.data };
  }
  get value() {
    return this._def.value;
  }
};
Je.create = (r, e) => new Je({
  value: r,
  typeName: y.ZodLiteral,
  ..._(e)
});
function hr(r, e) {
  return new de({
    values: r,
    typeName: y.ZodEnum,
    ..._(e)
  });
}
var de = class _de extends b {
  _parse(e) {
    if (typeof e.data != "string") {
      const t = this._getOrReturnCtx(e), n = this._def.values;
      return h(t, {
        expected: T.joinValues(n),
        received: t.parsedType,
        code: d.invalid_type
      }), g;
    }
    if (this._def.values.indexOf(e.data) === -1) {
      const t = this._getOrReturnCtx(e), n = this._def.values;
      return h(t, {
        received: t.data,
        code: d.invalid_enum_value,
        options: n
      }), g;
    }
    return D(e.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const e = {};
    for (const t of this._def.values)
      e[t] = t;
    return e;
  }
  get Values() {
    const e = {};
    for (const t of this._def.values)
      e[t] = t;
    return e;
  }
  get Enum() {
    const e = {};
    for (const t of this._def.values)
      e[t] = t;
    return e;
  }
  extract(e) {
    return _de.create(e);
  }
  exclude(e) {
    return _de.create(this.options.filter((t) => !e.includes(t)));
  }
};
de.create = hr;
var Me = class extends b {
  _parse(e) {
    const t = T.getValidEnumValues(this._def.values), n = this._getOrReturnCtx(e);
    if (n.parsedType !== f.string && n.parsedType !== f.number) {
      const i = T.objectValues(t);
      return h(n, {
        expected: T.joinValues(i),
        received: n.parsedType,
        code: d.invalid_type
      }), g;
    }
    if (t.indexOf(e.data) === -1) {
      const i = T.objectValues(t);
      return h(n, {
        received: n.data,
        code: d.invalid_enum_value,
        options: i
      }), g;
    }
    return D(e.data);
  }
  get enum() {
    return this._def.values;
  }
};
Me.create = (r, e) => new Me({
  values: r,
  typeName: y.ZodNativeEnum,
  ..._(e)
});
var Ne = class extends b {
  unwrap() {
    return this._def.type;
  }
  _parse(e) {
    const { ctx: t } = this._processInputParams(e);
    if (t.parsedType !== f.promise && t.common.async === false)
      return h(t, {
        code: d.invalid_type,
        expected: f.promise,
        received: t.parsedType
      }), g;
    const n = t.parsedType === f.promise ? t.data : Promise.resolve(t.data);
    return D(n.then((i) => this._def.type.parseAsync(i, {
      path: t.path,
      errorMap: t.common.contextualErrorMap
    })));
  }
};
Ne.create = (r, e) => new Ne({
  type: r,
  typeName: y.ZodPromise,
  ..._(e)
});
var X = class extends b {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === y.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(e) {
    const { status: t, ctx: n } = this._processInputParams(e), i = this._def.effect || null;
    if (i.type === "preprocess") {
      const a = i.transform(n.data);
      return n.common.async ? Promise.resolve(a).then((o) => this._def.schema._parseAsync({
        data: o,
        path: n.path,
        parent: n
      })) : this._def.schema._parseSync({
        data: a,
        path: n.path,
        parent: n
      });
    }
    const s = {
      addIssue: (a) => {
        h(n, a), a.fatal ? t.abort() : t.dirty();
      },
      get path() {
        return n.path;
      }
    };
    if (s.addIssue = s.addIssue.bind(s), i.type === "refinement") {
      const a = (o) => {
        const u = i.refinement(o, s);
        if (n.common.async)
          return Promise.resolve(u);
        if (u instanceof Promise)
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        return o;
      };
      if (n.common.async === false) {
        const o = this._def.schema._parseSync({
          data: n.data,
          path: n.path,
          parent: n
        });
        return o.status === "aborted" ? g : (o.status === "dirty" && t.dirty(), a(o.value), { status: t.value, value: o.value });
      } else
        return this._def.schema._parseAsync({ data: n.data, path: n.path, parent: n }).then((o) => o.status === "aborted" ? g : (o.status === "dirty" && t.dirty(), a(o.value).then(() => ({ status: t.value, value: o.value }))));
    }
    if (i.type === "transform")
      if (n.common.async === false) {
        const a = this._def.schema._parseSync({
          data: n.data,
          path: n.path,
          parent: n
        });
        if (!wt(a))
          return a;
        const o = i.transform(a.value, s);
        if (o instanceof Promise)
          throw new Error("Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.");
        return { status: t.value, value: o };
      } else
        return this._def.schema._parseAsync({ data: n.data, path: n.path, parent: n }).then((a) => wt(a) ? Promise.resolve(i.transform(a.value, s)).then((o) => ({ status: t.value, value: o })) : a);
    T.assertNever(i);
  }
};
X.create = (r, e, t) => new X({
  schema: r,
  typeName: y.ZodEffects,
  effect: e,
  ..._(t)
});
X.createWithPreprocess = (r, e, t) => new X({
  schema: e,
  effect: { type: "preprocess", transform: r },
  typeName: y.ZodEffects,
  ..._(t)
});
var re = class extends b {
  _parse(e) {
    return this._getType(e) === f.undefined ? D(void 0) : this._def.innerType._parse(e);
  }
  unwrap() {
    return this._def.innerType;
  }
};
re.create = (r, e) => new re({
  innerType: r,
  typeName: y.ZodOptional,
  ..._(e)
});
var ke = class extends b {
  _parse(e) {
    return this._getType(e) === f.null ? D(null) : this._def.innerType._parse(e);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ke.create = (r, e) => new ke({
  innerType: r,
  typeName: y.ZodNullable,
  ..._(e)
});
var Xe = class extends b {
  _parse(e) {
    const { ctx: t } = this._processInputParams(e);
    let n = t.data;
    return t.parsedType === f.undefined && (n = this._def.defaultValue()), this._def.innerType._parse({
      data: n,
      path: t.path,
      parent: t
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
};
Xe.create = (r, e) => new Xe({
  innerType: r,
  typeName: y.ZodDefault,
  defaultValue: typeof e.default == "function" ? e.default : () => e.default,
  ..._(e)
});
var Ct = class extends b {
  _parse(e) {
    const { ctx: t } = this._processInputParams(e), n = {
      ...t,
      common: {
        ...t.common,
        issues: []
      }
    }, i = this._def.innerType._parse({
      data: n.data,
      path: n.path,
      parent: {
        ...n
      }
    });
    return bt(i) ? i.then((s) => ({
      status: "valid",
      value: s.status === "valid" ? s.value : this._def.catchValue({
        get error() {
          return new F(n.common.issues);
        },
        input: n.data
      })
    })) : {
      status: "valid",
      value: i.status === "valid" ? i.value : this._def.catchValue({
        get error() {
          return new F(n.common.issues);
        },
        input: n.data
      })
    };
  }
  removeCatch() {
    return this._def.innerType;
  }
};
Ct.create = (r, e) => new Ct({
  innerType: r,
  typeName: y.ZodCatch,
  catchValue: typeof e.catch == "function" ? e.catch : () => e.catch,
  ..._(e)
});
var At = class extends b {
  _parse(e) {
    if (this._getType(e) !== f.nan) {
      const n = this._getOrReturnCtx(e);
      return h(n, {
        code: d.invalid_type,
        expected: f.nan,
        received: n.parsedType
      }), g;
    }
    return { status: "valid", value: e.data };
  }
};
At.create = (r) => new At({
  typeName: y.ZodNaN,
  ..._(r)
});
var mn = class extends b {
  _parse(e) {
    const { ctx: t } = this._processInputParams(e), n = t.data;
    return this._def.type._parse({
      data: n,
      path: t.path,
      parent: t
    });
  }
  unwrap() {
    return this._def.type;
  }
};
var nt = class _nt extends b {
  _parse(e) {
    const { status: t, ctx: n } = this._processInputParams(e);
    if (n.common.async)
      return (async () => {
        const s = await this._def.in._parseAsync({
          data: n.data,
          path: n.path,
          parent: n
        });
        return s.status === "aborted" ? g : s.status === "dirty" ? (t.dirty(), rn(s.value)) : this._def.out._parseAsync({
          data: s.value,
          path: n.path,
          parent: n
        });
      })();
    {
      const i = this._def.in._parseSync({
        data: n.data,
        path: n.path,
        parent: n
      });
      return i.status === "aborted" ? g : i.status === "dirty" ? (t.dirty(), {
        status: "dirty",
        value: i.value
      }) : this._def.out._parseSync({
        data: i.value,
        path: n.path,
        parent: n
      });
    }
  }
  static create(e, t) {
    return new _nt({
      in: e,
      out: t,
      typeName: y.ZodPipeline
    });
  }
};
A.lazycreate;
var y;
(function(r) {
  r.ZodString = "ZodString", r.ZodNumber = "ZodNumber", r.ZodNaN = "ZodNaN", r.ZodBigInt = "ZodBigInt", r.ZodBoolean = "ZodBoolean", r.ZodDate = "ZodDate", r.ZodSymbol = "ZodSymbol", r.ZodUndefined = "ZodUndefined", r.ZodNull = "ZodNull", r.ZodAny = "ZodAny", r.ZodUnknown = "ZodUnknown", r.ZodNever = "ZodNever", r.ZodVoid = "ZodVoid", r.ZodArray = "ZodArray", r.ZodObject = "ZodObject", r.ZodUnion = "ZodUnion", r.ZodDiscriminatedUnion = "ZodDiscriminatedUnion", r.ZodIntersection = "ZodIntersection", r.ZodTuple = "ZodTuple", r.ZodRecord = "ZodRecord", r.ZodMap = "ZodMap", r.ZodSet = "ZodSet", r.ZodFunction = "ZodFunction", r.ZodLazy = "ZodLazy", r.ZodLiteral = "ZodLiteral", r.ZodEnum = "ZodEnum", r.ZodEffects = "ZodEffects", r.ZodNativeEnum = "ZodNativeEnum", r.ZodOptional = "ZodOptional", r.ZodNullable = "ZodNullable", r.ZodDefault = "ZodDefault", r.ZodCatch = "ZodCatch", r.ZodPromise = "ZodPromise", r.ZodBranded = "ZodBranded", r.ZodPipeline = "ZodPipeline";
})(y || (y = {}));
var E = J.create;
var it = we.create;
At.create;
be.create;
var Rt = xt.create;
Pe.create;
kt.create;
je.create;
Fe.create;
St.create;
ge.create;
ie.create;
Tt.create;
var Le = K.create;
var S = A.create;
A.strictCreate;
var V = Ke.create;
zt.create;
He.create;
M.create;
Ye.create;
It.create;
xe.create;
Re.create;
Ge.create;
var I = Je.create;
de.create;
Me.create;
Ne.create;
X.create;
re.create;
ke.create;
X.createWithPreprocess;
nt.create;
var yn = S({
  address: E(),
  label: E(),
  appearanceId: it()
});
var jt = S({
  publicKey: E(),
  signature: E(),
  curve: V([I("curve25519"), I("secp256k1")])
});
var vn = S({
  accountAddress: E(),
  proof: jt
});
var st = S({ identityAddress: E(), label: E() });
var tr = {
  western: "western",
  eastern: "eastern"
};
var gn = V([
  I(tr.eastern),
  I(tr.western)
]);
var _n = S({
  variant: gn,
  familyName: E(),
  nickname: E(),
  givenNames: E()
});
var Pt = S({
  quantifier: V([I("exactly"), I("atLeast")]),
  quantity: it().gte(1)
});
var Nt = S({
  challenge: E().optional(),
  numberOfAccounts: Pt
});
var Lt = S({
  accounts: Le(yn),
  challenge: E().optional(),
  proofs: Le(vn).optional()
}).refine((r) => {
  var e;
  return r.challenge || r != null && r.proofs ? r.challenge && ((e = r == null ? void 0 : r.proofs) == null ? void 0 : e.length) : true;
}, "missing challenge or proofs");
var Ot = S({
  isRequestingName: Rt().optional(),
  numberOfRequestedEmailAddresses: Pt.optional(),
  numberOfRequestedPhoneNumbers: Pt.optional()
});
var Zt = S({
  name: _n.optional(),
  emailAddresses: Le(E()).optional(),
  phoneNumbers: Le(E()).optional()
});
var wn = S({
  accounts: Rt(),
  personaData: Rt()
});
var cs = S({
  persona: st,
  challenge: E().optional(),
  proof: jt.optional()
}).refine((r) => r.challenge || r.proof ? r.challenge && r.proof : true, "missing challenge or proof");
var bn = S({
  discriminator: I("unauthorizedRequest"),
  oneTimeAccounts: Nt.optional(),
  oneTimePersonaData: Ot.optional()
});
var xn = S({
  discriminator: I("usePersona"),
  identityAddress: E()
});
var kn = S({
  discriminator: I("loginWithoutChallenge")
});
var Sn = S({
  discriminator: I("loginWithChallenge"),
  challenge: E()
});
var Tn = V([
  kn,
  Sn
]);
var En = V([
  xn,
  Tn
]);
var In = S({
  discriminator: I("authorizedRequest"),
  auth: En,
  reset: wn.optional(),
  oneTimeAccounts: Nt.optional(),
  ongoingAccounts: Nt.optional(),
  oneTimePersonaData: Ot.optional(),
  ongoingPersonaData: Ot.optional()
});
var Cn = V([
  bn,
  In
]);
var An = S({
  transactionManifest: E(),
  version: it(),
  blobs: Le(E()).optional(),
  message: E().optional()
});
var Rn = S({
  discriminator: I("transaction"),
  send: An
});
var Pn = S({
  transactionIntentHash: E()
});
var Nn = S({
  discriminator: I("transaction"),
  send: Pn
});
var Ln = S({
  discriminator: I("cancelRequest")
});
var On = V([
  Cn,
  Rn,
  Ln
]);
var pr = S({
  version: I(2),
  networkId: it(),
  dAppDefinitionAddress: E()
});
var Zn = S({
  interactionId: E(),
  metadata: pr,
  items: On
});
var Dn = S({
  discriminator: I("unauthorizedRequest"),
  oneTimeAccounts: Lt.optional(),
  oneTimePersonaData: Zt.optional()
});
var Vn = S({
  discriminator: I("loginWithoutChallenge"),
  persona: st
});
var $n = S({
  discriminator: I("loginWithChallenge"),
  persona: st,
  challenge: E(),
  proof: jt
});
var Wn = V([
  Vn,
  $n
]);
var qn = S({
  discriminator: I("usePersona"),
  persona: st
});
var Un = V([
  qn,
  Wn
]);
var Bn = S({
  discriminator: I("authorizedRequest"),
  auth: Un,
  oneTimeAccounts: Lt.optional(),
  ongoingAccounts: Lt.optional(),
  oneTimePersonaData: Zt.optional(),
  ongoingPersonaData: Zt.optional()
});
var zn = V([
  Dn,
  Bn
]);
var jn = V([
  zn,
  Nn
]);
var Fn = S({
  discriminator: I("success"),
  interactionId: E(),
  items: jn
});
var Kn = S({
  discriminator: I("failure"),
  interactionId: E(),
  error: E(),
  message: E().optional()
});
var mr = V([
  Fn,
  Kn
]);
var Ze = {
  receivedByExtension: "receivedByExtension",
  receivedByWallet: "receivedByWallet",
  requestCancelSuccess: "requestCancelSuccess",
  requestCancelFail: "requestCancelFail"
};
var Hn = S({
  eventType: V([
    I(Ze.receivedByExtension),
    I(Ze.receivedByWallet),
    I(Ze.requestCancelSuccess),
    I(Ze.requestCancelFail)
  ]),
  interactionId: E()
});
V([
  Hn,
  mr
]);
var lt = {
  outgoingMessage: "radix#chromeExtension#send",
  incomingMessage: "radix#chromeExtension#receive"
};
var Yn = (r, e) => G.fromPromise(
  r.parseAsync(e),
  (t) => t.issues
);
var yr = (r) => (e, t, n = crypto.randomUUID()) => {
  const i = {
    items: t,
    interactionId: n,
    metadata: e
  };
  return Yn(Zn, i).mapErr((s) => (r == null || r.error(" invalidWalletInteraction", s), Qe(
    qe.walletRequestValidation,
    i.interactionId
  )));
};
var us = Object.freeze(Object.defineProperty({
  __proto__: null,
  walletInteractionFactory: yr
}, Symbol.toStringTag, { value: "Module" }));
var Gn = (r) => r;
var qe = {
  rejectedByUser: "rejectedByUser",
  missingExtension: "missingExtension",
  canceledByUser: "canceledByUser",
  walletRequestValidation: "walletRequestValidation",
  walletResponseValidation: "walletResponseValidation",
  wrongNetwork: "wrongNetwork",
  failedToPrepareTransaction: "failedToPrepareTransaction",
  failedToCompileTransaction: "failedToCompileTransaction",
  failedToSignTransaction: "failedToSignTransaction",
  failedToSubmitTransaction: "failedToSubmitTransaction",
  failedToPollSubmittedTransaction: "failedToPollSubmittedTransaction",
  submittedTransactionWasDuplicate: "submittedTransactionWasDuplicate",
  submittedTransactionHasFailedTransactionStatus: "submittedTransactionHasFailedTransactionStatus",
  submittedTransactionHasRejectedTransactionStatus: "submittedTransactionHasRejectedTransactionStatus",
  failedToFindAccountWithEnoughFundsToLockFee: "failedToFindAccountWithEnoughFundsToLockFee",
  wrongAccountType: "wrongAccountType",
  unknownWebsite: "unknownWebsite",
  radixJsonNotFound: "radixJsonNotFound",
  unknownDappDefinitionAddress: "unknownDappDefinitionAddress",
  invalidPersona: "invalidPersona"
};
var Jn = (/* @__PURE__ */ new Map()).set(qe.missingExtension, "extension could not be found").set(qe.rejectedByUser, "user rejected request").set(qe.canceledByUser, "user has canceled the request");
var Qe = (r, e, t) => ({
  error: r,
  interactionId: e,
  message: t || Jn.get(r) || ""
});
var rr = (r) => G.fromPromise(
  mr.parseAsync(r),
  (e) => e.issues
).andThen(
  (e) => e.discriminator === "success" ? j(e) : q(e)
).mapErr(() => Qe("walletResponseValidation", ""));
var Mn = (r, e) => {
  const t = r.logger, n = yr(t);
  return {
    request: (a, o = {}) => n(r, a).andThen(
      (u) => e.send(u, o)
    ).andThen(rr).map((u) => u.items),
    sendTransaction: (a, o = {}) => n(r, {
      discriminator: "transaction",
      send: a
    }).andThen(
      (u) => e.send(u, o)
    ).andThen(rr).map(
      (u) => u.items.send
    )
  };
};
var Dt = function(r, e) {
  return Dt = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t, n) {
    t.__proto__ = n;
  } || function(t, n) {
    for (var i in n)
      Object.prototype.hasOwnProperty.call(n, i) && (t[i] = n[i]);
  }, Dt(r, e);
};
function se(r, e) {
  if (typeof e != "function" && e !== null)
    throw new TypeError("Class extends value " + String(e) + " is not a constructor or null");
  Dt(r, e);
  function t() {
    this.constructor = r;
  }
  r.prototype = e === null ? Object.create(e) : (t.prototype = e.prototype, new t());
}
function Xn(r, e, t, n) {
  function i(s) {
    return s instanceof t ? s : new t(function(a) {
      a(s);
    });
  }
  return new (t || (t = Promise))(function(s, a) {
    function o(l) {
      try {
        c(n.next(l));
      } catch (p) {
        a(p);
      }
    }
    function u(l) {
      try {
        c(n.throw(l));
      } catch (p) {
        a(p);
      }
    }
    function c(l) {
      l.done ? s(l.value) : i(l.value).then(o, u);
    }
    c((n = n.apply(r, e || [])).next());
  });
}
function vr(r, e) {
  var t = { label: 0, sent: function() {
    if (s[0] & 1)
      throw s[1];
    return s[1];
  }, trys: [], ops: [] }, n, i, s, a;
  return a = { next: o(0), throw: o(1), return: o(2) }, typeof Symbol == "function" && (a[Symbol.iterator] = function() {
    return this;
  }), a;
  function o(c) {
    return function(l) {
      return u([c, l]);
    };
  }
  function u(c) {
    if (n)
      throw new TypeError("Generator is already executing.");
    for (; a && (a = 0, c[0] && (t = 0)), t; )
      try {
        if (n = 1, i && (s = c[0] & 2 ? i.return : c[0] ? i.throw || ((s = i.return) && s.call(i), 0) : i.next) && !(s = s.call(i, c[1])).done)
          return s;
        switch (i = 0, s && (c = [c[0] & 2, s.value]), c[0]) {
          case 0:
          case 1:
            s = c;
            break;
          case 4:
            return t.label++, { value: c[1], done: false };
          case 5:
            t.label++, i = c[1], c = [0];
            continue;
          case 7:
            c = t.ops.pop(), t.trys.pop();
            continue;
          default:
            if (s = t.trys, !(s = s.length > 0 && s[s.length - 1]) && (c[0] === 6 || c[0] === 2)) {
              t = 0;
              continue;
            }
            if (c[0] === 3 && (!s || c[1] > s[0] && c[1] < s[3])) {
              t.label = c[1];
              break;
            }
            if (c[0] === 6 && t.label < s[1]) {
              t.label = s[1], s = c;
              break;
            }
            if (s && t.label < s[2]) {
              t.label = s[2], t.ops.push(c);
              break;
            }
            s[2] && t.ops.pop(), t.trys.pop();
            continue;
        }
        c = e.call(r, t);
      } catch (l) {
        c = [6, l], i = 0;
      } finally {
        n = s = 0;
      }
    if (c[0] & 5)
      throw c[1];
    return { value: c[0] ? c[1] : void 0, done: true };
  }
}
function Se(r) {
  var e = typeof Symbol == "function" && Symbol.iterator, t = e && r[e], n = 0;
  if (t)
    return t.call(r);
  if (r && typeof r.length == "number")
    return {
      next: function() {
        return r && n >= r.length && (r = void 0), { value: r && r[n++], done: !r };
      }
    };
  throw new TypeError(e ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function fe(r, e) {
  var t = typeof Symbol == "function" && r[Symbol.iterator];
  if (!t)
    return r;
  var n = t.call(r), i, s = [], a;
  try {
    for (; (e === void 0 || e-- > 0) && !(i = n.next()).done; )
      s.push(i.value);
  } catch (o) {
    a = { error: o };
  } finally {
    try {
      i && !i.done && (t = n.return) && t.call(n);
    } finally {
      if (a)
        throw a.error;
    }
  }
  return s;
}
function he(r, e, t) {
  if (t || arguments.length === 2)
    for (var n = 0, i = e.length, s; n < i; n++)
      (s || !(n in e)) && (s || (s = Array.prototype.slice.call(e, 0, n)), s[n] = e[n]);
  return r.concat(s || Array.prototype.slice.call(e));
}
function _e(r) {
  return this instanceof _e ? (this.v = r, this) : new _e(r);
}
function Qn(r, e, t) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var n = t.apply(r, e || []), i, s = [];
  return i = {}, a("next"), a("throw"), a("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i;
  function a(v) {
    n[v] && (i[v] = function(x) {
      return new Promise(function(C, k) {
        s.push([v, x, C, k]) > 1 || o(v, x);
      });
    });
  }
  function o(v, x) {
    try {
      u(n[v](x));
    } catch (C) {
      p(s[0][3], C);
    }
  }
  function u(v) {
    v.value instanceof _e ? Promise.resolve(v.value.v).then(c, l) : p(s[0][2], v);
  }
  function c(v) {
    o("next", v);
  }
  function l(v) {
    o("throw", v);
  }
  function p(v, x) {
    v(x), s.shift(), s.length && o(s[0][0], s[0][1]);
  }
}
function ei(r) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var e = r[Symbol.asyncIterator], t;
  return e ? e.call(r) : (r = typeof Se == "function" ? Se(r) : r[Symbol.iterator](), t = {}, n("next"), n("throw"), n("return"), t[Symbol.asyncIterator] = function() {
    return this;
  }, t);
  function n(s) {
    t[s] = r[s] && function(a) {
      return new Promise(function(o, u) {
        a = r[s](a), i(o, u, a.done, a.value);
      });
    };
  }
  function i(s, a, o, u) {
    Promise.resolve(u).then(function(c) {
      s({ value: c, done: o });
    }, a);
  }
}
function R(r) {
  return typeof r == "function";
}
function Ft(r) {
  var e = function(n) {
    Error.call(n), n.stack = new Error().stack;
  }, t = r(e);
  return t.prototype = Object.create(Error.prototype), t.prototype.constructor = t, t;
}
var dt = Ft(function(r) {
  return function(t) {
    r(this), this.message = t ? t.length + ` errors occurred during unsubscription:
` + t.map(function(n, i) {
      return i + 1 + ") " + n.toString();
    }).join(`
  `) : "", this.name = "UnsubscriptionError", this.errors = t;
  };
});
function et(r, e) {
  if (r) {
    var t = r.indexOf(e);
    0 <= t && r.splice(t, 1);
  }
}
var Ee = function() {
  function r(e) {
    this.initialTeardown = e, this.closed = false, this._parentage = null, this._finalizers = null;
  }
  return r.prototype.unsubscribe = function() {
    var e, t, n, i, s;
    if (!this.closed) {
      this.closed = true;
      var a = this._parentage;
      if (a)
        if (this._parentage = null, Array.isArray(a))
          try {
            for (var o = Se(a), u = o.next(); !u.done; u = o.next()) {
              var c = u.value;
              c.remove(this);
            }
          } catch (k) {
            e = { error: k };
          } finally {
            try {
              u && !u.done && (t = o.return) && t.call(o);
            } finally {
              if (e)
                throw e.error;
            }
          }
        else
          a.remove(this);
      var l = this.initialTeardown;
      if (R(l))
        try {
          l();
        } catch (k) {
          s = k instanceof dt ? k.errors : [k];
        }
      var p = this._finalizers;
      if (p) {
        this._finalizers = null;
        try {
          for (var v = Se(p), x = v.next(); !x.done; x = v.next()) {
            var C = x.value;
            try {
              nr(C);
            } catch (k) {
              s = s ?? [], k instanceof dt ? s = he(he([], fe(s)), fe(k.errors)) : s.push(k);
            }
          }
        } catch (k) {
          n = { error: k };
        } finally {
          try {
            x && !x.done && (i = v.return) && i.call(v);
          } finally {
            if (n)
              throw n.error;
          }
        }
      }
      if (s)
        throw new dt(s);
    }
  }, r.prototype.add = function(e) {
    var t;
    if (e && e !== this)
      if (this.closed)
        nr(e);
      else {
        if (e instanceof r) {
          if (e.closed || e._hasParent(this))
            return;
          e._addParent(this);
        }
        (this._finalizers = (t = this._finalizers) !== null && t !== void 0 ? t : []).push(e);
      }
  }, r.prototype._hasParent = function(e) {
    var t = this._parentage;
    return t === e || Array.isArray(t) && t.includes(e);
  }, r.prototype._addParent = function(e) {
    var t = this._parentage;
    this._parentage = Array.isArray(t) ? (t.push(e), t) : t ? [t, e] : e;
  }, r.prototype._removeParent = function(e) {
    var t = this._parentage;
    t === e ? this._parentage = null : Array.isArray(t) && et(t, e);
  }, r.prototype.remove = function(e) {
    var t = this._finalizers;
    t && et(t, e), e instanceof r && e._removeParent(this);
  }, r.EMPTY = function() {
    var e = new r();
    return e.closed = true, e;
  }(), r;
}();
var gr = Ee.EMPTY;
function _r(r) {
  return r instanceof Ee || r && "closed" in r && R(r.remove) && R(r.add) && R(r.unsubscribe);
}
function nr(r) {
  R(r) ? r() : r.unsubscribe();
}
var wr = {
  onUnhandledError: null,
  onStoppedNotification: null,
  Promise: void 0,
  useDeprecatedSynchronousErrorHandling: false,
  useDeprecatedNextContext: false
};
var Vt = {
  setTimeout: function(r, e) {
    for (var t = [], n = 2; n < arguments.length; n++)
      t[n - 2] = arguments[n];
    var i = Vt.delegate;
    return i != null && i.setTimeout ? i.setTimeout.apply(i, he([r, e], fe(t))) : setTimeout.apply(void 0, he([r, e], fe(t)));
  },
  clearTimeout: function(r) {
    var e = Vt.delegate;
    return ((e == null ? void 0 : e.clearTimeout) || clearTimeout)(r);
  },
  delegate: void 0
};
function br(r) {
  Vt.setTimeout(function() {
    throw r;
  });
}
function $t() {
}
function Ue(r) {
  r();
}
var Kt = function(r) {
  se(e, r);
  function e(t) {
    var n = r.call(this) || this;
    return n.isStopped = false, t ? (n.destination = t, _r(t) && t.add(n)) : n.destination = ii, n;
  }
  return e.create = function(t, n, i) {
    return new Te(t, n, i);
  }, e.prototype.next = function(t) {
    this.isStopped || this._next(t);
  }, e.prototype.error = function(t) {
    this.isStopped || (this.isStopped = true, this._error(t));
  }, e.prototype.complete = function() {
    this.isStopped || (this.isStopped = true, this._complete());
  }, e.prototype.unsubscribe = function() {
    this.closed || (this.isStopped = true, r.prototype.unsubscribe.call(this), this.destination = null);
  }, e.prototype._next = function(t) {
    this.destination.next(t);
  }, e.prototype._error = function(t) {
    try {
      this.destination.error(t);
    } finally {
      this.unsubscribe();
    }
  }, e.prototype._complete = function() {
    try {
      this.destination.complete();
    } finally {
      this.unsubscribe();
    }
  }, e;
}(Ee);
var ti = Function.prototype.bind;
function ft(r, e) {
  return ti.call(r, e);
}
var ri = function() {
  function r(e) {
    this.partialObserver = e;
  }
  return r.prototype.next = function(e) {
    var t = this.partialObserver;
    if (t.next)
      try {
        t.next(e);
      } catch (n) {
        De(n);
      }
  }, r.prototype.error = function(e) {
    var t = this.partialObserver;
    if (t.error)
      try {
        t.error(e);
      } catch (n) {
        De(n);
      }
    else
      De(e);
  }, r.prototype.complete = function() {
    var e = this.partialObserver;
    if (e.complete)
      try {
        e.complete();
      } catch (t) {
        De(t);
      }
  }, r;
}();
var Te = function(r) {
  se(e, r);
  function e(t, n, i) {
    var s = r.call(this) || this, a;
    if (R(t) || !t)
      a = {
        next: t ?? void 0,
        error: n ?? void 0,
        complete: i ?? void 0
      };
    else {
      var o;
      s && wr.useDeprecatedNextContext ? (o = Object.create(t), o.unsubscribe = function() {
        return s.unsubscribe();
      }, a = {
        next: t.next && ft(t.next, o),
        error: t.error && ft(t.error, o),
        complete: t.complete && ft(t.complete, o)
      }) : a = t;
    }
    return s.destination = new ri(a), s;
  }
  return e;
}(Kt);
function De(r) {
  br(r);
}
function ni(r) {
  throw r;
}
var ii = {
  closed: true,
  next: $t,
  error: ni,
  complete: $t
};
var Ht = function() {
  return typeof Symbol == "function" && Symbol.observable || "@@observable";
}();
function at(r) {
  return r;
}
function si(r) {
  return r.length === 0 ? at : r.length === 1 ? r[0] : function(t) {
    return r.reduce(function(n, i) {
      return i(n);
    }, t);
  };
}
var $ = function() {
  function r(e) {
    e && (this._subscribe = e);
  }
  return r.prototype.lift = function(e) {
    var t = new r();
    return t.source = this, t.operator = e, t;
  }, r.prototype.subscribe = function(e, t, n) {
    var i = this, s = oi(e) ? e : new Te(e, t, n);
    return Ue(function() {
      var a = i, o = a.operator, u = a.source;
      s.add(o ? o.call(s, u) : u ? i._subscribe(s) : i._trySubscribe(s));
    }), s;
  }, r.prototype._trySubscribe = function(e) {
    try {
      return this._subscribe(e);
    } catch (t) {
      e.error(t);
    }
  }, r.prototype.forEach = function(e, t) {
    var n = this;
    return t = ir(t), new t(function(i, s) {
      var a = new Te({
        next: function(o) {
          try {
            e(o);
          } catch (u) {
            s(u), a.unsubscribe();
          }
        },
        error: s,
        complete: i
      });
      n.subscribe(a);
    });
  }, r.prototype._subscribe = function(e) {
    var t;
    return (t = this.source) === null || t === void 0 ? void 0 : t.subscribe(e);
  }, r.prototype[Ht] = function() {
    return this;
  }, r.prototype.pipe = function() {
    for (var e = [], t = 0; t < arguments.length; t++)
      e[t] = arguments[t];
    return si(e)(this);
  }, r.prototype.toPromise = function(e) {
    var t = this;
    return e = ir(e), new e(function(n, i) {
      var s;
      t.subscribe(function(a) {
        return s = a;
      }, function(a) {
        return i(a);
      }, function() {
        return n(s);
      });
    });
  }, r.create = function(e) {
    return new r(e);
  }, r;
}();
function ir(r) {
  var e;
  return (e = r ?? wr.Promise) !== null && e !== void 0 ? e : Promise;
}
function ai(r) {
  return r && R(r.next) && R(r.error) && R(r.complete);
}
function oi(r) {
  return r && r instanceof Kt || ai(r) && _r(r);
}
function ci(r) {
  return R(r == null ? void 0 : r.lift);
}
function U(r) {
  return function(e) {
    if (ci(e))
      return e.lift(function(t) {
        try {
          return r(t, this);
        } catch (n) {
          this.error(n);
        }
      });
    throw new TypeError("Unable to lift unknown Observable type");
  };
}
function Y(r, e, t, n, i) {
  return new ui(r, e, t, n, i);
}
var ui = function(r) {
  se(e, r);
  function e(t, n, i, s, a, o) {
    var u = r.call(this, t) || this;
    return u.onFinalize = a, u.shouldUnsubscribe = o, u._next = n ? function(c) {
      try {
        n(c);
      } catch (l) {
        t.error(l);
      }
    } : r.prototype._next, u._error = s ? function(c) {
      try {
        s(c);
      } catch (l) {
        t.error(l);
      } finally {
        this.unsubscribe();
      }
    } : r.prototype._error, u._complete = i ? function() {
      try {
        i();
      } catch (c) {
        t.error(c);
      } finally {
        this.unsubscribe();
      }
    } : r.prototype._complete, u;
  }
  return e.prototype.unsubscribe = function() {
    var t;
    if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) {
      var n = this.closed;
      r.prototype.unsubscribe.call(this), !n && ((t = this.onFinalize) === null || t === void 0 || t.call(this));
    }
  }, e;
}(Kt);
var li = Ft(function(r) {
  return function() {
    r(this), this.name = "ObjectUnsubscribedError", this.message = "object unsubscribed";
  };
});
var le = function(r) {
  se(e, r);
  function e() {
    var t = r.call(this) || this;
    return t.closed = false, t.currentObservers = null, t.observers = [], t.isStopped = false, t.hasError = false, t.thrownError = null, t;
  }
  return e.prototype.lift = function(t) {
    var n = new sr(this, this);
    return n.operator = t, n;
  }, e.prototype._throwIfClosed = function() {
    if (this.closed)
      throw new li();
  }, e.prototype.next = function(t) {
    var n = this;
    Ue(function() {
      var i, s;
      if (n._throwIfClosed(), !n.isStopped) {
        n.currentObservers || (n.currentObservers = Array.from(n.observers));
        try {
          for (var a = Se(n.currentObservers), o = a.next(); !o.done; o = a.next()) {
            var u = o.value;
            u.next(t);
          }
        } catch (c) {
          i = { error: c };
        } finally {
          try {
            o && !o.done && (s = a.return) && s.call(a);
          } finally {
            if (i)
              throw i.error;
          }
        }
      }
    });
  }, e.prototype.error = function(t) {
    var n = this;
    Ue(function() {
      if (n._throwIfClosed(), !n.isStopped) {
        n.hasError = n.isStopped = true, n.thrownError = t;
        for (var i = n.observers; i.length; )
          i.shift().error(t);
      }
    });
  }, e.prototype.complete = function() {
    var t = this;
    Ue(function() {
      if (t._throwIfClosed(), !t.isStopped) {
        t.isStopped = true;
        for (var n = t.observers; n.length; )
          n.shift().complete();
      }
    });
  }, e.prototype.unsubscribe = function() {
    this.isStopped = this.closed = true, this.observers = this.currentObservers = null;
  }, Object.defineProperty(e.prototype, "observed", {
    get: function() {
      var t;
      return ((t = this.observers) === null || t === void 0 ? void 0 : t.length) > 0;
    },
    enumerable: false,
    configurable: true
  }), e.prototype._trySubscribe = function(t) {
    return this._throwIfClosed(), r.prototype._trySubscribe.call(this, t);
  }, e.prototype._subscribe = function(t) {
    return this._throwIfClosed(), this._checkFinalizedStatuses(t), this._innerSubscribe(t);
  }, e.prototype._innerSubscribe = function(t) {
    var n = this, i = this, s = i.hasError, a = i.isStopped, o = i.observers;
    return s || a ? gr : (this.currentObservers = null, o.push(t), new Ee(function() {
      n.currentObservers = null, et(o, t);
    }));
  }, e.prototype._checkFinalizedStatuses = function(t) {
    var n = this, i = n.hasError, s = n.thrownError, a = n.isStopped;
    i ? t.error(s) : a && t.complete();
  }, e.prototype.asObservable = function() {
    var t = new $();
    return t.source = this, t;
  }, e.create = function(t, n) {
    return new sr(t, n);
  }, e;
}($);
var sr = function(r) {
  se(e, r);
  function e(t, n) {
    var i = r.call(this) || this;
    return i.destination = t, i.source = n, i;
  }
  return e.prototype.next = function(t) {
    var n, i;
    (i = (n = this.destination) === null || n === void 0 ? void 0 : n.next) === null || i === void 0 || i.call(n, t);
  }, e.prototype.error = function(t) {
    var n, i;
    (i = (n = this.destination) === null || n === void 0 ? void 0 : n.error) === null || i === void 0 || i.call(n, t);
  }, e.prototype.complete = function() {
    var t, n;
    (n = (t = this.destination) === null || t === void 0 ? void 0 : t.complete) === null || n === void 0 || n.call(t);
  }, e.prototype._subscribe = function(t) {
    var n, i;
    return (i = (n = this.source) === null || n === void 0 ? void 0 : n.subscribe(t)) !== null && i !== void 0 ? i : gr;
  }, e;
}(le);
var xr = {
  now: function() {
    return (xr.delegate || Date).now();
  },
  delegate: void 0
};
var di = function(r) {
  se(e, r);
  function e(t, n) {
    return r.call(this) || this;
  }
  return e.prototype.schedule = function(t, n) {
    return this;
  }, e;
}(Ee);
var tt = {
  setInterval: function(r, e) {
    for (var t = [], n = 2; n < arguments.length; n++)
      t[n - 2] = arguments[n];
    var i = tt.delegate;
    return i != null && i.setInterval ? i.setInterval.apply(i, he([r, e], fe(t))) : setInterval.apply(void 0, he([r, e], fe(t)));
  },
  clearInterval: function(r) {
    var e = tt.delegate;
    return ((e == null ? void 0 : e.clearInterval) || clearInterval)(r);
  },
  delegate: void 0
};
var fi = function(r) {
  se(e, r);
  function e(t, n) {
    var i = r.call(this, t, n) || this;
    return i.scheduler = t, i.work = n, i.pending = false, i;
  }
  return e.prototype.schedule = function(t, n) {
    var i;
    if (n === void 0 && (n = 0), this.closed)
      return this;
    this.state = t;
    var s = this.id, a = this.scheduler;
    return s != null && (this.id = this.recycleAsyncId(a, s, n)), this.pending = true, this.delay = n, this.id = (i = this.id) !== null && i !== void 0 ? i : this.requestAsyncId(a, this.id, n), this;
  }, e.prototype.requestAsyncId = function(t, n, i) {
    return i === void 0 && (i = 0), tt.setInterval(t.flush.bind(t, this), i);
  }, e.prototype.recycleAsyncId = function(t, n, i) {
    if (i === void 0 && (i = 0), i != null && this.delay === i && this.pending === false)
      return n;
    n != null && tt.clearInterval(n);
  }, e.prototype.execute = function(t, n) {
    if (this.closed)
      return new Error("executing a cancelled action");
    this.pending = false;
    var i = this._execute(t, n);
    if (i)
      return i;
    this.pending === false && this.id != null && (this.id = this.recycleAsyncId(this.scheduler, this.id, null));
  }, e.prototype._execute = function(t, n) {
    var i = false, s;
    try {
      this.work(t);
    } catch (a) {
      i = true, s = a || new Error("Scheduled action threw falsy error");
    }
    if (i)
      return this.unsubscribe(), s;
  }, e.prototype.unsubscribe = function() {
    if (!this.closed) {
      var t = this, n = t.id, i = t.scheduler, s = i.actions;
      this.work = this.state = this.scheduler = null, this.pending = false, et(s, this), n != null && (this.id = this.recycleAsyncId(i, n, null)), this.delay = null, r.prototype.unsubscribe.call(this);
    }
  }, e;
}(di);
var ar = function() {
  function r(e, t) {
    t === void 0 && (t = r.now), this.schedulerActionCtor = e, this.now = t;
  }
  return r.prototype.schedule = function(e, t, n) {
    return t === void 0 && (t = 0), new this.schedulerActionCtor(this, e).schedule(n, t);
  }, r.now = xr.now, r;
}();
var hi = function(r) {
  se(e, r);
  function e(t, n) {
    n === void 0 && (n = ar.now);
    var i = r.call(this, t, n) || this;
    return i.actions = [], i._active = false, i;
  }
  return e.prototype.flush = function(t) {
    var n = this.actions;
    if (this._active) {
      n.push(t);
      return;
    }
    var i;
    this._active = true;
    do
      if (i = t.execute(t.state, t.delay))
        break;
    while (t = n.shift());
    if (this._active = false, i) {
      for (; t = n.shift(); )
        t.unsubscribe();
      throw i;
    }
  }, e;
}(ar);
var pi = new hi(fi);
var mi = pi;
var kr = new $(function(r) {
  return r.complete();
});
function Sr(r) {
  return r && R(r.schedule);
}
function Tr(r) {
  return r[r.length - 1];
}
function Er(r) {
  return Sr(Tr(r)) ? r.pop() : void 0;
}
function yi(r, e) {
  return typeof Tr(r) == "number" ? r.pop() : e;
}
var Ir = function(r) {
  return r && typeof r.length == "number" && typeof r != "function";
};
function Cr(r) {
  return R(r == null ? void 0 : r.then);
}
function Ar(r) {
  return R(r[Ht]);
}
function Rr(r) {
  return Symbol.asyncIterator && R(r == null ? void 0 : r[Symbol.asyncIterator]);
}
function Pr(r) {
  return new TypeError("You provided " + (r !== null && typeof r == "object" ? "an invalid object" : "'" + r + "'") + " where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.");
}
function vi() {
  return typeof Symbol != "function" || !Symbol.iterator ? "@@iterator" : Symbol.iterator;
}
var Nr = vi();
function Lr(r) {
  return R(r == null ? void 0 : r[Nr]);
}
function Or(r) {
  return Qn(this, arguments, function() {
    var t, n, i, s;
    return vr(this, function(a) {
      switch (a.label) {
        case 0:
          t = r.getReader(), a.label = 1;
        case 1:
          a.trys.push([1, , 9, 10]), a.label = 2;
        case 2:
          return [4, _e(t.read())];
        case 3:
          return n = a.sent(), i = n.value, s = n.done, s ? [4, _e(void 0)] : [3, 5];
        case 4:
          return [2, a.sent()];
        case 5:
          return [4, _e(i)];
        case 6:
          return [4, a.sent()];
        case 7:
          return a.sent(), [3, 2];
        case 8:
          return [3, 10];
        case 9:
          return t.releaseLock(), [7];
        case 10:
          return [2];
      }
    });
  });
}
function Zr(r) {
  return R(r == null ? void 0 : r.getReader);
}
function Q(r) {
  if (r instanceof $)
    return r;
  if (r != null) {
    if (Ar(r))
      return gi(r);
    if (Ir(r))
      return _i(r);
    if (Cr(r))
      return wi(r);
    if (Rr(r))
      return Dr(r);
    if (Lr(r))
      return bi(r);
    if (Zr(r))
      return xi(r);
  }
  throw Pr(r);
}
function gi(r) {
  return new $(function(e) {
    var t = r[Ht]();
    if (R(t.subscribe))
      return t.subscribe(e);
    throw new TypeError("Provided object does not correctly implement Symbol.observable");
  });
}
function _i(r) {
  return new $(function(e) {
    for (var t = 0; t < r.length && !e.closed; t++)
      e.next(r[t]);
    e.complete();
  });
}
function wi(r) {
  return new $(function(e) {
    r.then(function(t) {
      e.closed || (e.next(t), e.complete());
    }, function(t) {
      return e.error(t);
    }).then(null, br);
  });
}
function bi(r) {
  return new $(function(e) {
    var t, n;
    try {
      for (var i = Se(r), s = i.next(); !s.done; s = i.next()) {
        var a = s.value;
        if (e.next(a), e.closed)
          return;
      }
    } catch (o) {
      t = { error: o };
    } finally {
      try {
        s && !s.done && (n = i.return) && n.call(i);
      } finally {
        if (t)
          throw t.error;
      }
    }
    e.complete();
  });
}
function Dr(r) {
  return new $(function(e) {
    ki(r, e).catch(function(t) {
      return e.error(t);
    });
  });
}
function xi(r) {
  return Dr(Or(r));
}
function ki(r, e) {
  var t, n, i, s;
  return Xn(this, void 0, void 0, function() {
    var a, o;
    return vr(this, function(u) {
      switch (u.label) {
        case 0:
          u.trys.push([0, 5, 6, 11]), t = ei(r), u.label = 1;
        case 1:
          return [4, t.next()];
        case 2:
          if (n = u.sent(), !!n.done)
            return [3, 4];
          if (a = n.value, e.next(a), e.closed)
            return [2];
          u.label = 3;
        case 3:
          return [3, 1];
        case 4:
          return [3, 11];
        case 5:
          return o = u.sent(), i = { error: o }, [3, 11];
        case 6:
          return u.trys.push([6, , 9, 10]), n && !n.done && (s = t.return) ? [4, s.call(t)] : [3, 8];
        case 7:
          u.sent(), u.label = 8;
        case 8:
          return [3, 10];
        case 9:
          if (i)
            throw i.error;
          return [7];
        case 10:
          return [7];
        case 11:
          return e.complete(), [2];
      }
    });
  });
}
function ne(r, e, t, n, i) {
  n === void 0 && (n = 0), i === void 0 && (i = false);
  var s = e.schedule(function() {
    t(), i ? r.add(this.schedule(null, n)) : this.unsubscribe();
  }, n);
  if (r.add(s), !i)
    return s;
}
function Vr(r, e) {
  return e === void 0 && (e = 0), U(function(t, n) {
    t.subscribe(Y(n, function(i) {
      return ne(n, r, function() {
        return n.next(i);
      }, e);
    }, function() {
      return ne(n, r, function() {
        return n.complete();
      }, e);
    }, function(i) {
      return ne(n, r, function() {
        return n.error(i);
      }, e);
    }));
  });
}
function $r(r, e) {
  return e === void 0 && (e = 0), U(function(t, n) {
    n.add(r.schedule(function() {
      return t.subscribe(n);
    }, e));
  });
}
function Si(r, e) {
  return Q(r).pipe($r(e), Vr(e));
}
function Ti(r, e) {
  return Q(r).pipe($r(e), Vr(e));
}
function Ei(r, e) {
  return new $(function(t) {
    var n = 0;
    return e.schedule(function() {
      n === r.length ? t.complete() : (t.next(r[n++]), t.closed || this.schedule());
    });
  });
}
function Ii(r, e) {
  return new $(function(t) {
    var n;
    return ne(t, e, function() {
      n = r[Nr](), ne(t, e, function() {
        var i, s, a;
        try {
          i = n.next(), s = i.value, a = i.done;
        } catch (o) {
          t.error(o);
          return;
        }
        a ? t.complete() : t.next(s);
      }, 0, true);
    }), function() {
      return R(n == null ? void 0 : n.return) && n.return();
    };
  });
}
function Wr(r, e) {
  if (!r)
    throw new Error("Iterable cannot be null");
  return new $(function(t) {
    ne(t, e, function() {
      var n = r[Symbol.asyncIterator]();
      ne(t, e, function() {
        n.next().then(function(i) {
          i.done ? t.complete() : t.next(i.value);
        });
      }, 0, true);
    });
  });
}
function Ci(r, e) {
  return Wr(Or(r), e);
}
function Ai(r, e) {
  if (r != null) {
    if (Ar(r))
      return Si(r, e);
    if (Ir(r))
      return Ei(r, e);
    if (Cr(r))
      return Ti(r, e);
    if (Rr(r))
      return Wr(r, e);
    if (Lr(r))
      return Ii(r, e);
    if (Zr(r))
      return Ci(r, e);
  }
  throw Pr(r);
}
function qr(r, e) {
  return e ? Ai(r, e) : Q(r);
}
function Ri() {
  for (var r = [], e = 0; e < arguments.length; e++)
    r[e] = arguments[e];
  var t = Er(r);
  return qr(r, t);
}
var Yt = Ft(function(r) {
  return function() {
    r(this), this.name = "EmptyError", this.message = "no elements in sequence";
  };
});
function Ur(r, e) {
  var t = typeof e == "object";
  return new Promise(function(n, i) {
    var s = new Te({
      next: function(a) {
        n(a), s.unsubscribe();
      },
      error: i,
      complete: function() {
        t ? n(e.defaultValue) : i(new Yt());
      }
    });
    r.subscribe(s);
  });
}
function Pi(r) {
  return r instanceof Date && !isNaN(r);
}
function me(r, e) {
  return U(function(t, n) {
    var i = 0;
    t.subscribe(Y(n, function(s) {
      n.next(r.call(e, s, i++));
    }));
  });
}
function Ni(r, e, t, n, i, s, a, o) {
  var u = [], c = 0, l = 0, p = false, v = function() {
    p && !u.length && !c && e.complete();
  }, x = function(k) {
    return c < n ? C(k) : u.push(k);
  }, C = function(k) {
    s && e.next(k), c++;
    var O = false;
    Q(t(k, l++)).subscribe(Y(e, function(P) {
      i == null || i(P), s ? x(P) : e.next(P);
    }, function() {
      O = true;
    }, void 0, function() {
      if (O)
        try {
          c--;
          for (var P = function() {
            var w = u.shift();
            a ? ne(e, a, function() {
              return C(w);
            }) : C(w);
          }; u.length && c < n; )
            P();
          v();
        } catch (w) {
          e.error(w);
        }
    }));
  };
  return r.subscribe(Y(e, x, function() {
    p = true, v();
  })), function() {
    o == null || o();
  };
}
function Br(r, e, t) {
  return t === void 0 && (t = 1 / 0), R(e) ? Br(function(n, i) {
    return me(function(s, a) {
      return e(n, s, i, a);
    })(Q(r(n, i)));
  }, t) : (typeof e == "number" && (t = e), U(function(n, i) {
    return Ni(n, i, r, t);
  }));
}
function Li(r) {
  return r === void 0 && (r = 1 / 0), Br(at, r);
}
function Oi(r, e, t) {
  r === void 0 && (r = 0), t === void 0 && (t = mi);
  var n = -1;
  return e != null && (Sr(e) ? t = e : n = e), new $(function(i) {
    var s = Pi(r) ? +r - t.now() : r;
    s < 0 && (s = 0);
    var a = 0;
    return t.schedule(function() {
      i.closed || (i.next(a++), 0 <= n ? this.schedule(void 0, n) : i.complete());
    }, s);
  });
}
function Ve() {
  for (var r = [], e = 0; e < arguments.length; e++)
    r[e] = arguments[e];
  var t = Er(r), n = yi(r, 1 / 0), i = r;
  return i.length ? i.length === 1 ? Q(i[0]) : Li(n)(qr(i, t)) : kr;
}
function ye(r, e) {
  return U(function(t, n) {
    var i = 0;
    t.subscribe(Y(n, function(s) {
      return r.call(e, s, i++) && n.next(s);
    }));
  });
}
function Zi(r) {
  return U(function(e, t) {
    var n = false;
    e.subscribe(Y(t, function(i) {
      n = true, t.next(i);
    }, function() {
      n || t.next(r), t.complete();
    }));
  });
}
function Di(r) {
  return r <= 0 ? function() {
    return kr;
  } : U(function(e, t) {
    var n = 0;
    e.subscribe(Y(t, function(i) {
      ++n <= r && (t.next(i), r <= n && t.complete());
    }));
  });
}
function Vi(r) {
  return r === void 0 && (r = $i), U(function(e, t) {
    var n = false;
    e.subscribe(Y(t, function(i) {
      n = true, t.next(i);
    }, function() {
      return n ? t.complete() : t.error(r());
    }));
  });
}
function $i() {
  return new Yt();
}
function or(r, e) {
  var t = arguments.length >= 2;
  return function(n) {
    return n.pipe(r ? ye(function(i, s) {
      return r(i, s, n);
    }) : at, Di(1), t ? Zi(e) : Vi(function() {
      return new Yt();
    }));
  };
}
function Wi(r) {
  r === void 0 && (r = {});
  var e = r.connector, t = e === void 0 ? function() {
    return new le();
  } : e, n = r.resetOnError, i = n === void 0 ? true : n, s = r.resetOnComplete, a = s === void 0 ? true : s, o = r.resetOnRefCountZero, u = o === void 0 ? true : o;
  return function(c) {
    var l, p, v, x = 0, C = false, k = false, O = function() {
      p == null || p.unsubscribe(), p = void 0;
    }, P = function() {
      O(), l = v = void 0, C = k = false;
    }, w = function() {
      var N = l;
      P(), N == null || N.unsubscribe();
    };
    return U(function(N, ee) {
      x++, !k && !C && O();
      var B = v = v ?? t();
      ee.add(function() {
        x--, x === 0 && !k && !C && (p = ht(w, u));
      }), B.subscribe(ee), !l && x > 0 && (l = new Te({
        next: function(z) {
          return B.next(z);
        },
        error: function(z) {
          k = true, O(), p = ht(P, i, z), B.error(z);
        },
        complete: function() {
          C = true, O(), p = ht(P, a), B.complete();
        }
      }), Q(N).subscribe(l));
    })(c);
  };
}
function ht(r, e) {
  for (var t = [], n = 2; n < arguments.length; n++)
    t[n - 2] = arguments[n];
  if (e === true) {
    r();
    return;
  }
  if (e !== false) {
    var i = new Te({
      next: function() {
        i.unsubscribe(), r();
      }
    });
    return Q(e.apply(void 0, he([], fe(t)))).subscribe(i);
  }
}
function qi(r) {
  return U(function(e, t) {
    Q(r).subscribe(Y(t, function() {
      return t.complete();
    }, $t)), !t.closed && e.subscribe(t);
  });
}
function Ae(r, e, t) {
  var n = R(r) || e || t ? { next: r, error: e, complete: t } : r;
  return n ? U(function(i, s) {
    var a;
    (a = n.subscribe) === null || a === void 0 || a.call(n);
    var o = true;
    i.subscribe(Y(s, function(u) {
      var c;
      (c = n.next) === null || c === void 0 || c.call(n, u), s.next(u);
    }, function() {
      var u;
      o = false, (u = n.complete) === null || u === void 0 || u.call(n), s.complete();
    }, function(u) {
      var c;
      o = false, (c = n.error) === null || c === void 0 || c.call(n, u), s.error(u);
    }, function() {
      var u, c;
      o && ((u = n.unsubscribe) === null || u === void 0 || u.call(n)), (c = n.finalize) === null || c === void 0 || c.call(n);
    }));
  }) : at;
}
var Ui = () => ({
  outgoingMessageSubject: new le(),
  incomingMessageSubject: new le(),
  responseSubject: new le(),
  messageLifeCycleEventSubject: new le()
});
var Bi = (r) => G.fromPromise(Ur(r), Gn).andThen(
  (e) => e
);
var zi = {
  extensionDetectionTime: 100
};
var ji = (r) => {
  const e = r == null ? void 0 : r.logger, t = (r == null ? void 0 : r.subjects) ?? Ui(), n = new Ee();
  n.add(
    t.incomingMessageSubject.pipe(
      Ae((a) => {
        "eventType" in a ? (e == null || e.debug(" messageLifecycleEvent", a), t.messageLifeCycleEventSubject.next(a)) : (e == null || e.debug(" walletResponse", a), t.responseSubject.next(a));
      })
    ).subscribe()
  ), n.add(
    t.outgoingMessageSubject.pipe(
      Ae((a) => {
        e == null || e.debug(" walletRequest", a), window.dispatchEvent(
          new CustomEvent(lt.outgoingMessage, {
            detail: a
          })
        );
      })
    ).subscribe()
  );
  const i = (a) => {
    const o = a.detail;
    t.incomingMessageSubject.next(o);
  };
  return addEventListener(lt.incomingMessage, i), {
    send: (a, o) => {
      const u = new le(), c = t.responseSubject.pipe(
        ye(
          (w) => w.interactionId === a.interactionId
        ),
        me(
          (w) => w.discriminator === "success" ? j(w) : q(w)
        )
      ), l = t.messageLifeCycleEventSubject.pipe(
        ye(
          ({ interactionId: w, eventType: N }) => a.interactionId === w && ["requestCancelSuccess", "requestCancelFail"].includes(N)
        ),
        me((w) => {
          const N = Qe("canceledByUser", w.interactionId);
          return e == null || e.debug(" walletRequestCanceled", N), u.next(q(N)), w;
        })
      ), p = () => (t.outgoingMessageSubject.next({
        interactionId: a.interactionId,
        items: { discriminator: "cancelRequest" },
        metadata: a.metadata
      }), G.fromSafePromise(
        Ur(
          Ve(
            c.pipe(me(() => "requestCancelFail")),
            l.pipe(me(({ eventType: w }) => w))
          )
        )
      ));
      o.requestControl && o.requestControl({
        cancelRequest: () => p().andThen(
          (w) => w === "requestCancelSuccess" ? j("requestCancelSuccess") : q("requestCancelFail")
        ),
        getRequest: () => a
      });
      const v = Ve(
        c,
        u
      ).pipe(or()), x = t.messageLifeCycleEventSubject.pipe(
        ye(
          ({ interactionId: w }) => a.interactionId === w
        ),
        Ae((w) => {
          o.eventCallback && o.eventCallback(w.eventType);
        }),
        qi(c),
        Wi()
      ), C = x.subscribe(), k = Oi(zi.extensionDetectionTime).pipe(
        me(
          () => q(Qe("missingExtension", a.interactionId))
        )
      ), O = Ve(
        k,
        x
      ).pipe(
        or(),
        ye((w) => !("eventType" in w))
      ), P = Ri(a).pipe(
        Ae((w) => {
          t.outgoingMessageSubject.next(w);
        }),
        ye((w) => false)
      );
      return Bi(
        Ve(
          v,
          O,
          P
        ).pipe(
          Ae(() => {
            C.unsubscribe();
          })
        )
      );
    },
    destroy: () => {
      n.unsubscribe(), removeEventListener(lt.incomingMessage, i);
    }
  };
};
var Wt = {
  reset: [0, 0],
  bold: [1, 22],
  dim: [2, 22],
  italic: [3, 23],
  underline: [4, 24],
  overline: [53, 55],
  inverse: [7, 27],
  hidden: [8, 28],
  strikethrough: [9, 29],
  black: [30, 39],
  red: [31, 39],
  green: [32, 39],
  yellow: [33, 39],
  blue: [34, 39],
  magenta: [35, 39],
  cyan: [36, 39],
  white: [37, 39],
  blackBright: [90, 39],
  redBright: [91, 39],
  greenBright: [92, 39],
  yellowBright: [93, 39],
  blueBright: [94, 39],
  magentaBright: [95, 39],
  cyanBright: [96, 39],
  whiteBright: [97, 39],
  bgBlack: [40, 49],
  bgRed: [41, 49],
  bgGreen: [42, 49],
  bgYellow: [43, 49],
  bgBlue: [44, 49],
  bgMagenta: [45, 49],
  bgCyan: [46, 49],
  bgWhite: [47, 49],
  bgBlackBright: [100, 49],
  bgRedBright: [101, 49],
  bgGreenBright: [102, 49],
  bgYellowBright: [103, 49],
  bgBlueBright: [104, 49],
  bgMagentaBright: [105, 49],
  bgCyanBright: [106, 49],
  bgWhiteBright: [107, 49]
};
function qt(r, e, t, n = false) {
  const i = String(e), s = (o, u) => `\x1B[${u[0]}m${o}\x1B[${u[1]}m`, a = (o, u) => u != null && typeof u == "string" ? s(o, Wt[u]) : u != null && Array.isArray(u) ? u.reduce((c, l) => a(c, l), o) : u != null && u[o.trim()] != null ? a(o, u[o.trim()]) : u != null && u["*"] != null ? a(o, u["*"]) : o;
  return i.replace(/{{(.+?)}}/g, (o, u) => {
    var l;
    const c = t[u] != null ? t[u] : n ? "" : o;
    return r.stylePrettyLogs ? a(c, (l = r == null ? void 0 : r.prettyLogStyles) == null ? void 0 : l[u]) + s("", Wt.reset) : c;
  });
}
function zr(r) {
  const e = /* @__PURE__ */ new Set();
  return JSON.stringify(r, (t, n) => {
    if (typeof n == "object" && n !== null) {
      if (e.has(n))
        return "[Circular]";
      e.add(n);
    }
    return n;
  });
}
function L(r, e) {
  const t = {
    seen: [],
    stylize: jr
  };
  return e != null && Yr(t, e), ve(t.showHidden) && (t.showHidden = false), ve(t.depth) && (t.depth = 2), ve(t.colors) && (t.colors = true), ve(t.customInspect) && (t.customInspect = true), t.colors && (t.stylize = Ki), rt(t, r, t.depth);
}
L.colors = Wt;
L.styles = {
  special: "cyan",
  number: "yellow",
  boolean: "yellow",
  undefined: "grey",
  null: "bold",
  string: "green",
  date: "magenta",
  regexp: "red"
};
function Fi(r) {
  return typeof r == "boolean";
}
function ve(r) {
  return r == null;
}
function jr(r) {
  return r;
}
function Ki(r, e) {
  var n, i, s, a;
  const t = L.styles[e];
  return t != null && ((i = (n = L == null ? void 0 : L.colors) == null ? void 0 : n[t]) == null ? void 0 : i[0]) != null && ((a = (s = L == null ? void 0 : L.colors) == null ? void 0 : s[t]) == null ? void 0 : a[1]) != null ? "\x1B[" + L.colors[t][0] + "m" + r + "\x1B[" + L.colors[t][1] + "m" : r;
}
function $e(r) {
  return typeof r == "function";
}
function Fr(r) {
  return typeof r == "string";
}
function Hi(r) {
  return typeof r == "number";
}
function Kr(r) {
  return r === null;
}
function Hr(r, e) {
  return Object.prototype.hasOwnProperty.call(r, e);
}
function pt(r) {
  return ot(r) && Gt(r) === "[object RegExp]";
}
function ot(r) {
  return typeof r == "object" && r !== null;
}
function mt(r) {
  return ot(r) && (Gt(r) === "[object Error]" || r instanceof Error);
}
function cr(r) {
  return ot(r) && Gt(r) === "[object Date]";
}
function Gt(r) {
  return Object.prototype.toString.call(r);
}
function Yi(r) {
  const e = {};
  return r.forEach((t) => {
    e[t] = true;
  }), e;
}
function Gi(r, e, t, n, i) {
  const s = [];
  for (let a = 0, o = e.length; a < o; ++a)
    Hr(e, String(a)) ? s.push(Ut(r, e, t, n, String(a), true)) : s.push("");
  return i.forEach((a) => {
    a.match(/^\d+$/) || s.push(Ut(r, e, t, n, a, true));
  }), s;
}
function yt(r) {
  return "[" + Error.prototype.toString.call(r) + "]";
}
function rt(r, e, t = 0) {
  if (r.customInspect && e != null && $e(e) && (e == null ? void 0 : e.inspect) !== L && !(e != null && e.constructor && (e == null ? void 0 : e.constructor.prototype) === e)) {
    if (typeof e.inspect != "function" && e.toString != null)
      return e.toString();
    let l = e == null ? void 0 : e.inspect(t, r);
    return Fr(l) || (l = rt(r, l, t)), l;
  }
  const n = te(r, e);
  if (n)
    return n;
  let i = Object.keys(e);
  const s = Yi(i);
  try {
    r.showHidden && Object.getOwnPropertyNames && (i = Object.getOwnPropertyNames(e));
  } catch {
  }
  if (mt(e) && (i.indexOf("message") >= 0 || i.indexOf("description") >= 0))
    return yt(e);
  if (i.length === 0)
    if ($e(r.stylize)) {
      if ($e(e)) {
        const l = e.name ? ": " + e.name : "";
        return r.stylize("[Function" + l + "]", "special");
      }
      if (pt(e))
        return r.stylize(RegExp.prototype.toString.call(e), "regexp");
      if (cr(e))
        return r.stylize(Date.prototype.toString.call(e), "date");
      if (mt(e))
        return yt(e);
    } else
      return e;
  let a = "", o = false, u = [`{
`, `
}`];
  if (Array.isArray(e) && (o = true, u = [`[
`, `
]`]), $e(e) && (a = " [Function" + (e.name ? ": " + e.name : "") + "]"), pt(e) && (a = " " + RegExp.prototype.toString.call(e)), cr(e) && (a = " " + Date.prototype.toUTCString.call(e)), mt(e) && (a = " " + yt(e)), i.length === 0 && (!o || e.length == 0))
    return u[0] + a + u[1];
  if (t < 0)
    return pt(e) ? r.stylize(RegExp.prototype.toString.call(e), "regexp") : r.stylize("[Object]", "special");
  r.seen.push(e);
  let c;
  return o ? c = Gi(r, e, t, s, i) : c = i.map((l) => Ut(r, e, t, s, l, o)), r.seen.pop(), Ji(c, a, u);
}
function Ut(r, e, t, n, i, s) {
  let a, o, u;
  u = { value: void 0 };
  try {
    u.value = e[i];
  } catch {
  }
  try {
    Object.getOwnPropertyDescriptor && (u = Object.getOwnPropertyDescriptor(e, i) || u);
  } catch {
  }
  if (u.get ? u.set ? o = r.stylize("[Getter/Setter]", "special") : o = r.stylize("[Getter]", "special") : u.set && (o = r.stylize("[Setter]", "special")), Hr(n, i) || (a = "[" + i + "]"), o || (r.seen.indexOf(u.value) < 0 ? (Kr(t) ? o = rt(r, u.value, void 0) : o = rt(r, u.value, t - 1), o.indexOf(`
`) > -1 && (s ? o = o.split(`
`).map((c) => "  " + c).join(`
`).substr(2) : o = `
` + o.split(`
`).map((c) => "   " + c).join(`
`))) : o = r.stylize("[Circular]", "special")), ve(a)) {
    if (s && i.match(/^\d+$/))
      return o;
    a = JSON.stringify("" + i), a.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (a = a.substr(1, a.length - 2), a = r.stylize(a, "name")) : (a = a.replace(/'/g, "\\'").replace(/\\"/g, "\\'").replace(/(^"|"$)/g, "'"), a = r.stylize(a, "string"));
  }
  return a + ": " + o;
}
function te(r, e) {
  if (ve(e))
    return r.stylize("undefined", "undefined");
  if (Fr(e)) {
    const t = "'" + JSON.stringify(e).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, "\\'") + "'";
    return r.stylize(t, "string");
  }
  if (Hi(e))
    return r.stylize("" + e, "number");
  if (Fi(e))
    return r.stylize("" + e, "boolean");
  if (Kr(e))
    return r.stylize("null", "null");
}
function Ji(r, e, t) {
  return t[0] + (e === "" ? "" : e + `
`) + "  " + r.join(`,
  `) + " " + t[1];
}
function Yr(r, e) {
  if (!e || !ot(e))
    return r;
  const t = Object.keys(e);
  let n = t.length;
  for (; n--; )
    r[t[n]] = e[t[n]];
  return r;
}
function Mi(r, ...e) {
  const t = {
    seen: [],
    stylize: jr
  };
  r != null && Yr(t, r);
  const n = e[0];
  let i = 0, s = "", a = "";
  if (typeof n == "string") {
    if (e.length === 1)
      return n;
    let o, u = 0;
    for (let c = 0; c < n.length - 1; c++)
      if (n.charCodeAt(c) === 37) {
        const l = n.charCodeAt(++c);
        if (i + 1 !== e.length) {
          switch (l) {
            case 115: {
              const p = e[++i];
              typeof p == "number" || typeof p == "bigint" ? o = te(t, p) : typeof p != "object" || p === null ? o = String(p) : o = L(p, {
                ...r,
                compact: 3,
                colors: false,
                depth: 0
              });
              break;
            }
            case 106:
              o = zr(e[++i]);
              break;
            case 100: {
              const p = e[++i];
              typeof p == "bigint" ? o = te(t, p) : typeof p == "symbol" ? o = "NaN" : o = te(t, p);
              break;
            }
            case 79:
              o = L(e[++i], r);
              break;
            case 111:
              o = L(e[++i], {
                ...r,
                showHidden: true,
                showProxy: true,
                depth: 4
              });
              break;
            case 105: {
              const p = e[++i];
              typeof p == "bigint" ? o = te(t, p) : typeof p == "symbol" ? o = "NaN" : o = te(t, parseInt(o));
              break;
            }
            case 102: {
              const p = e[++i];
              typeof p == "symbol" ? o = "NaN" : o = te(t, parseInt(p));
              break;
            }
            case 99:
              i += 1, o = "";
              break;
            case 37:
              s += n.slice(u, c), u = c + 1;
              continue;
            default:
              continue;
          }
          u !== c - 1 && (s += n.slice(u, c - 1)), s += o, u = c + 1;
        } else
          l === 37 && (s += n.slice(u, c), u = c + 1);
      }
    u !== 0 && (i++, a = " ", u < n.length && (s += n.slice(u)));
  }
  for (; i < e.length; ) {
    const o = e[i];
    s += a, s += typeof o != "string" ? L(o, r) : o, a = " ", i++;
  }
  return s;
}
var ur;
var Xi = {
  runtime: [typeof window, typeof document].includes("undefined") ? "Generic" : "Browser",
  browser: (ur = globalThis == null ? void 0 : globalThis.navigator) == null ? void 0 : ur.userAgent
};
var Qi = /(?:(?:file|https?|global code|[^@]+)@)?(?:file:)?((?:\/[^:/]+){2,})(?::(\d+))?(?::(\d+))?/;
function es(r, e, t, n, i, s) {
  return Object.assign({}, Xi, {
    name: i,
    parentNames: s,
    date: /* @__PURE__ */ new Date(),
    logLevelId: r,
    logLevelName: e,
    path: n ? void 0 : ts(t)
  });
}
function ts(r, e = Error()) {
  var t, n, i;
  return Jr((i = (n = (t = e == null ? void 0 : e.stack) == null ? void 0 : t.split(`
`)) == null ? void 0 : n.filter((s) => !s.includes("Error: "))) == null ? void 0 : i[r]);
}
function Gr(r) {
  var e, t, n;
  return (n = (t = (e = r == null ? void 0 : r.stack) == null ? void 0 : e.split(`
`)) == null ? void 0 : t.filter((i) => !i.includes("Error: "))) == null ? void 0 : n.reduce((i, s) => (i.push(Jr(s)), i), []);
}
function Jr(r) {
  const e = globalThis.location.origin, t = {
    fullFilePath: void 0,
    fileName: void 0,
    fileNameWithLine: void 0,
    fileColumn: void 0,
    fileLine: void 0,
    filePath: void 0,
    filePathWithLine: void 0,
    method: void 0
  };
  if (r != null) {
    const n = r.match(Qi);
    if (n) {
      t.filePath = n[1].replace(/\?.*$/, ""), t.fullFilePath = `${e}${t.filePath}`;
      const i = t.filePath.split("/");
      t.fileName = i[i.length - 1], t.fileLine = n[2], t.fileColumn = n[3], t.filePathWithLine = `${t.filePath}:${t.fileLine}`, t.fileNameWithLine = `${t.fileName}:${t.fileLine}`;
    }
  }
  return t;
}
function Bt(r) {
  return r instanceof Error;
}
function rs(r, e) {
  return r.reduce((t, n) => (Bt(n) ? t.errors.push(ns(n, e)) : t.args.push(n), t), { args: [], errors: [] });
}
function ns(r, e) {
  const t = Gr(r).map((i) => qt(e, e.prettyErrorStackTemplate, { ...i }, true)), n = {
    errorName: ` ${r.name} `,
    errorMessage: r.message,
    errorStack: t.join(`
`)
  };
  return qt(e, e.prettyErrorTemplate, n);
}
function is(r, e, t, n) {
  const i = (t.length > 0 && e.length > 0 ? `
` : "") + t.join(`
`);
  n.prettyInspectOptions.colors = n.stylePrettyLogs, console.log(r + Mi(n.prettyInspectOptions, ...e) + i);
}
function ss(r) {
  console.log(zr(r));
}
function W(r, e = 2, t = 0) {
  return r != null && isNaN(r) ? "" : (r = r != null ? r + t : r, e === 2 ? r == null ? "--" : r < 10 ? "0" + r : r.toString() : r == null ? "---" : r < 10 ? "00" + r : r < 100 ? "0" + r : r.toString());
}
var as = class {
  constructor(e, t, n = 4) {
    var u, c, l, p, v, x, C;
    this.logObj = t, this.stackDepthLevel = n;
    const i = ![typeof window, typeof document].includes("undefined"), s = Object.prototype.toString.call(typeof process < "u" ? process : 0) === "[object process]";
    this.runtime = i ? "browser" : s ? "nodejs" : "unknown";
    const a = i ? (((window == null ? void 0 : window.chrome) || window.Intl && (Intl == null ? void 0 : Intl.v8BreakIterator)) && "CSS" in window) != null : false, o = i ? /^((?!chrome|android).)*safari/i.test(navigator == null ? void 0 : navigator.userAgent) : false;
    this.stackDepthLevel = o ? 4 : this.stackDepthLevel, this.settings = {
      type: (e == null ? void 0 : e.type) ?? "pretty",
      name: e == null ? void 0 : e.name,
      parentNames: e == null ? void 0 : e.parentNames,
      minLevel: (e == null ? void 0 : e.minLevel) ?? 0,
      argumentsArrayName: e == null ? void 0 : e.argumentsArrayName,
      hideLogPositionForProduction: (e == null ? void 0 : e.hideLogPositionForProduction) ?? false,
      prettyLogTemplate: (e == null ? void 0 : e.prettyLogTemplate) ?? "{{yyyy}}.{{mm}}.{{dd}} {{hh}}:{{MM}}:{{ss}}:{{ms}}	{{logLevelName}}	{{filePathWithLine}}{{nameWithDelimiterPrefix}}	",
      prettyErrorTemplate: (e == null ? void 0 : e.prettyErrorTemplate) ?? `
{{errorName}} {{errorMessage}}
error stack:
{{errorStack}}`,
      prettyErrorStackTemplate: (e == null ? void 0 : e.prettyErrorStackTemplate) ?? `   {{fileName}}	{{method}}
	{{filePathWithLine}}`,
      prettyErrorParentNamesSeparator: (e == null ? void 0 : e.prettyErrorParentNamesSeparator) ?? ":",
      prettyErrorLoggerNameDelimiter: (e == null ? void 0 : e.prettyErrorLoggerNameDelimiter) ?? "	",
      stylePrettyLogs: (e == null ? void 0 : e.stylePrettyLogs) ?? true,
      prettyLogTimeZone: (e == null ? void 0 : e.prettyLogTimeZone) ?? "UTC",
      prettyLogStyles: (e == null ? void 0 : e.prettyLogStyles) ?? {
        logLevelName: {
          "*": ["bold", "black", "bgWhiteBright", "dim"],
          SILLY: ["bold", "white"],
          TRACE: ["bold", "whiteBright"],
          DEBUG: ["bold", "green"],
          INFO: ["bold", "blue"],
          WARN: ["bold", "yellow"],
          ERROR: ["bold", "red"],
          FATAL: ["bold", "redBright"]
        },
        dateIsoStr: "white",
        filePathWithLine: "white",
        name: ["white", "bold"],
        nameWithDelimiterPrefix: ["white", "bold"],
        nameWithDelimiterSuffix: ["white", "bold"],
        errorName: ["bold", "bgRedBright", "whiteBright"],
        fileName: ["yellow"],
        fileNameWithLine: "white"
      },
      prettyInspectOptions: (e == null ? void 0 : e.prettyInspectOptions) ?? {
        colors: true,
        compact: false,
        depth: 1 / 0
      },
      metaProperty: (e == null ? void 0 : e.metaProperty) ?? "_meta",
      maskPlaceholder: (e == null ? void 0 : e.maskPlaceholder) ?? "[***]",
      maskValuesOfKeys: (e == null ? void 0 : e.maskValuesOfKeys) ?? ["password"],
      maskValuesOfKeysCaseInsensitive: (e == null ? void 0 : e.maskValuesOfKeysCaseInsensitive) ?? false,
      maskValuesRegEx: e == null ? void 0 : e.maskValuesRegEx,
      prefix: [...(e == null ? void 0 : e.prefix) ?? []],
      attachedTransports: [...(e == null ? void 0 : e.attachedTransports) ?? []],
      overwrite: {
        mask: (u = e == null ? void 0 : e.overwrite) == null ? void 0 : u.mask,
        toLogObj: (c = e == null ? void 0 : e.overwrite) == null ? void 0 : c.toLogObj,
        addMeta: (l = e == null ? void 0 : e.overwrite) == null ? void 0 : l.addMeta,
        formatMeta: (p = e == null ? void 0 : e.overwrite) == null ? void 0 : p.formatMeta,
        formatLogObj: (v = e == null ? void 0 : e.overwrite) == null ? void 0 : v.formatLogObj,
        transportFormatted: (x = e == null ? void 0 : e.overwrite) == null ? void 0 : x.transportFormatted,
        transportJSON: (C = e == null ? void 0 : e.overwrite) == null ? void 0 : C.transportJSON
      }
    }, this.settings.stylePrettyLogs = this.settings.stylePrettyLogs && i && !a ? false : this.settings.stylePrettyLogs;
  }
  log(e, t, ...n) {
    var p, v, x, C, k, O, P, w, N, ee, B, z, Ie, Ce;
    if (e < this.settings.minLevel)
      return;
    const i = [...this.settings.prefix, ...n], s = ((p = this.settings.overwrite) == null ? void 0 : p.mask) != null ? (v = this.settings.overwrite) == null ? void 0 : v.mask(i) : this.settings.maskValuesOfKeys != null && this.settings.maskValuesOfKeys.length > 0 ? this._mask(i) : i, a = this.logObj != null ? this._recursiveCloneAndExecuteFunctions(this.logObj) : void 0, o = ((x = this.settings.overwrite) == null ? void 0 : x.toLogObj) != null ? (C = this.settings.overwrite) == null ? void 0 : C.toLogObj(s, a) : this._toLogObj(s, a), u = ((k = this.settings.overwrite) == null ? void 0 : k.addMeta) != null ? (O = this.settings.overwrite) == null ? void 0 : O.addMeta(o, e, t) : this._addMetaToLogObj(o, e, t);
    let c, l;
    return ((P = this.settings.overwrite) == null ? void 0 : P.formatMeta) != null && (c = (w = this.settings.overwrite) == null ? void 0 : w.formatMeta(u == null ? void 0 : u[this.settings.metaProperty])), ((N = this.settings.overwrite) == null ? void 0 : N.formatLogObj) != null && (l = (ee = this.settings.overwrite) == null ? void 0 : ee.formatLogObj(s, this.settings)), this.settings.type === "pretty" && (c = c ?? this._prettyFormatLogObjMeta(u == null ? void 0 : u[this.settings.metaProperty]), l = l ?? rs(s, this.settings)), c != null && l != null ? ((B = this.settings.overwrite) == null ? void 0 : B.transportFormatted) != null ? (z = this.settings.overwrite) == null || z.transportFormatted(c, l.args, l.errors, this.settings) : is(c, l.args, l.errors, this.settings) : ((Ie = this.settings.overwrite) == null ? void 0 : Ie.transportJSON) != null ? (Ce = this.settings.overwrite) == null || Ce.transportJSON(u) : this.settings.type !== "hidden" && ss(u), this.settings.attachedTransports != null && this.settings.attachedTransports.length > 0 && this.settings.attachedTransports.forEach((Oe) => {
      Oe(u);
    }), u;
  }
  attachTransport(e) {
    this.settings.attachedTransports.push(e);
  }
  getSubLogger(e, t) {
    var s, a, o;
    const n = {
      ...this.settings,
      ...e,
      parentNames: ((s = this.settings) == null ? void 0 : s.parentNames) != null && ((a = this.settings) == null ? void 0 : a.name) != null ? [...this.settings.parentNames, this.settings.name] : ((o = this.settings) == null ? void 0 : o.name) != null ? [this.settings.name] : void 0,
      prefix: [...this.settings.prefix, ...(e == null ? void 0 : e.prefix) ?? []]
    };
    return new this.constructor(n, t ?? this.logObj, this.stackDepthLevel);
  }
  _mask(e) {
    const t = this.settings.maskValuesOfKeysCaseInsensitive !== true ? this.settings.maskValuesOfKeys : this.settings.maskValuesOfKeys.map((n) => n.toLowerCase());
    return e == null ? void 0 : e.map((n) => this._recursiveCloneAndMaskValuesOfKeys(n, t));
  }
  _recursiveCloneAndMaskValuesOfKeys(e, t, n = []) {
    return n.includes(e) ? { ...e } : (typeof e == "object" && e != null && n.push(e), void 0 ? e : e instanceof Map ? new Map(e) : e instanceof Set ? new Set(e) : Array.isArray(e) ? e.map((i) => this._recursiveCloneAndMaskValuesOfKeys(i, t, n)) : e instanceof Date ? new Date(e.getTime()) : Bt(e) ? Object.getOwnPropertyNames(e).reduce((i, s) => {
      var a;
      return i[s] = t.includes(((a = this.settings) == null ? void 0 : a.maskValuesOfKeysCaseInsensitive) !== true ? s : s.toLowerCase()) ? this.settings.maskPlaceholder : this._recursiveCloneAndMaskValuesOfKeys(e[s], t, n), i;
    }, this._cloneError(e)) : e != null && typeof e == "object" ? Object.getOwnPropertyNames(e).reduce((i, s) => {
      var a;
      return i[s] = t.includes(((a = this.settings) == null ? void 0 : a.maskValuesOfKeysCaseInsensitive) !== true ? s : s.toLowerCase()) ? this.settings.maskPlaceholder : this._recursiveCloneAndMaskValuesOfKeys(e[s], t, n), i;
    }, Object.create(Object.getPrototypeOf(e))) : ((i) => {
      var s, a;
      return (a = (s = this.settings) == null ? void 0 : s.maskValuesRegEx) == null || a.forEach((o) => {
        var u;
        i = (u = i == null ? void 0 : i.toString()) == null ? void 0 : u.replace(o, this.settings.maskPlaceholder);
      }), i;
    })(e));
  }
  _recursiveCloneAndExecuteFunctions(e, t = []) {
    return t.includes(e) ? { ...e } : (typeof e == "object" && t.push(e), Array.isArray(e) ? e.map((n) => this._recursiveCloneAndExecuteFunctions(n, t)) : e instanceof Date ? new Date(e.getTime()) : e && typeof e == "object" ? Object.getOwnPropertyNames(e).reduce((n, i) => (Object.defineProperty(n, i, Object.getOwnPropertyDescriptor(e, i)), n[i] = typeof e[i] == "function" ? e[i]() : this._recursiveCloneAndExecuteFunctions(e[i], t), n), Object.create(Object.getPrototypeOf(e))) : e);
  }
  _toLogObj(e, t = {}) {
    return e = e == null ? void 0 : e.map((n) => Bt(n) ? this._toErrorObject(n) : n), this.settings.argumentsArrayName == null ? e.length === 1 && !Array.isArray(e[0]) && (e[0], void 0) !== true && !(e[0] instanceof Date) ? t = typeof e[0] == "object" && e[0] != null ? { ...e[0], ...t } : { 0: e[0], ...t } : t = { ...t, ...e } : t = {
      ...t,
      [this.settings.argumentsArrayName]: e
    }, t;
  }
  _cloneError(e) {
    const t = e.constructor, n = new t(e.message);
    Object.assign(n, e);
    const i = Object.getOwnPropertyNames(n);
    for (const s of i) {
      const a = Object.getOwnPropertyDescriptor(n, s);
      a && (a.writable = true, Object.defineProperty(n, s, a));
    }
    return n;
  }
  _toErrorObject(e) {
    return {
      nativeError: e,
      name: e.name ?? "Error",
      message: e.message,
      stack: Gr(e)
    };
  }
  _addMetaToLogObj(e, t, n) {
    return {
      ...e,
      [this.settings.metaProperty]: es(t, n, this.stackDepthLevel, this.settings.hideLogPositionForProduction, this.settings.name, this.settings.parentNames)
    };
  }
  _prettyFormatLogObjMeta(e) {
    var a, o, u, c, l, p, v, x, C, k, O, P, w, N, ee, B, z, Ie, Ce, Oe;
    if (e == null)
      return "";
    let t = this.settings.prettyLogTemplate;
    const n = {};
    t.includes("{{yyyy}}.{{mm}}.{{dd}} {{hh}}:{{MM}}:{{ss}}:{{ms}}") ? t = t.replace("{{yyyy}}.{{mm}}.{{dd}} {{hh}}:{{MM}}:{{ss}}:{{ms}}", "{{dateIsoStr}}") : this.settings.prettyLogTimeZone === "UTC" ? (n.yyyy = ((a = e == null ? void 0 : e.date) == null ? void 0 : a.getUTCFullYear()) ?? "----", n.mm = W((o = e == null ? void 0 : e.date) == null ? void 0 : o.getUTCMonth(), 2, 1), n.dd = W((u = e == null ? void 0 : e.date) == null ? void 0 : u.getUTCDate(), 2), n.hh = W((c = e == null ? void 0 : e.date) == null ? void 0 : c.getUTCHours(), 2), n.MM = W((l = e == null ? void 0 : e.date) == null ? void 0 : l.getUTCMinutes(), 2), n.ss = W((p = e == null ? void 0 : e.date) == null ? void 0 : p.getUTCSeconds(), 2), n.ms = W((v = e == null ? void 0 : e.date) == null ? void 0 : v.getUTCMilliseconds(), 3)) : (n.yyyy = ((x = e == null ? void 0 : e.date) == null ? void 0 : x.getFullYear()) ?? "----", n.mm = W((C = e == null ? void 0 : e.date) == null ? void 0 : C.getMonth(), 2, 1), n.dd = W((k = e == null ? void 0 : e.date) == null ? void 0 : k.getDate(), 2), n.hh = W((O = e == null ? void 0 : e.date) == null ? void 0 : O.getHours(), 2), n.MM = W((P = e == null ? void 0 : e.date) == null ? void 0 : P.getMinutes(), 2), n.ss = W((w = e == null ? void 0 : e.date) == null ? void 0 : w.getSeconds(), 2), n.ms = W((N = e == null ? void 0 : e.date) == null ? void 0 : N.getMilliseconds(), 3));
    const i = this.settings.prettyLogTimeZone === "UTC" ? e == null ? void 0 : e.date : new Date(((ee = e == null ? void 0 : e.date) == null ? void 0 : ee.getTime()) - ((B = e == null ? void 0 : e.date) == null ? void 0 : B.getTimezoneOffset()) * 6e4);
    n.rawIsoStr = i == null ? void 0 : i.toISOString(), n.dateIsoStr = i == null ? void 0 : i.toISOString().replace("T", " ").replace("Z", ""), n.logLevelName = e == null ? void 0 : e.logLevelName, n.fileNameWithLine = ((z = e == null ? void 0 : e.path) == null ? void 0 : z.fileNameWithLine) ?? "", n.filePathWithLine = ((Ie = e == null ? void 0 : e.path) == null ? void 0 : Ie.filePathWithLine) ?? "", n.fullFilePath = ((Ce = e == null ? void 0 : e.path) == null ? void 0 : Ce.fullFilePath) ?? "";
    let s = (Oe = this.settings.parentNames) == null ? void 0 : Oe.join(this.settings.prettyErrorParentNamesSeparator);
    return s = s != null && (e == null ? void 0 : e.name) != null ? s + this.settings.prettyErrorParentNamesSeparator : void 0, n.name = (e == null ? void 0 : e.name) != null || s != null ? (s ?? "") + (e == null ? void 0 : e.name) : "", n.nameWithDelimiterPrefix = n.name.length > 0 ? this.settings.prettyErrorLoggerNameDelimiter + n.name : "", n.nameWithDelimiterSuffix = n.name.length > 0 ? n.name + this.settings.prettyErrorLoggerNameDelimiter : "", qt(this.settings, t, n);
  }
};
var os = class extends as {
  constructor(e, t) {
    super(e, t, 5);
  }
  log(e, t, ...n) {
    return super.log(e, t, ...n);
  }
  silly(...e) {
    return super.log(0, "SILLY", ...e);
  }
  trace(...e) {
    return super.log(1, "TRACE", ...e);
  }
  debug(...e) {
    return super.log(2, "DEBUG", ...e);
  }
  info(...e) {
    return super.log(3, "INFO", ...e);
  }
  warn(...e) {
    return super.log(4, "WARN", ...e);
  }
  error(...e) {
    return super.log(5, "ERROR", ...e);
  }
  fatal(...e) {
    return super.log(6, "FATAL", ...e);
  }
  getSubLogger(e, t) {
    return super.getSubLogger(e, t);
  }
};
var ls = (r) => new os({
  minLevel: r,
  prettyLogTemplate: "{{hh}}:{{MM}}:{{ss}}:{{ms}}	{{logLevelName}}	"
});
var ds = (r) => {
  var i, s;
  const e = {
    version: 2,
    dAppDefinitionAddress: r.dAppDefinitionAddress,
    networkId: r.networkId
  };
  pr.parse(e), (i = r.logger) == null || i.debug(" walletSdkInstantiated", e);
  const t = r.logger, n = ((s = r.providers) == null ? void 0 : s.connectorExtensionClient) ?? ji({ logger: t });
  return {
    ...Mn(
      {
        version: 2,
        logger: r.logger,
        dAppDefinitionAddress: r.dAppDefinitionAddress,
        networkId: r.networkId
      },
      n
    ),
    destroy: () => {
      t == null || t.debug(" walletSdkInstantiatedDestroyed"), n.destroy();
    }
  };
};
export {
  yn as Account,
  vn as AccountProof,
  Nt as AccountsRequestItem,
  Lt as AccountsRequestResponseItem,
  Tn as AuthLoginRequestItem,
  Wn as AuthLoginRequestResponseItem,
  Sn as AuthLoginWithChallengeRequestItem,
  $n as AuthLoginWithChallengeRequestResponseItem,
  kn as AuthLoginWithoutChallengeRequestItem,
  Vn as AuthLoginWithoutChallengeRequestResponseItem,
  En as AuthRequestItem,
  Un as AuthRequestResponseItem,
  xn as AuthUsePersonaRequestItem,
  Ln as CancelRequest,
  cs as LoginRequestResponseItem,
  Hn as MessageLifeCycleEvent,
  pr as Metadata,
  Pt as NumberOfValues,
  st as Persona,
  _n as PersonaDataName,
  gn as PersonaDataNameVariant,
  Ot as PersonaDataRequestItem,
  Zt as PersonaDataRequestResponseItem,
  jt as Proof,
  wn as ResetRequestItem,
  An as SendTransactionItem,
  Pn as SendTransactionResponseItem,
  In as WalletAuthorizedRequestItems,
  Bn as WalletAuthorizedRequestResponseItems,
  Zn as WalletInteraction,
  Kn as WalletInteractionFailureResponse,
  On as WalletInteractionItems,
  mr as WalletInteractionResponse,
  Fn as WalletInteractionSuccessResponse,
  Cn as WalletRequestItems,
  zn as WalletRequestResponseItems,
  ds as WalletSdk,
  Rn as WalletTransactionItems,
  bn as WalletUnauthorizedRequestItems,
  ls as createLogger,
  Qe as createSdkError,
  qe as errorType,
  lt as eventType,
  Ze as messageLifeCycleEventType,
  tr as personaDataFullNameVariant,
  Gn as sdkError,
  us as walletInteractionFactoryV2
};
//# sourceMappingURL=@radixdlt_wallet-sdk.js.map
