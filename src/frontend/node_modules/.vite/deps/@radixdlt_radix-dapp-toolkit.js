import "./chunk-76J2PTFD.js";

// node_modules/@radixdlt/radix-dapp-toolkit/dist/radix-dapp-toolkit.mjs
var gs = function(e, t) {
  return gs = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n, r) {
    n.__proto__ = r;
  } || function(n, r) {
    for (var s in r)
      Object.prototype.hasOwnProperty.call(r, s) && (n[s] = r[s]);
  }, gs(e, t);
};
function Qe(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
  gs(e, t);
  function n() {
    this.constructor = e;
  }
  e.prototype = t === null ? Object.create(t) : (n.prototype = t.prototype, new n());
}
function ol(e, t, n, r) {
  function s(a) {
    return a instanceof n ? a : new n(function(i) {
      i(a);
    });
  }
  return new (n || (n = Promise))(function(a, i) {
    function o(d) {
      try {
        u(r.next(d));
      } catch (h) {
        i(h);
      }
    }
    function c(d) {
      try {
        u(r.throw(d));
      } catch (h) {
        i(h);
      }
    }
    function u(d) {
      d.done ? a(d.value) : s(d.value).then(o, c);
    }
    u((r = r.apply(e, t || [])).next());
  });
}
function Gi(e, t) {
  var n = { label: 0, sent: function() {
    if (a[0] & 1)
      throw a[1];
    return a[1];
  }, trys: [], ops: [] }, r, s, a, i;
  return i = { next: o(0), throw: o(1), return: o(2) }, typeof Symbol == "function" && (i[Symbol.iterator] = function() {
    return this;
  }), i;
  function o(u) {
    return function(d) {
      return c([u, d]);
    };
  }
  function c(u) {
    if (r)
      throw new TypeError("Generator is already executing.");
    for (; i && (i = 0, u[0] && (n = 0)), n; )
      try {
        if (r = 1, s && (a = u[0] & 2 ? s.return : u[0] ? s.throw || ((a = s.return) && a.call(s), 0) : s.next) && !(a = a.call(s, u[1])).done)
          return a;
        switch (s = 0, a && (u = [u[0] & 2, a.value]), u[0]) {
          case 0:
          case 1:
            a = u;
            break;
          case 4:
            return n.label++, { value: u[1], done: false };
          case 5:
            n.label++, s = u[1], u = [0];
            continue;
          case 7:
            u = n.ops.pop(), n.trys.pop();
            continue;
          default:
            if (a = n.trys, !(a = a.length > 0 && a[a.length - 1]) && (u[0] === 6 || u[0] === 2)) {
              n = 0;
              continue;
            }
            if (u[0] === 3 && (!a || u[1] > a[0] && u[1] < a[3])) {
              n.label = u[1];
              break;
            }
            if (u[0] === 6 && n.label < a[1]) {
              n.label = a[1], a = u;
              break;
            }
            if (a && n.label < a[2]) {
              n.label = a[2], n.ops.push(u);
              break;
            }
            a[2] && n.ops.pop(), n.trys.pop();
            continue;
        }
        u = t.call(e, n);
      } catch (d) {
        u = [6, d], s = 0;
      } finally {
        r = a = 0;
      }
    if (u[0] & 5)
      throw u[1];
    return { value: u[0] ? u[1] : void 0, done: true };
  }
}
function ln(e) {
  var t = typeof Symbol == "function" && Symbol.iterator, n = t && e[t], r = 0;
  if (n)
    return n.call(e);
  if (e && typeof e.length == "number")
    return {
      next: function() {
        return e && r >= e.length && (e = void 0), { value: e && e[r++], done: !e };
      }
    };
  throw new TypeError(t ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function wt(e, t) {
  var n = typeof Symbol == "function" && e[Symbol.iterator];
  if (!n)
    return e;
  var r = n.call(e), s, a = [], i;
  try {
    for (; (t === void 0 || t-- > 0) && !(s = r.next()).done; )
      a.push(s.value);
  } catch (o) {
    i = { error: o };
  } finally {
    try {
      s && !s.done && (n = r.return) && n.call(r);
    } finally {
      if (i)
        throw i.error;
    }
  }
  return a;
}
function Vt(e, t, n) {
  if (n || arguments.length === 2)
    for (var r = 0, s = t.length, a; r < s; r++)
      (a || !(r in t)) && (a || (a = Array.prototype.slice.call(t, 0, r)), a[r] = t[r]);
  return e.concat(a || Array.prototype.slice.call(t));
}
function on(e) {
  return this instanceof on ? (this.v = e, this) : new on(e);
}
function ul(e, t, n) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var r = n.apply(e, t || []), s, a = [];
  return s = {}, i("next"), i("throw"), i("return"), s[Symbol.asyncIterator] = function() {
    return this;
  }, s;
  function i(p) {
    r[p] && (s[p] = function(b) {
      return new Promise(function(E, y) {
        a.push([p, b, E, y]) > 1 || o(p, b);
      });
    });
  }
  function o(p, b) {
    try {
      c(r[p](b));
    } catch (E) {
      h(a[0][3], E);
    }
  }
  function c(p) {
    p.value instanceof on ? Promise.resolve(p.value.v).then(u, d) : h(a[0][2], p);
  }
  function u(p) {
    o("next", p);
  }
  function d(p) {
    o("throw", p);
  }
  function h(p, b) {
    p(b), a.shift(), a.length && o(a[0][0], a[0][1]);
  }
}
function cl(e) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var t = e[Symbol.asyncIterator], n;
  return t ? t.call(e) : (e = typeof ln == "function" ? ln(e) : e[Symbol.iterator](), n = {}, r("next"), r("throw"), r("return"), n[Symbol.asyncIterator] = function() {
    return this;
  }, n);
  function r(a) {
    n[a] = e[a] && function(i) {
      return new Promise(function(o, c) {
        i = e[a](i), s(o, c, i.done, i.value);
      });
    };
  }
  function s(a, i, o, c) {
    Promise.resolve(c).then(function(u) {
      a({ value: u, done: o });
    }, i);
  }
}
function K(e) {
  return typeof e == "function";
}
function la(e) {
  var t = function(r) {
    Error.call(r), r.stack = new Error().stack;
  }, n = e(t);
  return n.prototype = Object.create(Error.prototype), n.prototype.constructor = n, n;
}
var ts = la(function(e) {
  return function(n) {
    e(this), this.message = n ? n.length + ` errors occurred during unsubscription:
` + n.map(function(r, s) {
      return s + 1 + ") " + r.toString();
    }).join(`
  `) : "", this.name = "UnsubscriptionError", this.errors = n;
  };
});
function lr(e, t) {
  if (e) {
    var n = e.indexOf(t);
    0 <= n && e.splice(n, 1);
  }
}
var et = function() {
  function e(t) {
    this.initialTeardown = t, this.closed = false, this._parentage = null, this._finalizers = null;
  }
  return e.prototype.unsubscribe = function() {
    var t, n, r, s, a;
    if (!this.closed) {
      this.closed = true;
      var i = this._parentage;
      if (i)
        if (this._parentage = null, Array.isArray(i))
          try {
            for (var o = ln(i), c = o.next(); !c.done; c = o.next()) {
              var u = c.value;
              u.remove(this);
            }
          } catch (y) {
            t = { error: y };
          } finally {
            try {
              c && !c.done && (n = o.return) && n.call(o);
            } finally {
              if (t)
                throw t.error;
            }
          }
        else
          i.remove(this);
      var d = this.initialTeardown;
      if (K(d))
        try {
          d();
        } catch (y) {
          a = y instanceof ts ? y.errors : [y];
        }
      var h = this._finalizers;
      if (h) {
        this._finalizers = null;
        try {
          for (var p = ln(h), b = p.next(); !b.done; b = p.next()) {
            var E = b.value;
            try {
              ei(E);
            } catch (y) {
              a = a ?? [], y instanceof ts ? a = Vt(Vt([], wt(a)), wt(y.errors)) : a.push(y);
            }
          }
        } catch (y) {
          r = { error: y };
        } finally {
          try {
            b && !b.done && (s = p.return) && s.call(p);
          } finally {
            if (r)
              throw r.error;
          }
        }
      }
      if (a)
        throw new ts(a);
    }
  }, e.prototype.add = function(t) {
    var n;
    if (t && t !== this)
      if (this.closed)
        ei(t);
      else {
        if (t instanceof e) {
          if (t.closed || t._hasParent(this))
            return;
          t._addParent(this);
        }
        (this._finalizers = (n = this._finalizers) !== null && n !== void 0 ? n : []).push(t);
      }
  }, e.prototype._hasParent = function(t) {
    var n = this._parentage;
    return n === t || Array.isArray(n) && n.includes(t);
  }, e.prototype._addParent = function(t) {
    var n = this._parentage;
    this._parentage = Array.isArray(n) ? (n.push(t), n) : n ? [n, t] : t;
  }, e.prototype._removeParent = function(t) {
    var n = this._parentage;
    n === t ? this._parentage = null : Array.isArray(n) && lr(n, t);
  }, e.prototype.remove = function(t) {
    var n = this._finalizers;
    n && lr(n, t), t instanceof e && t._removeParent(this);
  }, e.EMPTY = function() {
    var t = new e();
    return t.closed = true, t;
  }(), e;
}();
var Hi = et.EMPTY;
function Ji(e) {
  return e instanceof et || e && "closed" in e && K(e.remove) && K(e.add) && K(e.unsubscribe);
}
function ei(e) {
  K(e) ? e() : e.unsubscribe();
}
var Yi = {
  onUnhandledError: null,
  onStoppedNotification: null,
  Promise: void 0,
  useDeprecatedSynchronousErrorHandling: false,
  useDeprecatedNextContext: false
};
var _s = {
  setTimeout: function(e, t) {
    for (var n = [], r = 2; r < arguments.length; r++)
      n[r - 2] = arguments[r];
    var s = _s.delegate;
    return s != null && s.setTimeout ? s.setTimeout.apply(s, Vt([e, t], wt(n))) : setTimeout.apply(void 0, Vt([e, t], wt(n)));
  },
  clearTimeout: function(e) {
    var t = _s.delegate;
    return ((t == null ? void 0 : t.clearTimeout) || clearTimeout)(e);
  },
  delegate: void 0
};
function Xi(e) {
  _s.setTimeout(function() {
    throw e;
  });
}
function ti() {
}
function ir(e) {
  e();
}
var da = function(e) {
  Qe(t, e);
  function t(n) {
    var r = e.call(this) || this;
    return r.isStopped = false, n ? (r.destination = n, Ji(n) && n.add(r)) : r.destination = hl, r;
  }
  return t.create = function(n, r, s) {
    return new dr(n, r, s);
  }, t.prototype.next = function(n) {
    this.isStopped || this._next(n);
  }, t.prototype.error = function(n) {
    this.isStopped || (this.isStopped = true, this._error(n));
  }, t.prototype.complete = function() {
    this.isStopped || (this.isStopped = true, this._complete());
  }, t.prototype.unsubscribe = function() {
    this.closed || (this.isStopped = true, e.prototype.unsubscribe.call(this), this.destination = null);
  }, t.prototype._next = function(n) {
    this.destination.next(n);
  }, t.prototype._error = function(n) {
    try {
      this.destination.error(n);
    } finally {
      this.unsubscribe();
    }
  }, t.prototype._complete = function() {
    try {
      this.destination.complete();
    } finally {
      this.unsubscribe();
    }
  }, t;
}(et);
var ll = Function.prototype.bind;
function ns(e, t) {
  return ll.call(e, t);
}
var dl = function() {
  function e(t) {
    this.partialObserver = t;
  }
  return e.prototype.next = function(t) {
    var n = this.partialObserver;
    if (n.next)
      try {
        n.next(t);
      } catch (r) {
        Qn(r);
      }
  }, e.prototype.error = function(t) {
    var n = this.partialObserver;
    if (n.error)
      try {
        n.error(t);
      } catch (r) {
        Qn(r);
      }
    else
      Qn(t);
  }, e.prototype.complete = function() {
    var t = this.partialObserver;
    if (t.complete)
      try {
        t.complete();
      } catch (n) {
        Qn(n);
      }
  }, e;
}();
var dr = function(e) {
  Qe(t, e);
  function t(n, r, s) {
    var a = e.call(this) || this, i;
    if (K(n) || !n)
      i = {
        next: n ?? void 0,
        error: r ?? void 0,
        complete: s ?? void 0
      };
    else {
      var o;
      a && Yi.useDeprecatedNextContext ? (o = Object.create(n), o.unsubscribe = function() {
        return a.unsubscribe();
      }, i = {
        next: n.next && ns(n.next, o),
        error: n.error && ns(n.error, o),
        complete: n.complete && ns(n.complete, o)
      }) : i = n;
    }
    return a.destination = new dl(i), a;
  }
  return t;
}(da);
function Qn(e) {
  Xi(e);
}
function fl(e) {
  throw e;
}
var hl = {
  closed: true,
  next: ti,
  error: fl,
  complete: ti
};
var fa = function() {
  return typeof Symbol == "function" && Symbol.observable || "@@observable";
}();
function qr(e) {
  return e;
}
function pl(e) {
  return e.length === 0 ? qr : e.length === 1 ? e[0] : function(n) {
    return e.reduce(function(r, s) {
      return s(r);
    }, n);
  };
}
var xe = function() {
  function e(t) {
    t && (this._subscribe = t);
  }
  return e.prototype.lift = function(t) {
    var n = new e();
    return n.source = this, n.operator = t, n;
  }, e.prototype.subscribe = function(t, n, r) {
    var s = this, a = yl(t) ? t : new dr(t, n, r);
    return ir(function() {
      var i = s, o = i.operator, c = i.source;
      a.add(o ? o.call(a, c) : c ? s._subscribe(a) : s._trySubscribe(a));
    }), a;
  }, e.prototype._trySubscribe = function(t) {
    try {
      return this._subscribe(t);
    } catch (n) {
      t.error(n);
    }
  }, e.prototype.forEach = function(t, n) {
    var r = this;
    return n = ni(n), new n(function(s, a) {
      var i = new dr({
        next: function(o) {
          try {
            t(o);
          } catch (c) {
            a(c), i.unsubscribe();
          }
        },
        error: a,
        complete: s
      });
      r.subscribe(i);
    });
  }, e.prototype._subscribe = function(t) {
    var n;
    return (n = this.source) === null || n === void 0 ? void 0 : n.subscribe(t);
  }, e.prototype[fa] = function() {
    return this;
  }, e.prototype.pipe = function() {
    for (var t = [], n = 0; n < arguments.length; n++)
      t[n] = arguments[n];
    return pl(t)(this);
  }, e.prototype.toPromise = function(t) {
    var n = this;
    return t = ni(t), new t(function(r, s) {
      var a;
      n.subscribe(function(i) {
        return a = i;
      }, function(i) {
        return s(i);
      }, function() {
        return r(a);
      });
    });
  }, e.create = function(t) {
    return new e(t);
  }, e;
}();
function ni(e) {
  var t;
  return (t = e ?? Yi.Promise) !== null && t !== void 0 ? t : Promise;
}
function ml(e) {
  return e && K(e.next) && K(e.error) && K(e.complete);
}
function yl(e) {
  return e && e instanceof da || ml(e) && Ji(e);
}
function vl(e) {
  return K(e == null ? void 0 : e.lift);
}
function tt(e) {
  return function(t) {
    if (vl(t))
      return t.lift(function(n) {
        try {
          return e(n, this);
        } catch (r) {
          this.error(r);
        }
      });
    throw new TypeError("Unable to lift unknown Observable type");
  };
}
function Le(e, t, n, r, s) {
  return new gl(e, t, n, r, s);
}
var gl = function(e) {
  Qe(t, e);
  function t(n, r, s, a, i, o) {
    var c = e.call(this, n) || this;
    return c.onFinalize = i, c.shouldUnsubscribe = o, c._next = r ? function(u) {
      try {
        r(u);
      } catch (d) {
        n.error(d);
      }
    } : e.prototype._next, c._error = a ? function(u) {
      try {
        a(u);
      } catch (d) {
        n.error(d);
      } finally {
        this.unsubscribe();
      }
    } : e.prototype._error, c._complete = s ? function() {
      try {
        s();
      } catch (u) {
        n.error(u);
      } finally {
        this.unsubscribe();
      }
    } : e.prototype._complete, c;
  }
  return t.prototype.unsubscribe = function() {
    var n;
    if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) {
      var r = this.closed;
      e.prototype.unsubscribe.call(this), !r && ((n = this.onFinalize) === null || n === void 0 || n.call(this));
    }
  }, t;
}(da);
var _l = la(function(e) {
  return function() {
    e(this), this.name = "ObjectUnsubscribedError", this.message = "object unsubscribed";
  };
});
var $e = function(e) {
  Qe(t, e);
  function t() {
    var n = e.call(this) || this;
    return n.closed = false, n.currentObservers = null, n.observers = [], n.isStopped = false, n.hasError = false, n.thrownError = null, n;
  }
  return t.prototype.lift = function(n) {
    var r = new ri(this, this);
    return r.operator = n, r;
  }, t.prototype._throwIfClosed = function() {
    if (this.closed)
      throw new _l();
  }, t.prototype.next = function(n) {
    var r = this;
    ir(function() {
      var s, a;
      if (r._throwIfClosed(), !r.isStopped) {
        r.currentObservers || (r.currentObservers = Array.from(r.observers));
        try {
          for (var i = ln(r.currentObservers), o = i.next(); !o.done; o = i.next()) {
            var c = o.value;
            c.next(n);
          }
        } catch (u) {
          s = { error: u };
        } finally {
          try {
            o && !o.done && (a = i.return) && a.call(i);
          } finally {
            if (s)
              throw s.error;
          }
        }
      }
    });
  }, t.prototype.error = function(n) {
    var r = this;
    ir(function() {
      if (r._throwIfClosed(), !r.isStopped) {
        r.hasError = r.isStopped = true, r.thrownError = n;
        for (var s = r.observers; s.length; )
          s.shift().error(n);
      }
    });
  }, t.prototype.complete = function() {
    var n = this;
    ir(function() {
      if (n._throwIfClosed(), !n.isStopped) {
        n.isStopped = true;
        for (var r = n.observers; r.length; )
          r.shift().complete();
      }
    });
  }, t.prototype.unsubscribe = function() {
    this.isStopped = this.closed = true, this.observers = this.currentObservers = null;
  }, Object.defineProperty(t.prototype, "observed", {
    get: function() {
      var n;
      return ((n = this.observers) === null || n === void 0 ? void 0 : n.length) > 0;
    },
    enumerable: false,
    configurable: true
  }), t.prototype._trySubscribe = function(n) {
    return this._throwIfClosed(), e.prototype._trySubscribe.call(this, n);
  }, t.prototype._subscribe = function(n) {
    return this._throwIfClosed(), this._checkFinalizedStatuses(n), this._innerSubscribe(n);
  }, t.prototype._innerSubscribe = function(n) {
    var r = this, s = this, a = s.hasError, i = s.isStopped, o = s.observers;
    return a || i ? Hi : (this.currentObservers = null, o.push(n), new et(function() {
      r.currentObservers = null, lr(o, n);
    }));
  }, t.prototype._checkFinalizedStatuses = function(n) {
    var r = this, s = r.hasError, a = r.thrownError, i = r.isStopped;
    s ? n.error(a) : i && n.complete();
  }, t.prototype.asObservable = function() {
    var n = new xe();
    return n.source = this, n;
  }, t.create = function(n, r) {
    return new ri(n, r);
  }, t;
}(xe);
var ri = function(e) {
  Qe(t, e);
  function t(n, r) {
    var s = e.call(this) || this;
    return s.destination = n, s.source = r, s;
  }
  return t.prototype.next = function(n) {
    var r, s;
    (s = (r = this.destination) === null || r === void 0 ? void 0 : r.next) === null || s === void 0 || s.call(r, n);
  }, t.prototype.error = function(n) {
    var r, s;
    (s = (r = this.destination) === null || r === void 0 ? void 0 : r.error) === null || s === void 0 || s.call(r, n);
  }, t.prototype.complete = function() {
    var n, r;
    (r = (n = this.destination) === null || n === void 0 ? void 0 : n.complete) === null || r === void 0 || r.call(n);
  }, t.prototype._subscribe = function(n) {
    var r, s;
    return (s = (r = this.source) === null || r === void 0 ? void 0 : r.subscribe(n)) !== null && s !== void 0 ? s : Hi;
  }, t;
}($e);
var Pe = function(e) {
  Qe(t, e);
  function t(n) {
    var r = e.call(this) || this;
    return r._value = n, r;
  }
  return Object.defineProperty(t.prototype, "value", {
    get: function() {
      return this.getValue();
    },
    enumerable: false,
    configurable: true
  }), t.prototype._subscribe = function(n) {
    var r = e.prototype._subscribe.call(this, n);
    return !r.closed && n.next(this._value), r;
  }, t.prototype.getValue = function() {
    var n = this, r = n.hasError, s = n.thrownError, a = n._value;
    if (r)
      throw s;
    return this._throwIfClosed(), a;
  }, t.prototype.next = function(n) {
    e.prototype.next.call(this, this._value = n);
  }, t;
}($e);
var ha = {
  now: function() {
    return (ha.delegate || Date).now();
  },
  delegate: void 0
};
var bl = function(e) {
  Qe(t, e);
  function t(n, r, s) {
    n === void 0 && (n = 1 / 0), r === void 0 && (r = 1 / 0), s === void 0 && (s = ha);
    var a = e.call(this) || this;
    return a._bufferSize = n, a._windowTime = r, a._timestampProvider = s, a._buffer = [], a._infiniteTimeWindow = true, a._infiniteTimeWindow = r === 1 / 0, a._bufferSize = Math.max(1, n), a._windowTime = Math.max(1, r), a;
  }
  return t.prototype.next = function(n) {
    var r = this, s = r.isStopped, a = r._buffer, i = r._infiniteTimeWindow, o = r._timestampProvider, c = r._windowTime;
    s || (a.push(n), !i && a.push(o.now() + c)), this._trimBuffer(), e.prototype.next.call(this, n);
  }, t.prototype._subscribe = function(n) {
    this._throwIfClosed(), this._trimBuffer();
    for (var r = this._innerSubscribe(n), s = this, a = s._infiniteTimeWindow, i = s._buffer, o = i.slice(), c = 0; c < o.length && !n.closed; c += a ? 1 : 2)
      n.next(o[c]);
    return this._checkFinalizedStatuses(n), r;
  }, t.prototype._trimBuffer = function() {
    var n = this, r = n._bufferSize, s = n._timestampProvider, a = n._buffer, i = n._infiniteTimeWindow, o = (i ? 1 : 2) * r;
    if (r < 1 / 0 && o < a.length && a.splice(0, a.length - o), !i) {
      for (var c = s.now(), u = 0, d = 1; d < a.length && a[d] <= c; d += 2)
        u = d;
      u && a.splice(0, u + 1);
    }
  }, t;
}($e);
var wl = function(e) {
  Qe(t, e);
  function t(n, r) {
    return e.call(this) || this;
  }
  return t.prototype.schedule = function(n, r) {
    return this;
  }, t;
}(et);
var fr = {
  setInterval: function(e, t) {
    for (var n = [], r = 2; r < arguments.length; r++)
      n[r - 2] = arguments[r];
    var s = fr.delegate;
    return s != null && s.setInterval ? s.setInterval.apply(s, Vt([e, t], wt(n))) : setInterval.apply(void 0, Vt([e, t], wt(n)));
  },
  clearInterval: function(e) {
    var t = fr.delegate;
    return ((t == null ? void 0 : t.clearInterval) || clearInterval)(e);
  },
  delegate: void 0
};
var xl = function(e) {
  Qe(t, e);
  function t(n, r) {
    var s = e.call(this, n, r) || this;
    return s.scheduler = n, s.work = r, s.pending = false, s;
  }
  return t.prototype.schedule = function(n, r) {
    var s;
    if (r === void 0 && (r = 0), this.closed)
      return this;
    this.state = n;
    var a = this.id, i = this.scheduler;
    return a != null && (this.id = this.recycleAsyncId(i, a, r)), this.pending = true, this.delay = r, this.id = (s = this.id) !== null && s !== void 0 ? s : this.requestAsyncId(i, this.id, r), this;
  }, t.prototype.requestAsyncId = function(n, r, s) {
    return s === void 0 && (s = 0), fr.setInterval(n.flush.bind(n, this), s);
  }, t.prototype.recycleAsyncId = function(n, r, s) {
    if (s === void 0 && (s = 0), s != null && this.delay === s && this.pending === false)
      return r;
    r != null && fr.clearInterval(r);
  }, t.prototype.execute = function(n, r) {
    if (this.closed)
      return new Error("executing a cancelled action");
    this.pending = false;
    var s = this._execute(n, r);
    if (s)
      return s;
    this.pending === false && this.id != null && (this.id = this.recycleAsyncId(this.scheduler, this.id, null));
  }, t.prototype._execute = function(n, r) {
    var s = false, a;
    try {
      this.work(n);
    } catch (i) {
      s = true, a = i || new Error("Scheduled action threw falsy error");
    }
    if (s)
      return this.unsubscribe(), a;
  }, t.prototype.unsubscribe = function() {
    if (!this.closed) {
      var n = this, r = n.id, s = n.scheduler, a = s.actions;
      this.work = this.state = this.scheduler = null, this.pending = false, lr(a, this), r != null && (this.id = this.recycleAsyncId(s, r, null)), this.delay = null, e.prototype.unsubscribe.call(this);
    }
  }, t;
}(wl);
var si = function() {
  function e(t, n) {
    n === void 0 && (n = e.now), this.schedulerActionCtor = t, this.now = n;
  }
  return e.prototype.schedule = function(t, n, r) {
    return n === void 0 && (n = 0), new this.schedulerActionCtor(this, t).schedule(r, n);
  }, e.now = ha.now, e;
}();
var kl = function(e) {
  Qe(t, e);
  function t(n, r) {
    r === void 0 && (r = si.now);
    var s = e.call(this, n, r) || this;
    return s.actions = [], s._active = false, s;
  }
  return t.prototype.flush = function(n) {
    var r = this.actions;
    if (this._active) {
      r.push(n);
      return;
    }
    var s;
    this._active = true;
    do
      if (s = n.execute(n.state, n.delay))
        break;
    while (n = r.shift());
    if (this._active = false, s) {
      for (; n = r.shift(); )
        n.unsubscribe();
      throw s;
    }
  }, t;
}(si);
var Sl = new kl(xl);
var Tl = Sl;
var Qi = new xe(function(e) {
  return e.complete();
});
function eo(e) {
  return e && K(e.schedule);
}
function to(e) {
  return e[e.length - 1];
}
function no(e) {
  return eo(to(e)) ? e.pop() : void 0;
}
function Pl(e, t) {
  return typeof to(e) == "number" ? e.pop() : t;
}
var pa = function(e) {
  return e && typeof e.length == "number" && typeof e != "function";
};
function ro(e) {
  return K(e == null ? void 0 : e.then);
}
function so(e) {
  return K(e[fa]);
}
function ao(e) {
  return Symbol.asyncIterator && K(e == null ? void 0 : e[Symbol.asyncIterator]);
}
function io(e) {
  return new TypeError("You provided " + (e !== null && typeof e == "object" ? "an invalid object" : "'" + e + "'") + " where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.");
}
function Ol() {
  return typeof Symbol != "function" || !Symbol.iterator ? "@@iterator" : Symbol.iterator;
}
var oo = Ol();
function uo(e) {
  return K(e == null ? void 0 : e[oo]);
}
function co(e) {
  return ul(this, arguments, function() {
    var n, r, s, a;
    return Gi(this, function(i) {
      switch (i.label) {
        case 0:
          n = e.getReader(), i.label = 1;
        case 1:
          i.trys.push([1, , 9, 10]), i.label = 2;
        case 2:
          return [4, on(n.read())];
        case 3:
          return r = i.sent(), s = r.value, a = r.done, a ? [4, on(void 0)] : [3, 5];
        case 4:
          return [2, i.sent()];
        case 5:
          return [4, on(s)];
        case 6:
          return [4, i.sent()];
        case 7:
          return i.sent(), [3, 2];
        case 8:
          return [3, 10];
        case 9:
          return n.releaseLock(), [7];
        case 10:
          return [2];
      }
    });
  });
}
function lo(e) {
  return K(e == null ? void 0 : e.getReader);
}
function Pt(e) {
  if (e instanceof xe)
    return e;
  if (e != null) {
    if (so(e))
      return El(e);
    if (pa(e))
      return Cl(e);
    if (ro(e))
      return Rl(e);
    if (ao(e))
      return fo(e);
    if (uo(e))
      return Al(e);
    if (lo(e))
      return Il(e);
  }
  throw io(e);
}
function El(e) {
  return new xe(function(t) {
    var n = e[fa]();
    if (K(n.subscribe))
      return n.subscribe(t);
    throw new TypeError("Provided object does not correctly implement Symbol.observable");
  });
}
function Cl(e) {
  return new xe(function(t) {
    for (var n = 0; n < e.length && !t.closed; n++)
      t.next(e[n]);
    t.complete();
  });
}
function Rl(e) {
  return new xe(function(t) {
    e.then(function(n) {
      t.closed || (t.next(n), t.complete());
    }, function(n) {
      return t.error(n);
    }).then(null, Xi);
  });
}
function Al(e) {
  return new xe(function(t) {
    var n, r;
    try {
      for (var s = ln(e), a = s.next(); !a.done; a = s.next()) {
        var i = a.value;
        if (t.next(i), t.closed)
          return;
      }
    } catch (o) {
      n = { error: o };
    } finally {
      try {
        a && !a.done && (r = s.return) && r.call(s);
      } finally {
        if (n)
          throw n.error;
      }
    }
    t.complete();
  });
}
function fo(e) {
  return new xe(function(t) {
    Nl(e, t).catch(function(n) {
      return t.error(n);
    });
  });
}
function Il(e) {
  return fo(co(e));
}
function Nl(e, t) {
  var n, r, s, a;
  return ol(this, void 0, void 0, function() {
    var i, o;
    return Gi(this, function(c) {
      switch (c.label) {
        case 0:
          c.trys.push([0, 5, 6, 11]), n = cl(e), c.label = 1;
        case 1:
          return [4, n.next()];
        case 2:
          if (r = c.sent(), !!r.done)
            return [3, 4];
          if (i = r.value, t.next(i), t.closed)
            return [2];
          c.label = 3;
        case 3:
          return [3, 1];
        case 4:
          return [3, 11];
        case 5:
          return o = c.sent(), s = { error: o }, [3, 11];
        case 6:
          return c.trys.push([6, , 9, 10]), r && !r.done && (a = n.return) ? [4, a.call(n)] : [3, 8];
        case 7:
          c.sent(), c.label = 8;
        case 8:
          return [3, 10];
        case 9:
          if (s)
            throw s.error;
          return [7];
        case 10:
          return [7];
        case 11:
          return t.complete(), [2];
      }
    });
  });
}
function vt(e, t, n, r, s) {
  r === void 0 && (r = 0), s === void 0 && (s = false);
  var a = t.schedule(function() {
    n(), s ? e.add(this.schedule(null, r)) : this.unsubscribe();
  }, r);
  if (e.add(a), !s)
    return a;
}
function ho(e, t) {
  return t === void 0 && (t = 0), tt(function(n, r) {
    n.subscribe(Le(r, function(s) {
      return vt(r, e, function() {
        return r.next(s);
      }, t);
    }, function() {
      return vt(r, e, function() {
        return r.complete();
      }, t);
    }, function(s) {
      return vt(r, e, function() {
        return r.error(s);
      }, t);
    }));
  });
}
function po(e, t) {
  return t === void 0 && (t = 0), tt(function(n, r) {
    r.add(e.schedule(function() {
      return n.subscribe(r);
    }, t));
  });
}
function jl(e, t) {
  return Pt(e).pipe(po(t), ho(t));
}
function Dl(e, t) {
  return Pt(e).pipe(po(t), ho(t));
}
function ql(e, t) {
  return new xe(function(n) {
    var r = 0;
    return t.schedule(function() {
      r === e.length ? n.complete() : (n.next(e[r++]), n.closed || this.schedule());
    });
  });
}
function $l(e, t) {
  return new xe(function(n) {
    var r;
    return vt(n, t, function() {
      r = e[oo](), vt(n, t, function() {
        var s, a, i;
        try {
          s = r.next(), a = s.value, i = s.done;
        } catch (o) {
          n.error(o);
          return;
        }
        i ? n.complete() : n.next(a);
      }, 0, true);
    }), function() {
      return K(r == null ? void 0 : r.return) && r.return();
    };
  });
}
function mo(e, t) {
  if (!e)
    throw new Error("Iterable cannot be null");
  return new xe(function(n) {
    vt(n, t, function() {
      var r = e[Symbol.asyncIterator]();
      vt(n, t, function() {
        r.next().then(function(s) {
          s.done ? n.complete() : n.next(s.value);
        });
      }, 0, true);
    });
  });
}
function Ll(e, t) {
  return mo(co(e), t);
}
function Zl(e, t) {
  if (e != null) {
    if (so(e))
      return jl(e, t);
    if (pa(e))
      return ql(e, t);
    if (ro(e))
      return Dl(e, t);
    if (ao(e))
      return mo(e, t);
    if (uo(e))
      return $l(e, t);
    if (lo(e))
      return Ll(e, t);
  }
  throw io(e);
}
function yo(e, t) {
  return t ? Zl(e, t) : Pt(e);
}
function Ml() {
  for (var e = [], t = 0; t < arguments.length; t++)
    e[t] = arguments[t];
  var n = no(e);
  return yo(e, n);
}
var ma = la(function(e) {
  return function() {
    e(this), this.name = "EmptyError", this.message = "no elements in sequence";
  };
});
function vo(e, t) {
  var n = typeof t == "object";
  return new Promise(function(r, s) {
    var a = new dr({
      next: function(i) {
        r(i), a.unsubscribe();
      },
      error: s,
      complete: function() {
        n ? r(t.defaultValue) : s(new ma());
      }
    });
    e.subscribe(a);
  });
}
function Fl(e) {
  return e instanceof Date && !isNaN(e);
}
function Be(e, t) {
  return tt(function(n, r) {
    var s = 0;
    n.subscribe(Le(r, function(a) {
      r.next(e.call(t, a, s++));
    }));
  });
}
var zl = Array.isArray;
function Ul(e, t) {
  return zl(t) ? e.apply(void 0, Vt([], wt(t))) : e(t);
}
function Vl(e) {
  return Be(function(t) {
    return Ul(e, t);
  });
}
function Bl(e, t, n, r, s, a, i, o) {
  var c = [], u = 0, d = 0, h = false, p = function() {
    h && !c.length && !u && t.complete();
  }, b = function(y) {
    return u < r ? E(y) : c.push(y);
  }, E = function(y) {
    a && t.next(y), u++;
    var A = false;
    Pt(n(y, d++)).subscribe(Le(t, function(O) {
      s == null || s(O), a ? b(O) : t.next(O);
    }, function() {
      A = true;
    }, void 0, function() {
      if (A)
        try {
          u--;
          for (var O = function() {
            var I = c.shift();
            i ? vt(t, i, function() {
              return E(I);
            }) : E(I);
          }; c.length && u < r; )
            O();
          p();
        } catch (I) {
          t.error(I);
        }
    }));
  };
  return e.subscribe(Le(t, b, function() {
    h = true, p();
  })), function() {
    o == null || o();
  };
}
function ya(e, t, n) {
  return n === void 0 && (n = 1 / 0), K(t) ? ya(function(r, s) {
    return Be(function(a, i) {
      return t(r, a, s, i);
    })(Pt(e(r, s)));
  }, n) : (typeof t == "number" && (n = t), tt(function(r, s) {
    return Bl(r, s, e, n);
  }));
}
function Wl(e) {
  return e === void 0 && (e = 1 / 0), ya(qr, e);
}
var Kl = ["addListener", "removeListener"];
var Gl = ["addEventListener", "removeEventListener"];
var Hl = ["on", "off"];
function it(e, t, n, r) {
  if (K(n) && (r = n, n = void 0), r)
    return it(e, t, n).pipe(Vl(r));
  var s = wt(Xl(e) ? Gl.map(function(o) {
    return function(c) {
      return e[o](t, c, n);
    };
  }) : Jl(e) ? Kl.map(ai(e, t)) : Yl(e) ? Hl.map(ai(e, t)) : [], 2), a = s[0], i = s[1];
  if (!a && pa(e))
    return ya(function(o) {
      return it(o, t, n);
    })(Pt(e));
  if (!a)
    throw new TypeError("Invalid event target");
  return new xe(function(o) {
    var c = function() {
      for (var u = [], d = 0; d < arguments.length; d++)
        u[d] = arguments[d];
      return o.next(1 < u.length ? u : u[0]);
    };
    return a(c), function() {
      return i(c);
    };
  });
}
function ai(e, t) {
  return function(n) {
    return function(r) {
      return e[n](t, r);
    };
  };
}
function Jl(e) {
  return K(e.addListener) && K(e.removeListener);
}
function Yl(e) {
  return K(e.on) && K(e.off);
}
function Xl(e) {
  return K(e.addEventListener) && K(e.removeEventListener);
}
function ii(e, t, n) {
  e === void 0 && (e = 0), n === void 0 && (n = Tl);
  var r = -1;
  return t != null && (eo(t) ? n = t : r = t), new xe(function(s) {
    var a = Fl(e) ? +e - n.now() : e;
    a < 0 && (a = 0);
    var i = 0;
    return n.schedule(function() {
      s.closed || (s.next(i++), 0 <= r ? this.schedule(void 0, r) : s.complete());
    }, a);
  });
}
function dn() {
  for (var e = [], t = 0; t < arguments.length; t++)
    e[t] = arguments[t];
  var n = no(e), r = Pl(e, 1 / 0), s = e;
  return s.length ? s.length === 1 ? Pt(s[0]) : Wl(r)(yo(s, n)) : Qi;
}
function xt(e, t) {
  return tt(function(n, r) {
    var s = 0;
    n.subscribe(Le(r, function(a) {
      return e.call(t, a, s++) && r.next(a);
    }));
  });
}
function Ql(e) {
  return tt(function(t, n) {
    var r = false;
    t.subscribe(Le(n, function(s) {
      r = true, n.next(s);
    }, function() {
      r || n.next(e), n.complete();
    }));
  });
}
function ed(e) {
  return e <= 0 ? function() {
    return Qi;
  } : tt(function(t, n) {
    var r = 0;
    t.subscribe(Le(n, function(s) {
      ++r <= e && (n.next(s), e <= r && n.complete());
    }));
  });
}
function td(e) {
  return e === void 0 && (e = nd), tt(function(t, n) {
    var r = false;
    t.subscribe(Le(n, function(s) {
      r = true, n.next(s);
    }, function() {
      return r ? n.complete() : n.error(e());
    }));
  });
}
function nd() {
  return new ma();
}
function go(e, t) {
  var n = arguments.length >= 2;
  return function(r) {
    return r.pipe(e ? xt(function(s, a) {
      return e(s, a, r);
    }) : qr, ed(1), n ? Ql(t) : td(function() {
      return new ma();
    }));
  };
}
function rd(e) {
  return xt(function(t, n) {
    return e <= n;
  });
}
function ct(e, t) {
  return tt(function(n, r) {
    var s = null, a = 0, i = false, o = function() {
      return i && !s && r.complete();
    };
    n.subscribe(Le(r, function(c) {
      s == null || s.unsubscribe();
      var u = 0, d = a++;
      Pt(e(c, d)).subscribe(s = Le(r, function(h) {
        return r.next(t ? t(c, h, d, u++) : h);
      }, function() {
        s = null, o();
      }));
    }, function() {
      i = true, o();
    }));
  });
}
function ae(e, t, n) {
  var r = K(e) || t || n ? { next: e, error: t, complete: n } : e;
  return r ? tt(function(s, a) {
    var i;
    (i = r.subscribe) === null || i === void 0 || i.call(r);
    var o = true;
    s.subscribe(Le(a, function(c) {
      var u;
      (u = r.next) === null || u === void 0 || u.call(r, c), a.next(c);
    }, function() {
      var c;
      o = false, (c = r.complete) === null || c === void 0 || c.call(r), a.complete();
    }, function(c) {
      var u;
      o = false, (u = r.error) === null || u === void 0 || u.call(r, c), a.error(c);
    }, function() {
      var c, u;
      o && ((c = r.unsubscribe) === null || c === void 0 || c.call(r)), (u = r.finalize) === null || u === void 0 || u.call(r);
    }));
  }) : qr;
}
function rs(e, t, n, r) {
  function s(a) {
    return a instanceof n ? a : new n(function(i) {
      i(a);
    });
  }
  return new (n || (n = Promise))(function(a, i) {
    function o(d) {
      try {
        u(r.next(d));
      } catch (h) {
        i(h);
      }
    }
    function c(d) {
      try {
        u(r.throw(d));
      } catch (h) {
        i(h);
      }
    }
    function u(d) {
      d.done ? a(d.value) : s(d.value).then(o, c);
    }
    u((r = r.apply(e, t || [])).next());
  });
}
function ss(e, t) {
  var n = { label: 0, sent: function() {
    if (a[0] & 1)
      throw a[1];
    return a[1];
  }, trys: [], ops: [] }, r, s, a, i;
  return i = { next: o(0), throw: o(1), return: o(2) }, typeof Symbol == "function" && (i[Symbol.iterator] = function() {
    return this;
  }), i;
  function o(u) {
    return function(d) {
      return c([u, d]);
    };
  }
  function c(u) {
    if (r)
      throw new TypeError("Generator is already executing.");
    for (; n; )
      try {
        if (r = 1, s && (a = u[0] & 2 ? s.return : u[0] ? s.throw || ((a = s.return) && a.call(s), 0) : s.next) && !(a = a.call(s, u[1])).done)
          return a;
        switch (s = 0, a && (u = [u[0] & 2, a.value]), u[0]) {
          case 0:
          case 1:
            a = u;
            break;
          case 4:
            return n.label++, { value: u[1], done: false };
          case 5:
            n.label++, s = u[1], u = [0];
            continue;
          case 7:
            u = n.ops.pop(), n.trys.pop();
            continue;
          default:
            if (a = n.trys, !(a = a.length > 0 && a[a.length - 1]) && (u[0] === 6 || u[0] === 2)) {
              n = 0;
              continue;
            }
            if (u[0] === 3 && (!a || u[1] > a[0] && u[1] < a[3])) {
              n.label = u[1];
              break;
            }
            if (u[0] === 6 && n.label < a[1]) {
              n.label = a[1], a = u;
              break;
            }
            if (a && n.label < a[2]) {
              n.label = a[2], n.ops.push(u);
              break;
            }
            a[2] && n.ops.pop(), n.trys.pop();
            continue;
        }
        u = t.call(e, n);
      } catch (d) {
        u = [6, d], s = 0;
      } finally {
        r = a = 0;
      }
    if (u[0] & 5)
      throw u[1];
    return { value: u[0] ? u[1] : void 0, done: true };
  }
}
function hr(e, t) {
  var n = typeof Symbol == "function" && e[Symbol.iterator];
  if (!n)
    return e;
  var r = n.call(e), s, a = [], i;
  try {
    for (; (t === void 0 || t-- > 0) && !(s = r.next()).done; )
      a.push(s.value);
  } catch (o) {
    i = { error: o };
  } finally {
    try {
      s && !s.done && (n = r.return) && n.call(r);
    } finally {
      if (i)
        throw i.error;
    }
  }
  return a;
}
function Ft(e, t, n) {
  if (n || arguments.length === 2)
    for (var r = 0, s = t.length, a; r < s; r++)
      (a || !(r in t)) && (a || (a = Array.prototype.slice.call(t, 0, r)), a[r] = t[r]);
  return e.concat(a || Array.prototype.slice.call(t));
}
var sd = {
  withStackTrace: false
};
var _o = function(e, t, n) {
  n === void 0 && (n = sd);
  var r = t.isOk() ? { type: "Ok", value: t.value } : { type: "Err", value: t.error }, s = n.withStackTrace ? new Error().stack : void 0;
  return {
    data: r,
    message: e,
    stack: s
  };
};
var nt = (
  /** @class */
  function() {
    function e(t) {
      this._promise = t;
    }
    return e.fromSafePromise = function(t) {
      var n = t.then(function(r) {
        return new jt(r);
      });
      return new e(n);
    }, e.fromPromise = function(t, n) {
      var r = t.then(function(s) {
        return new jt(s);
      }).catch(function(s) {
        return new $t(n(s));
      });
      return new e(r);
    }, e.combine = function(t) {
      return id(t);
    }, e.combineWithAllErrors = function(t) {
      return od(t);
    }, e.prototype.map = function(t) {
      var n = this;
      return new e(this._promise.then(function(r) {
        return rs(n, void 0, void 0, function() {
          var s;
          return ss(this, function(a) {
            switch (a.label) {
              case 0:
                return r.isErr() ? [2, new $t(r.error)] : (s = jt.bind, [4, t(r.value)]);
              case 1:
                return [2, new (s.apply(jt, [void 0, a.sent()]))()];
            }
          });
        });
      }));
    }, e.prototype.mapErr = function(t) {
      var n = this;
      return new e(this._promise.then(function(r) {
        return rs(n, void 0, void 0, function() {
          var s;
          return ss(this, function(a) {
            switch (a.label) {
              case 0:
                return r.isOk() ? [2, new jt(r.value)] : (s = $t.bind, [4, t(r.error)]);
              case 1:
                return [2, new (s.apply($t, [void 0, a.sent()]))()];
            }
          });
        });
      }));
    }, e.prototype.andThen = function(t) {
      return new e(this._promise.then(function(n) {
        if (n.isErr())
          return new $t(n.error);
        var r = t(n.value);
        return r instanceof e ? r._promise : r;
      }));
    }, e.prototype.orElse = function(t) {
      var n = this;
      return new e(this._promise.then(function(r) {
        return rs(n, void 0, void 0, function() {
          return ss(this, function(s) {
            return r.isErr() ? [2, t(r.error)] : [2, new jt(r.value)];
          });
        });
      }));
    }, e.prototype.match = function(t, n) {
      return this._promise.then(function(r) {
        return r.match(t, n);
      });
    }, e.prototype.unwrapOr = function(t) {
      return this._promise.then(function(n) {
        return n.unwrapOr(t);
      });
    }, e.prototype.then = function(t, n) {
      return this._promise.then(t, n);
    }, e;
  }()
);
var oi = function(e) {
  return new nt(Promise.resolve(new $t(e)));
};
nt.fromPromise;
nt.fromSafePromise;
var ad = function(e) {
  return function(t) {
    return Ft(Ft([], hr(t), false), [e], false);
  };
};
var bo = function(e) {
  return e.reduce(function(t, n) {
    return t.isOk() ? n.isErr() ? je(n.error) : t.map(ad(n.value)) : t;
  }, We([]));
};
var id = function(e) {
  return nt.fromSafePromise(Promise.all(e)).andThen(bo);
};
var wo = function(e) {
  return e.reduce(function(t, n) {
    return n.isErr() ? t.isErr() ? je(Ft(Ft([], hr(t.error), false), [n.error], false)) : je([n.error]) : t.isErr() ? t : We(Ft(Ft([], hr(t.value), false), [n.value], false));
  }, We([]));
};
var od = function(e) {
  return nt.fromSafePromise(Promise.all(e)).andThen(wo);
};
var bs;
(function(e) {
  function t(s, a) {
    return function() {
      for (var i = [], o = 0; o < arguments.length; o++)
        i[o] = arguments[o];
      try {
        var c = s.apply(void 0, Ft([], hr(i), false));
        return We(c);
      } catch (u) {
        return je(a ? a(u) : u);
      }
    };
  }
  e.fromThrowable = t;
  function n(s) {
    return bo(s);
  }
  e.combine = n;
  function r(s) {
    return wo(s);
  }
  e.combineWithAllErrors = r;
})(bs || (bs = {}));
var We = function(e) {
  return new jt(e);
};
var je = function(e) {
  return new $t(e);
};
var jt = (
  /** @class */
  function() {
    function e(t) {
      this.value = t;
    }
    return e.prototype.isOk = function() {
      return true;
    }, e.prototype.isErr = function() {
      return !this.isOk();
    }, e.prototype.map = function(t) {
      return We(t(this.value));
    }, e.prototype.mapErr = function(t) {
      return We(this.value);
    }, e.prototype.andThen = function(t) {
      return t(this.value);
    }, e.prototype.orElse = function(t) {
      return We(this.value);
    }, e.prototype.asyncAndThen = function(t) {
      return t(this.value);
    }, e.prototype.asyncMap = function(t) {
      return nt.fromSafePromise(t(this.value));
    }, e.prototype.unwrapOr = function(t) {
      return this.value;
    }, e.prototype.match = function(t, n) {
      return t(this.value);
    }, e.prototype._unsafeUnwrap = function(t) {
      return this.value;
    }, e.prototype._unsafeUnwrapErr = function(t) {
      throw _o("Called `_unsafeUnwrapErr` on an Ok", this, t);
    }, e;
  }()
);
var $t = (
  /** @class */
  function() {
    function e(t) {
      this.error = t;
    }
    return e.prototype.isOk = function() {
      return false;
    }, e.prototype.isErr = function() {
      return !this.isOk();
    }, e.prototype.map = function(t) {
      return je(this.error);
    }, e.prototype.mapErr = function(t) {
      return je(t(this.error));
    }, e.prototype.andThen = function(t) {
      return je(this.error);
    }, e.prototype.orElse = function(t) {
      return t(this.error);
    }, e.prototype.asyncAndThen = function(t) {
      return oi(this.error);
    }, e.prototype.asyncMap = function(t) {
      return oi(this.error);
    }, e.prototype.unwrapOr = function(t) {
      return t;
    }, e.prototype.match = function(t, n) {
      return n(this.error);
    }, e.prototype._unsafeUnwrap = function(t) {
      throw _o("Called `_unsafeUnwrap` on an Err", this, t);
    }, e.prototype._unsafeUnwrapErr = function(t) {
      return this.error;
    }, e;
  }()
);
bs.fromThrowable;
var V;
(function(e) {
  e.assertEqual = (s) => s;
  function t(s) {
  }
  e.assertIs = t;
  function n(s) {
    throw new Error();
  }
  e.assertNever = n, e.arrayToEnum = (s) => {
    const a = {};
    for (const i of s)
      a[i] = i;
    return a;
  }, e.getValidEnumValues = (s) => {
    const a = e.objectKeys(s).filter((o) => typeof s[s[o]] != "number"), i = {};
    for (const o of a)
      i[o] = s[o];
    return e.objectValues(i);
  }, e.objectValues = (s) => e.objectKeys(s).map(function(a) {
    return s[a];
  }), e.objectKeys = typeof Object.keys == "function" ? (s) => Object.keys(s) : (s) => {
    const a = [];
    for (const i in s)
      Object.prototype.hasOwnProperty.call(s, i) && a.push(i);
    return a;
  }, e.find = (s, a) => {
    for (const i of s)
      if (a(i))
        return i;
  }, e.isInteger = typeof Number.isInteger == "function" ? (s) => Number.isInteger(s) : (s) => typeof s == "number" && isFinite(s) && Math.floor(s) === s;
  function r(s, a = " | ") {
    return s.map((i) => typeof i == "string" ? `'${i}'` : i).join(a);
  }
  e.joinValues = r, e.jsonStringifyReplacer = (s, a) => typeof a == "bigint" ? a.toString() : a;
})(V || (V = {}));
var ui;
(function(e) {
  e.mergeShapes = (t, n) => ({
    ...t,
    ...n
    // second overwrites first
  });
})(ui || (ui = {}));
var P = V.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]);
var Lt = (e) => {
  switch (typeof e) {
    case "undefined":
      return P.undefined;
    case "string":
      return P.string;
    case "number":
      return isNaN(e) ? P.nan : P.number;
    case "boolean":
      return P.boolean;
    case "function":
      return P.function;
    case "bigint":
      return P.bigint;
    case "symbol":
      return P.symbol;
    case "object":
      return Array.isArray(e) ? P.array : e === null ? P.null : e.then && typeof e.then == "function" && e.catch && typeof e.catch == "function" ? P.promise : typeof Map < "u" && e instanceof Map ? P.map : typeof Set < "u" && e instanceof Set ? P.set : typeof Date < "u" && e instanceof Date ? P.date : P.object;
    default:
      return P.unknown;
  }
};
var _ = V.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]);
var Bt = class extends Error {
  constructor(t) {
    super(), this.issues = [], this.addIssue = (r) => {
      this.issues = [...this.issues, r];
    }, this.addIssues = (r = []) => {
      this.issues = [...this.issues, ...r];
    };
    const n = new.target.prototype;
    Object.setPrototypeOf ? Object.setPrototypeOf(this, n) : this.__proto__ = n, this.name = "ZodError", this.issues = t;
  }
  get errors() {
    return this.issues;
  }
  format(t) {
    const n = t || function(a) {
      return a.message;
    }, r = { _errors: [] }, s = (a) => {
      for (const i of a.issues)
        if (i.code === "invalid_union")
          i.unionErrors.map(s);
        else if (i.code === "invalid_return_type")
          s(i.returnTypeError);
        else if (i.code === "invalid_arguments")
          s(i.argumentsError);
        else if (i.path.length === 0)
          r._errors.push(n(i));
        else {
          let o = r, c = 0;
          for (; c < i.path.length; ) {
            const u = i.path[c];
            c === i.path.length - 1 ? (o[u] = o[u] || { _errors: [] }, o[u]._errors.push(n(i))) : o[u] = o[u] || { _errors: [] }, o = o[u], c++;
          }
        }
    };
    return s(this), r;
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, V.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(t = (n) => n.message) {
    const n = {}, r = [];
    for (const s of this.issues)
      s.path.length > 0 ? (n[s.path[0]] = n[s.path[0]] || [], n[s.path[0]].push(t(s))) : r.push(t(s));
    return { formErrors: r, fieldErrors: n };
  }
  get formErrors() {
    return this.flatten();
  }
};
Bt.create = (e) => new Bt(e);
var xo = (e, t) => {
  let n;
  switch (e.code) {
    case _.invalid_type:
      e.received === P.undefined ? n = "Required" : n = `Expected ${e.expected}, received ${e.received}`;
      break;
    case _.invalid_literal:
      n = `Invalid literal value, expected ${JSON.stringify(e.expected, V.jsonStringifyReplacer)}`;
      break;
    case _.unrecognized_keys:
      n = `Unrecognized key(s) in object: ${V.joinValues(e.keys, ", ")}`;
      break;
    case _.invalid_union:
      n = "Invalid input";
      break;
    case _.invalid_union_discriminator:
      n = `Invalid discriminator value. Expected ${V.joinValues(e.options)}`;
      break;
    case _.invalid_enum_value:
      n = `Invalid enum value. Expected ${V.joinValues(e.options)}, received '${e.received}'`;
      break;
    case _.invalid_arguments:
      n = "Invalid function arguments";
      break;
    case _.invalid_return_type:
      n = "Invalid function return type";
      break;
    case _.invalid_date:
      n = "Invalid date";
      break;
    case _.invalid_string:
      typeof e.validation == "object" ? "includes" in e.validation ? (n = `Invalid input: must include "${e.validation.includes}"`, typeof e.validation.position == "number" && (n = `${n} at one or more positions greater than or equal to ${e.validation.position}`)) : "startsWith" in e.validation ? n = `Invalid input: must start with "${e.validation.startsWith}"` : "endsWith" in e.validation ? n = `Invalid input: must end with "${e.validation.endsWith}"` : V.assertNever(e.validation) : e.validation !== "regex" ? n = `Invalid ${e.validation}` : n = "Invalid";
      break;
    case _.too_small:
      e.type === "array" ? n = `Array must contain ${e.exact ? "exactly" : e.inclusive ? "at least" : "more than"} ${e.minimum} element(s)` : e.type === "string" ? n = `String must contain ${e.exact ? "exactly" : e.inclusive ? "at least" : "over"} ${e.minimum} character(s)` : e.type === "number" ? n = `Number must be ${e.exact ? "exactly equal to " : e.inclusive ? "greater than or equal to " : "greater than "}${e.minimum}` : e.type === "date" ? n = `Date must be ${e.exact ? "exactly equal to " : e.inclusive ? "greater than or equal to " : "greater than "}${new Date(Number(e.minimum))}` : n = "Invalid input";
      break;
    case _.too_big:
      e.type === "array" ? n = `Array must contain ${e.exact ? "exactly" : e.inclusive ? "at most" : "less than"} ${e.maximum} element(s)` : e.type === "string" ? n = `String must contain ${e.exact ? "exactly" : e.inclusive ? "at most" : "under"} ${e.maximum} character(s)` : e.type === "number" ? n = `Number must be ${e.exact ? "exactly" : e.inclusive ? "less than or equal to" : "less than"} ${e.maximum}` : e.type === "bigint" ? n = `BigInt must be ${e.exact ? "exactly" : e.inclusive ? "less than or equal to" : "less than"} ${e.maximum}` : e.type === "date" ? n = `Date must be ${e.exact ? "exactly" : e.inclusive ? "smaller than or equal to" : "smaller than"} ${new Date(Number(e.maximum))}` : n = "Invalid input";
      break;
    case _.custom:
      n = "Invalid input";
      break;
    case _.invalid_intersection_types:
      n = "Intersection results could not be merged";
      break;
    case _.not_multiple_of:
      n = `Number must be a multiple of ${e.multipleOf}`;
      break;
    case _.not_finite:
      n = "Number must be finite";
      break;
    default:
      n = t.defaultError, V.assertNever(e);
  }
  return { message: n };
};
var ud = xo;
function cd() {
  return ud;
}
var ld = (e) => {
  const { data: t, path: n, errorMaps: r, issueData: s } = e, a = [...n, ...s.path || []], i = {
    ...s,
    path: a
  };
  let o = "";
  const c = r.filter((u) => !!u).slice().reverse();
  for (const u of c)
    o = u(i, { data: t, defaultError: o }).message;
  return {
    ...s,
    path: a,
    message: s.message || o
  };
};
function T(e, t) {
  const n = ld({
    issueData: t,
    data: e.data,
    path: e.path,
    errorMaps: [
      e.common.contextualErrorMap,
      e.schemaErrorMap,
      cd(),
      xo
      // then global default map
    ].filter((r) => !!r)
  });
  e.common.issues.push(n);
}
var Ze = class ko {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    this.value === "valid" && (this.value = "dirty");
  }
  abort() {
    this.value !== "aborted" && (this.value = "aborted");
  }
  static mergeArray(t, n) {
    const r = [];
    for (const s of n) {
      if (s.status === "aborted")
        return Z;
      s.status === "dirty" && t.dirty(), r.push(s.value);
    }
    return { status: t.value, value: r };
  }
  static async mergeObjectAsync(t, n) {
    const r = [];
    for (const s of n)
      r.push({
        key: await s.key,
        value: await s.value
      });
    return ko.mergeObjectSync(t, r);
  }
  static mergeObjectSync(t, n) {
    const r = {};
    for (const s of n) {
      const { key: a, value: i } = s;
      if (a.status === "aborted" || i.status === "aborted")
        return Z;
      a.status === "dirty" && t.dirty(), i.status === "dirty" && t.dirty(), (typeof i.value < "u" || s.alwaysSet) && (r[a.value] = i.value);
    }
    return { status: t.value, value: r };
  }
};
var Z = Object.freeze({
  status: "aborted"
});
var dd = (e) => ({ status: "dirty", value: e });
var De = (e) => ({ status: "valid", value: e });
var ci = (e) => e.status === "aborted";
var li = (e) => e.status === "dirty";
var ws = (e) => e.status === "valid";
var xs = (e) => typeof Promise < "u" && e instanceof Promise;
var C;
(function(e) {
  e.errToObj = (t) => typeof t == "string" ? { message: t } : t || {}, e.toString = (t) => typeof t == "string" ? t : t == null ? void 0 : t.message;
})(C || (C = {}));
var kt = class {
  constructor(t, n, r, s) {
    this._cachedPath = [], this.parent = t, this.data = n, this._path = r, this._key = s;
  }
  get path() {
    return this._cachedPath.length || (this._key instanceof Array ? this._cachedPath.push(...this._path, ...this._key) : this._cachedPath.push(...this._path, this._key)), this._cachedPath;
  }
};
var di = (e, t) => {
  if (ws(t))
    return { success: true, data: t.value };
  if (!e.common.issues.length)
    throw new Error("Validation failed but no issues detected.");
  return {
    success: false,
    get error() {
      if (this._error)
        return this._error;
      const n = new Bt(e.common.issues);
      return this._error = n, this._error;
    }
  };
};
function L(e) {
  if (!e)
    return {};
  const { errorMap: t, invalid_type_error: n, required_error: r, description: s } = e;
  if (t && (n || r))
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  return t ? { errorMap: t, description: s } : { errorMap: (a, i) => a.code !== "invalid_type" ? { message: i.defaultError } : typeof i.data > "u" ? { message: r ?? i.defaultError } : { message: n ?? i.defaultError }, description: s };
}
var z = class {
  constructor(t) {
    this.spa = this.safeParseAsync, this._def = t, this.parse = this.parse.bind(this), this.safeParse = this.safeParse.bind(this), this.parseAsync = this.parseAsync.bind(this), this.safeParseAsync = this.safeParseAsync.bind(this), this.spa = this.spa.bind(this), this.refine = this.refine.bind(this), this.refinement = this.refinement.bind(this), this.superRefine = this.superRefine.bind(this), this.optional = this.optional.bind(this), this.nullable = this.nullable.bind(this), this.nullish = this.nullish.bind(this), this.array = this.array.bind(this), this.promise = this.promise.bind(this), this.or = this.or.bind(this), this.and = this.and.bind(this), this.transform = this.transform.bind(this), this.brand = this.brand.bind(this), this.default = this.default.bind(this), this.catch = this.catch.bind(this), this.describe = this.describe.bind(this), this.pipe = this.pipe.bind(this), this.isNullable = this.isNullable.bind(this), this.isOptional = this.isOptional.bind(this);
  }
  get description() {
    return this._def.description;
  }
  _getType(t) {
    return Lt(t.data);
  }
  _getOrReturnCtx(t, n) {
    return n || {
      common: t.parent.common,
      data: t.data,
      parsedType: Lt(t.data),
      schemaErrorMap: this._def.errorMap,
      path: t.path,
      parent: t.parent
    };
  }
  _processInputParams(t) {
    return {
      status: new Ze(),
      ctx: {
        common: t.parent.common,
        data: t.data,
        parsedType: Lt(t.data),
        schemaErrorMap: this._def.errorMap,
        path: t.path,
        parent: t.parent
      }
    };
  }
  _parseSync(t) {
    const n = this._parse(t);
    if (xs(n))
      throw new Error("Synchronous parse encountered promise.");
    return n;
  }
  _parseAsync(t) {
    const n = this._parse(t);
    return Promise.resolve(n);
  }
  parse(t, n) {
    const r = this.safeParse(t, n);
    if (r.success)
      return r.data;
    throw r.error;
  }
  safeParse(t, n) {
    var r;
    const s = {
      common: {
        issues: [],
        async: (r = n == null ? void 0 : n.async) !== null && r !== void 0 ? r : false,
        contextualErrorMap: n == null ? void 0 : n.errorMap
      },
      path: (n == null ? void 0 : n.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: t,
      parsedType: Lt(t)
    }, a = this._parseSync({ data: t, path: s.path, parent: s });
    return di(s, a);
  }
  async parseAsync(t, n) {
    const r = await this.safeParseAsync(t, n);
    if (r.success)
      return r.data;
    throw r.error;
  }
  async safeParseAsync(t, n) {
    const r = {
      common: {
        issues: [],
        contextualErrorMap: n == null ? void 0 : n.errorMap,
        async: true
      },
      path: (n == null ? void 0 : n.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: t,
      parsedType: Lt(t)
    }, s = this._parse({ data: t, path: r.path, parent: r }), a = await (xs(s) ? s : Promise.resolve(s));
    return di(r, a);
  }
  refine(t, n) {
    const r = (s) => typeof n == "string" || typeof n > "u" ? { message: n } : typeof n == "function" ? n(s) : n;
    return this._refinement((s, a) => {
      const i = t(s), o = () => a.addIssue({
        code: _.custom,
        ...r(s)
      });
      return typeof Promise < "u" && i instanceof Promise ? i.then((c) => c ? true : (o(), false)) : i ? true : (o(), false);
    });
  }
  refinement(t, n) {
    return this._refinement((r, s) => t(r) ? true : (s.addIssue(typeof n == "function" ? n(r, s) : n), false));
  }
  _refinement(t) {
    return new hn({
      schema: this,
      typeName: j.ZodEffects,
      effect: { type: "refinement", refinement: t }
    });
  }
  superRefine(t) {
    return this._refinement(t);
  }
  optional() {
    return gt.create(this, this._def);
  }
  nullable() {
    return pn.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return fn.create(this, this._def);
  }
  promise() {
    return yr.create(this, this._def);
  }
  or(t) {
    return pr.create([this, t], this._def);
  }
  and(t) {
    return mr.create(this, t, this._def);
  }
  transform(t) {
    return new hn({
      ...L(this._def),
      schema: this,
      typeName: j.ZodEffects,
      effect: { type: "transform", transform: t }
    });
  }
  default(t) {
    const n = typeof t == "function" ? t : () => t;
    return new Is({
      ...L(this._def),
      innerType: this,
      defaultValue: n,
      typeName: j.ZodDefault
    });
  }
  brand() {
    return new kd({
      typeName: j.ZodBranded,
      type: this,
      ...L(this._def)
    });
  }
  catch(t) {
    const n = typeof t == "function" ? t : () => t;
    return new Ns({
      ...L(this._def),
      innerType: this,
      catchValue: n,
      typeName: j.ZodCatch
    });
  }
  describe(t) {
    const n = this.constructor;
    return new n({
      ...this._def,
      description: t
    });
  }
  pipe(t) {
    return ga.create(this, t);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
};
var fd = /^c[^\s-]{8,}$/i;
var hd = /^[a-z][a-z0-9]*$/;
var pd = /[0-9A-HJKMNP-TV-Z]{26}/;
var md = /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[a-f0-9]{4}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i;
var yd = /^(([^<>()[\]\\.,;:\s@\"]+(\.[^<>()[\]\\.,;:\s@\"]+)*)|(\".+\"))@((\[(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\])|(\[IPv6:(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))\])|([A-Za-z0-9]([A-Za-z0-9-]*[A-Za-z0-9])*(\.[A-Za-z]{2,})+))$/;
var vd = /^(\p{Extended_Pictographic}|\p{Emoji_Component})+$/u;
var gd = /^(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))$/;
var _d = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/;
var bd = (e) => e.precision ? e.offset ? new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${e.precision}}(([+-]\\d{2}(:?\\d{2})?)|Z)$`) : new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${e.precision}}Z$`) : e.precision === 0 ? e.offset ? new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(([+-]\\d{2}(:?\\d{2})?)|Z)$") : new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}Z$") : e.offset ? new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(([+-]\\d{2}(:?\\d{2})?)|Z)$") : new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?Z$");
function wd(e, t) {
  return !!((t === "v4" || !t) && gd.test(e) || (t === "v6" || !t) && _d.test(e));
}
var ks = class In extends z {
  constructor() {
    super(...arguments), this._regex = (t, n, r) => this.refinement((s) => t.test(s), {
      validation: n,
      code: _.invalid_string,
      ...C.errToObj(r)
    }), this.nonempty = (t) => this.min(1, C.errToObj(t)), this.trim = () => new In({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    }), this.toLowerCase = () => new In({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    }), this.toUpperCase = () => new In({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  _parse(t) {
    if (this._def.coerce && (t.data = String(t.data)), this._getType(t) !== P.string) {
      const s = this._getOrReturnCtx(t);
      return T(
        s,
        {
          code: _.invalid_type,
          expected: P.string,
          received: s.parsedType
        }
        //
      ), Z;
    }
    const n = new Ze();
    let r;
    for (const s of this._def.checks)
      if (s.kind === "min")
        t.data.length < s.value && (r = this._getOrReturnCtx(t, r), T(r, {
          code: _.too_small,
          minimum: s.value,
          type: "string",
          inclusive: true,
          exact: false,
          message: s.message
        }), n.dirty());
      else if (s.kind === "max")
        t.data.length > s.value && (r = this._getOrReturnCtx(t, r), T(r, {
          code: _.too_big,
          maximum: s.value,
          type: "string",
          inclusive: true,
          exact: false,
          message: s.message
        }), n.dirty());
      else if (s.kind === "length") {
        const a = t.data.length > s.value, i = t.data.length < s.value;
        (a || i) && (r = this._getOrReturnCtx(t, r), a ? T(r, {
          code: _.too_big,
          maximum: s.value,
          type: "string",
          inclusive: true,
          exact: true,
          message: s.message
        }) : i && T(r, {
          code: _.too_small,
          minimum: s.value,
          type: "string",
          inclusive: true,
          exact: true,
          message: s.message
        }), n.dirty());
      } else if (s.kind === "email")
        yd.test(t.data) || (r = this._getOrReturnCtx(t, r), T(r, {
          validation: "email",
          code: _.invalid_string,
          message: s.message
        }), n.dirty());
      else if (s.kind === "emoji")
        vd.test(t.data) || (r = this._getOrReturnCtx(t, r), T(r, {
          validation: "emoji",
          code: _.invalid_string,
          message: s.message
        }), n.dirty());
      else if (s.kind === "uuid")
        md.test(t.data) || (r = this._getOrReturnCtx(t, r), T(r, {
          validation: "uuid",
          code: _.invalid_string,
          message: s.message
        }), n.dirty());
      else if (s.kind === "cuid")
        fd.test(t.data) || (r = this._getOrReturnCtx(t, r), T(r, {
          validation: "cuid",
          code: _.invalid_string,
          message: s.message
        }), n.dirty());
      else if (s.kind === "cuid2")
        hd.test(t.data) || (r = this._getOrReturnCtx(t, r), T(r, {
          validation: "cuid2",
          code: _.invalid_string,
          message: s.message
        }), n.dirty());
      else if (s.kind === "ulid")
        pd.test(t.data) || (r = this._getOrReturnCtx(t, r), T(r, {
          validation: "ulid",
          code: _.invalid_string,
          message: s.message
        }), n.dirty());
      else if (s.kind === "url")
        try {
          new URL(t.data);
        } catch {
          r = this._getOrReturnCtx(t, r), T(r, {
            validation: "url",
            code: _.invalid_string,
            message: s.message
          }), n.dirty();
        }
      else
        s.kind === "regex" ? (s.regex.lastIndex = 0, s.regex.test(t.data) || (r = this._getOrReturnCtx(t, r), T(r, {
          validation: "regex",
          code: _.invalid_string,
          message: s.message
        }), n.dirty())) : s.kind === "trim" ? t.data = t.data.trim() : s.kind === "includes" ? t.data.includes(s.value, s.position) || (r = this._getOrReturnCtx(t, r), T(r, {
          code: _.invalid_string,
          validation: { includes: s.value, position: s.position },
          message: s.message
        }), n.dirty()) : s.kind === "toLowerCase" ? t.data = t.data.toLowerCase() : s.kind === "toUpperCase" ? t.data = t.data.toUpperCase() : s.kind === "startsWith" ? t.data.startsWith(s.value) || (r = this._getOrReturnCtx(t, r), T(r, {
          code: _.invalid_string,
          validation: { startsWith: s.value },
          message: s.message
        }), n.dirty()) : s.kind === "endsWith" ? t.data.endsWith(s.value) || (r = this._getOrReturnCtx(t, r), T(r, {
          code: _.invalid_string,
          validation: { endsWith: s.value },
          message: s.message
        }), n.dirty()) : s.kind === "datetime" ? bd(s).test(t.data) || (r = this._getOrReturnCtx(t, r), T(r, {
          code: _.invalid_string,
          validation: "datetime",
          message: s.message
        }), n.dirty()) : s.kind === "ip" ? wd(t.data, s.version) || (r = this._getOrReturnCtx(t, r), T(r, {
          validation: "ip",
          code: _.invalid_string,
          message: s.message
        }), n.dirty()) : V.assertNever(s);
    return { status: n.value, value: t.data };
  }
  _addCheck(t) {
    return new In({
      ...this._def,
      checks: [...this._def.checks, t]
    });
  }
  email(t) {
    return this._addCheck({ kind: "email", ...C.errToObj(t) });
  }
  url(t) {
    return this._addCheck({ kind: "url", ...C.errToObj(t) });
  }
  emoji(t) {
    return this._addCheck({ kind: "emoji", ...C.errToObj(t) });
  }
  uuid(t) {
    return this._addCheck({ kind: "uuid", ...C.errToObj(t) });
  }
  cuid(t) {
    return this._addCheck({ kind: "cuid", ...C.errToObj(t) });
  }
  cuid2(t) {
    return this._addCheck({ kind: "cuid2", ...C.errToObj(t) });
  }
  ulid(t) {
    return this._addCheck({ kind: "ulid", ...C.errToObj(t) });
  }
  ip(t) {
    return this._addCheck({ kind: "ip", ...C.errToObj(t) });
  }
  datetime(t) {
    var n;
    return typeof t == "string" ? this._addCheck({
      kind: "datetime",
      precision: null,
      offset: false,
      message: t
    }) : this._addCheck({
      kind: "datetime",
      precision: typeof (t == null ? void 0 : t.precision) > "u" ? null : t == null ? void 0 : t.precision,
      offset: (n = t == null ? void 0 : t.offset) !== null && n !== void 0 ? n : false,
      ...C.errToObj(t == null ? void 0 : t.message)
    });
  }
  regex(t, n) {
    return this._addCheck({
      kind: "regex",
      regex: t,
      ...C.errToObj(n)
    });
  }
  includes(t, n) {
    return this._addCheck({
      kind: "includes",
      value: t,
      position: n == null ? void 0 : n.position,
      ...C.errToObj(n == null ? void 0 : n.message)
    });
  }
  startsWith(t, n) {
    return this._addCheck({
      kind: "startsWith",
      value: t,
      ...C.errToObj(n)
    });
  }
  endsWith(t, n) {
    return this._addCheck({
      kind: "endsWith",
      value: t,
      ...C.errToObj(n)
    });
  }
  min(t, n) {
    return this._addCheck({
      kind: "min",
      value: t,
      ...C.errToObj(n)
    });
  }
  max(t, n) {
    return this._addCheck({
      kind: "max",
      value: t,
      ...C.errToObj(n)
    });
  }
  length(t, n) {
    return this._addCheck({
      kind: "length",
      value: t,
      ...C.errToObj(n)
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((t) => t.kind === "datetime");
  }
  get isEmail() {
    return !!this._def.checks.find((t) => t.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((t) => t.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((t) => t.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((t) => t.kind === "uuid");
  }
  get isCUID() {
    return !!this._def.checks.find((t) => t.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((t) => t.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((t) => t.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((t) => t.kind === "ip");
  }
  get minLength() {
    let t = null;
    for (const n of this._def.checks)
      n.kind === "min" && (t === null || n.value > t) && (t = n.value);
    return t;
  }
  get maxLength() {
    let t = null;
    for (const n of this._def.checks)
      n.kind === "max" && (t === null || n.value < t) && (t = n.value);
    return t;
  }
};
ks.create = (e) => {
  var t;
  return new ks({
    checks: [],
    typeName: j.ZodString,
    coerce: (t = e == null ? void 0 : e.coerce) !== null && t !== void 0 ? t : false,
    ...L(e)
  });
};
function xd(e, t) {
  const n = (e.toString().split(".")[1] || "").length, r = (t.toString().split(".")[1] || "").length, s = n > r ? n : r, a = parseInt(e.toFixed(s).replace(".", "")), i = parseInt(t.toFixed(s).replace(".", ""));
  return a % i / Math.pow(10, s);
}
var Ss = class Ts extends z {
  constructor() {
    super(...arguments), this.min = this.gte, this.max = this.lte, this.step = this.multipleOf;
  }
  _parse(t) {
    if (this._def.coerce && (t.data = Number(t.data)), this._getType(t) !== P.number) {
      const s = this._getOrReturnCtx(t);
      return T(s, {
        code: _.invalid_type,
        expected: P.number,
        received: s.parsedType
      }), Z;
    }
    let n;
    const r = new Ze();
    for (const s of this._def.checks)
      s.kind === "int" ? V.isInteger(t.data) || (n = this._getOrReturnCtx(t, n), T(n, {
        code: _.invalid_type,
        expected: "integer",
        received: "float",
        message: s.message
      }), r.dirty()) : s.kind === "min" ? (s.inclusive ? t.data < s.value : t.data <= s.value) && (n = this._getOrReturnCtx(t, n), T(n, {
        code: _.too_small,
        minimum: s.value,
        type: "number",
        inclusive: s.inclusive,
        exact: false,
        message: s.message
      }), r.dirty()) : s.kind === "max" ? (s.inclusive ? t.data > s.value : t.data >= s.value) && (n = this._getOrReturnCtx(t, n), T(n, {
        code: _.too_big,
        maximum: s.value,
        type: "number",
        inclusive: s.inclusive,
        exact: false,
        message: s.message
      }), r.dirty()) : s.kind === "multipleOf" ? xd(t.data, s.value) !== 0 && (n = this._getOrReturnCtx(t, n), T(n, {
        code: _.not_multiple_of,
        multipleOf: s.value,
        message: s.message
      }), r.dirty()) : s.kind === "finite" ? Number.isFinite(t.data) || (n = this._getOrReturnCtx(t, n), T(n, {
        code: _.not_finite,
        message: s.message
      }), r.dirty()) : V.assertNever(s);
    return { status: r.value, value: t.data };
  }
  gte(t, n) {
    return this.setLimit("min", t, true, C.toString(n));
  }
  gt(t, n) {
    return this.setLimit("min", t, false, C.toString(n));
  }
  lte(t, n) {
    return this.setLimit("max", t, true, C.toString(n));
  }
  lt(t, n) {
    return this.setLimit("max", t, false, C.toString(n));
  }
  setLimit(t, n, r, s) {
    return new Ts({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind: t,
          value: n,
          inclusive: r,
          message: C.toString(s)
        }
      ]
    });
  }
  _addCheck(t) {
    return new Ts({
      ...this._def,
      checks: [...this._def.checks, t]
    });
  }
  int(t) {
    return this._addCheck({
      kind: "int",
      message: C.toString(t)
    });
  }
  positive(t) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: false,
      message: C.toString(t)
    });
  }
  negative(t) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: false,
      message: C.toString(t)
    });
  }
  nonpositive(t) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: true,
      message: C.toString(t)
    });
  }
  nonnegative(t) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: true,
      message: C.toString(t)
    });
  }
  multipleOf(t, n) {
    return this._addCheck({
      kind: "multipleOf",
      value: t,
      message: C.toString(n)
    });
  }
  finite(t) {
    return this._addCheck({
      kind: "finite",
      message: C.toString(t)
    });
  }
  safe(t) {
    return this._addCheck({
      kind: "min",
      inclusive: true,
      value: Number.MIN_SAFE_INTEGER,
      message: C.toString(t)
    })._addCheck({
      kind: "max",
      inclusive: true,
      value: Number.MAX_SAFE_INTEGER,
      message: C.toString(t)
    });
  }
  get minValue() {
    let t = null;
    for (const n of this._def.checks)
      n.kind === "min" && (t === null || n.value > t) && (t = n.value);
    return t;
  }
  get maxValue() {
    let t = null;
    for (const n of this._def.checks)
      n.kind === "max" && (t === null || n.value < t) && (t = n.value);
    return t;
  }
  get isInt() {
    return !!this._def.checks.find((t) => t.kind === "int" || t.kind === "multipleOf" && V.isInteger(t.value));
  }
  get isFinite() {
    let t = null, n = null;
    for (const r of this._def.checks) {
      if (r.kind === "finite" || r.kind === "int" || r.kind === "multipleOf")
        return true;
      r.kind === "min" ? (n === null || r.value > n) && (n = r.value) : r.kind === "max" && (t === null || r.value < t) && (t = r.value);
    }
    return Number.isFinite(n) && Number.isFinite(t);
  }
};
Ss.create = (e) => new Ss({
  checks: [],
  typeName: j.ZodNumber,
  coerce: (e == null ? void 0 : e.coerce) || false,
  ...L(e)
});
var fi = class Ps extends z {
  constructor() {
    super(...arguments), this.min = this.gte, this.max = this.lte;
  }
  _parse(t) {
    if (this._def.coerce && (t.data = BigInt(t.data)), this._getType(t) !== P.bigint) {
      const s = this._getOrReturnCtx(t);
      return T(s, {
        code: _.invalid_type,
        expected: P.bigint,
        received: s.parsedType
      }), Z;
    }
    let n;
    const r = new Ze();
    for (const s of this._def.checks)
      s.kind === "min" ? (s.inclusive ? t.data < s.value : t.data <= s.value) && (n = this._getOrReturnCtx(t, n), T(n, {
        code: _.too_small,
        type: "bigint",
        minimum: s.value,
        inclusive: s.inclusive,
        message: s.message
      }), r.dirty()) : s.kind === "max" ? (s.inclusive ? t.data > s.value : t.data >= s.value) && (n = this._getOrReturnCtx(t, n), T(n, {
        code: _.too_big,
        type: "bigint",
        maximum: s.value,
        inclusive: s.inclusive,
        message: s.message
      }), r.dirty()) : s.kind === "multipleOf" ? t.data % s.value !== BigInt(0) && (n = this._getOrReturnCtx(t, n), T(n, {
        code: _.not_multiple_of,
        multipleOf: s.value,
        message: s.message
      }), r.dirty()) : V.assertNever(s);
    return { status: r.value, value: t.data };
  }
  gte(t, n) {
    return this.setLimit("min", t, true, C.toString(n));
  }
  gt(t, n) {
    return this.setLimit("min", t, false, C.toString(n));
  }
  lte(t, n) {
    return this.setLimit("max", t, true, C.toString(n));
  }
  lt(t, n) {
    return this.setLimit("max", t, false, C.toString(n));
  }
  setLimit(t, n, r, s) {
    return new Ps({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind: t,
          value: n,
          inclusive: r,
          message: C.toString(s)
        }
      ]
    });
  }
  _addCheck(t) {
    return new Ps({
      ...this._def,
      checks: [...this._def.checks, t]
    });
  }
  positive(t) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: false,
      message: C.toString(t)
    });
  }
  negative(t) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: false,
      message: C.toString(t)
    });
  }
  nonpositive(t) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: true,
      message: C.toString(t)
    });
  }
  nonnegative(t) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: true,
      message: C.toString(t)
    });
  }
  multipleOf(t, n) {
    return this._addCheck({
      kind: "multipleOf",
      value: t,
      message: C.toString(n)
    });
  }
  get minValue() {
    let t = null;
    for (const n of this._def.checks)
      n.kind === "min" && (t === null || n.value > t) && (t = n.value);
    return t;
  }
  get maxValue() {
    let t = null;
    for (const n of this._def.checks)
      n.kind === "max" && (t === null || n.value < t) && (t = n.value);
    return t;
  }
};
fi.create = (e) => {
  var t;
  return new fi({
    checks: [],
    typeName: j.ZodBigInt,
    coerce: (t = e == null ? void 0 : e.coerce) !== null && t !== void 0 ? t : false,
    ...L(e)
  });
};
var Os = class extends z {
  _parse(t) {
    if (this._def.coerce && (t.data = !!t.data), this._getType(t) !== P.boolean) {
      const n = this._getOrReturnCtx(t);
      return T(n, {
        code: _.invalid_type,
        expected: P.boolean,
        received: n.parsedType
      }), Z;
    }
    return De(t.data);
  }
};
Os.create = (e) => new Os({
  typeName: j.ZodBoolean,
  coerce: (e == null ? void 0 : e.coerce) || false,
  ...L(e)
});
var hi = class So extends z {
  _parse(t) {
    if (this._def.coerce && (t.data = new Date(t.data)), this._getType(t) !== P.date) {
      const s = this._getOrReturnCtx(t);
      return T(s, {
        code: _.invalid_type,
        expected: P.date,
        received: s.parsedType
      }), Z;
    }
    if (isNaN(t.data.getTime())) {
      const s = this._getOrReturnCtx(t);
      return T(s, {
        code: _.invalid_date
      }), Z;
    }
    const n = new Ze();
    let r;
    for (const s of this._def.checks)
      s.kind === "min" ? t.data.getTime() < s.value && (r = this._getOrReturnCtx(t, r), T(r, {
        code: _.too_small,
        message: s.message,
        inclusive: true,
        exact: false,
        minimum: s.value,
        type: "date"
      }), n.dirty()) : s.kind === "max" ? t.data.getTime() > s.value && (r = this._getOrReturnCtx(t, r), T(r, {
        code: _.too_big,
        message: s.message,
        inclusive: true,
        exact: false,
        maximum: s.value,
        type: "date"
      }), n.dirty()) : V.assertNever(s);
    return {
      status: n.value,
      value: new Date(t.data.getTime())
    };
  }
  _addCheck(t) {
    return new So({
      ...this._def,
      checks: [...this._def.checks, t]
    });
  }
  min(t, n) {
    return this._addCheck({
      kind: "min",
      value: t.getTime(),
      message: C.toString(n)
    });
  }
  max(t, n) {
    return this._addCheck({
      kind: "max",
      value: t.getTime(),
      message: C.toString(n)
    });
  }
  get minDate() {
    let t = null;
    for (const n of this._def.checks)
      n.kind === "min" && (t === null || n.value > t) && (t = n.value);
    return t != null ? new Date(t) : null;
  }
  get maxDate() {
    let t = null;
    for (const n of this._def.checks)
      n.kind === "max" && (t === null || n.value < t) && (t = n.value);
    return t != null ? new Date(t) : null;
  }
};
hi.create = (e) => new hi({
  checks: [],
  coerce: (e == null ? void 0 : e.coerce) || false,
  typeName: j.ZodDate,
  ...L(e)
});
var pi = class extends z {
  _parse(t) {
    if (this._getType(t) !== P.symbol) {
      const n = this._getOrReturnCtx(t);
      return T(n, {
        code: _.invalid_type,
        expected: P.symbol,
        received: n.parsedType
      }), Z;
    }
    return De(t.data);
  }
};
pi.create = (e) => new pi({
  typeName: j.ZodSymbol,
  ...L(e)
});
var mi = class extends z {
  _parse(t) {
    if (this._getType(t) !== P.undefined) {
      const n = this._getOrReturnCtx(t);
      return T(n, {
        code: _.invalid_type,
        expected: P.undefined,
        received: n.parsedType
      }), Z;
    }
    return De(t.data);
  }
};
mi.create = (e) => new mi({
  typeName: j.ZodUndefined,
  ...L(e)
});
var yi = class extends z {
  _parse(t) {
    if (this._getType(t) !== P.null) {
      const n = this._getOrReturnCtx(t);
      return T(n, {
        code: _.invalid_type,
        expected: P.null,
        received: n.parsedType
      }), Z;
    }
    return De(t.data);
  }
};
yi.create = (e) => new yi({
  typeName: j.ZodNull,
  ...L(e)
});
var vi = class extends z {
  constructor() {
    super(...arguments), this._any = true;
  }
  _parse(t) {
    return De(t.data);
  }
};
vi.create = (e) => new vi({
  typeName: j.ZodAny,
  ...L(e)
});
var gi = class extends z {
  constructor() {
    super(...arguments), this._unknown = true;
  }
  _parse(t) {
    return De(t.data);
  }
};
gi.create = (e) => new gi({
  typeName: j.ZodUnknown,
  ...L(e)
});
var St = class extends z {
  _parse(t) {
    const n = this._getOrReturnCtx(t);
    return T(n, {
      code: _.invalid_type,
      expected: P.never,
      received: n.parsedType
    }), Z;
  }
};
St.create = (e) => new St({
  typeName: j.ZodNever,
  ...L(e)
});
var _i = class extends z {
  _parse(t) {
    if (this._getType(t) !== P.undefined) {
      const n = this._getOrReturnCtx(t);
      return T(n, {
        code: _.invalid_type,
        expected: P.void,
        received: n.parsedType
      }), Z;
    }
    return De(t.data);
  }
};
_i.create = (e) => new _i({
  typeName: j.ZodVoid,
  ...L(e)
});
var fn = class or extends z {
  _parse(t) {
    const { ctx: n, status: r } = this._processInputParams(t), s = this._def;
    if (n.parsedType !== P.array)
      return T(n, {
        code: _.invalid_type,
        expected: P.array,
        received: n.parsedType
      }), Z;
    if (s.exactLength !== null) {
      const i = n.data.length > s.exactLength.value, o = n.data.length < s.exactLength.value;
      (i || o) && (T(n, {
        code: i ? _.too_big : _.too_small,
        minimum: o ? s.exactLength.value : void 0,
        maximum: i ? s.exactLength.value : void 0,
        type: "array",
        inclusive: true,
        exact: true,
        message: s.exactLength.message
      }), r.dirty());
    }
    if (s.minLength !== null && n.data.length < s.minLength.value && (T(n, {
      code: _.too_small,
      minimum: s.minLength.value,
      type: "array",
      inclusive: true,
      exact: false,
      message: s.minLength.message
    }), r.dirty()), s.maxLength !== null && n.data.length > s.maxLength.value && (T(n, {
      code: _.too_big,
      maximum: s.maxLength.value,
      type: "array",
      inclusive: true,
      exact: false,
      message: s.maxLength.message
    }), r.dirty()), n.common.async)
      return Promise.all([...n.data].map((i, o) => s.type._parseAsync(new kt(n, i, n.path, o)))).then((i) => Ze.mergeArray(r, i));
    const a = [...n.data].map((i, o) => s.type._parseSync(new kt(n, i, n.path, o)));
    return Ze.mergeArray(r, a);
  }
  get element() {
    return this._def.type;
  }
  min(t, n) {
    return new or({
      ...this._def,
      minLength: { value: t, message: C.toString(n) }
    });
  }
  max(t, n) {
    return new or({
      ...this._def,
      maxLength: { value: t, message: C.toString(n) }
    });
  }
  length(t, n) {
    return new or({
      ...this._def,
      exactLength: { value: t, message: C.toString(n) }
    });
  }
  nonempty(t) {
    return this.min(1, t);
  }
};
fn.create = (e, t) => new fn({
  type: e,
  minLength: null,
  maxLength: null,
  exactLength: null,
  typeName: j.ZodArray,
  ...L(t)
});
function en(e) {
  if (e instanceof ne) {
    const t = {};
    for (const n in e.shape) {
      const r = e.shape[n];
      t[n] = gt.create(en(r));
    }
    return new ne({
      ...e._def,
      shape: () => t
    });
  } else
    return e instanceof fn ? new fn({
      ...e._def,
      type: en(e.element)
    }) : e instanceof gt ? gt.create(en(e.unwrap())) : e instanceof pn ? pn.create(en(e.unwrap())) : e instanceof Wt ? Wt.create(e.items.map((t) => en(t))) : e;
}
var ne = class _ne extends z {
  constructor() {
    super(...arguments), this._cached = null, this.nonstrict = this.passthrough, this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const t = this._def.shape(), n = V.objectKeys(t);
    return this._cached = { shape: t, keys: n };
  }
  _parse(t) {
    if (this._getType(t) !== P.object) {
      const c = this._getOrReturnCtx(t);
      return T(c, {
        code: _.invalid_type,
        expected: P.object,
        received: c.parsedType
      }), Z;
    }
    const { status: n, ctx: r } = this._processInputParams(t), { shape: s, keys: a } = this._getCached(), i = [];
    if (!(this._def.catchall instanceof St && this._def.unknownKeys === "strip"))
      for (const c in r.data)
        a.includes(c) || i.push(c);
    const o = [];
    for (const c of a) {
      const u = s[c], d = r.data[c];
      o.push({
        key: { status: "valid", value: c },
        value: u._parse(new kt(r, d, r.path, c)),
        alwaysSet: c in r.data
      });
    }
    if (this._def.catchall instanceof St) {
      const c = this._def.unknownKeys;
      if (c === "passthrough")
        for (const u of i)
          o.push({
            key: { status: "valid", value: u },
            value: { status: "valid", value: r.data[u] }
          });
      else if (c === "strict")
        i.length > 0 && (T(r, {
          code: _.unrecognized_keys,
          keys: i
        }), n.dirty());
      else if (c !== "strip")
        throw new Error("Internal ZodObject error: invalid unknownKeys value.");
    } else {
      const c = this._def.catchall;
      for (const u of i) {
        const d = r.data[u];
        o.push({
          key: { status: "valid", value: u },
          value: c._parse(
            new kt(r, d, r.path, u)
            //, ctx.child(key), value, getParsedType(value)
          ),
          alwaysSet: u in r.data
        });
      }
    }
    return r.common.async ? Promise.resolve().then(async () => {
      const c = [];
      for (const u of o) {
        const d = await u.key;
        c.push({
          key: d,
          value: await u.value,
          alwaysSet: u.alwaysSet
        });
      }
      return c;
    }).then((c) => Ze.mergeObjectSync(n, c)) : Ze.mergeObjectSync(n, o);
  }
  get shape() {
    return this._def.shape();
  }
  strict(t) {
    return C.errToObj, new _ne({
      ...this._def,
      unknownKeys: "strict",
      ...t !== void 0 ? {
        errorMap: (n, r) => {
          var s, a, i, o;
          const c = (i = (a = (s = this._def).errorMap) === null || a === void 0 ? void 0 : a.call(s, n, r).message) !== null && i !== void 0 ? i : r.defaultError;
          return n.code === "unrecognized_keys" ? {
            message: (o = C.errToObj(t).message) !== null && o !== void 0 ? o : c
          } : {
            message: c
          };
        }
      } : {}
    });
  }
  strip() {
    return new _ne({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new _ne({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  // const AugmentFactory =
  //   <Def extends ZodObjectDef>(def: Def) =>
  //   <Augmentation extends ZodRawShape>(
  //     augmentation: Augmentation
  //   ): ZodObject<
  //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
  //     Def["unknownKeys"],
  //     Def["catchall"]
  //   > => {
  //     return new ZodObject({
  //       ...def,
  //       shape: () => ({
  //         ...def.shape(),
  //         ...augmentation,
  //       }),
  //     }) as any;
  //   };
  extend(t) {
    return new _ne({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...t
      })
    });
  }
  /**
   * Prior to zod@1.0.12 there was a bug in the
   * inferred type of merged objects. Please
   * upgrade if you are experiencing issues.
   */
  merge(t) {
    return new _ne({
      unknownKeys: t._def.unknownKeys,
      catchall: t._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...t._def.shape()
      }),
      typeName: j.ZodObject
    });
  }
  // merge<
  //   Incoming extends AnyZodObject,
  //   Augmentation extends Incoming["shape"],
  //   NewOutput extends {
  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
  //       ? Augmentation[k]["_output"]
  //       : k extends keyof Output
  //       ? Output[k]
  //       : never;
  //   },
  //   NewInput extends {
  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
  //       ? Augmentation[k]["_input"]
  //       : k extends keyof Input
  //       ? Input[k]
  //       : never;
  //   }
  // >(
  //   merging: Incoming
  // ): ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"],
  //   NewOutput,
  //   NewInput
  // > {
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  setKey(t, n) {
    return this.augment({ [t]: n });
  }
  // merge<Incoming extends AnyZodObject>(
  //   merging: Incoming
  // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
  // ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"]
  // > {
  //   // const mergedShape = objectUtil.mergeShapes(
  //   //   this._def.shape(),
  //   //   merging._def.shape()
  //   // );
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  catchall(t) {
    return new _ne({
      ...this._def,
      catchall: t
    });
  }
  pick(t) {
    const n = {};
    return V.objectKeys(t).forEach((r) => {
      t[r] && this.shape[r] && (n[r] = this.shape[r]);
    }), new _ne({
      ...this._def,
      shape: () => n
    });
  }
  omit(t) {
    const n = {};
    return V.objectKeys(this.shape).forEach((r) => {
      t[r] || (n[r] = this.shape[r]);
    }), new _ne({
      ...this._def,
      shape: () => n
    });
  }
  /**
   * @deprecated
   */
  deepPartial() {
    return en(this);
  }
  partial(t) {
    const n = {};
    return V.objectKeys(this.shape).forEach((r) => {
      const s = this.shape[r];
      t && !t[r] ? n[r] = s : n[r] = s.optional();
    }), new _ne({
      ...this._def,
      shape: () => n
    });
  }
  required(t) {
    const n = {};
    return V.objectKeys(this.shape).forEach((r) => {
      if (t && !t[r])
        n[r] = this.shape[r];
      else {
        let s = this.shape[r];
        for (; s instanceof gt; )
          s = s._def.innerType;
        n[r] = s;
      }
    }), new _ne({
      ...this._def,
      shape: () => n
    });
  }
  keyof() {
    return To(V.objectKeys(this.shape));
  }
};
ne.create = (e, t) => new ne({
  shape: () => e,
  unknownKeys: "strip",
  catchall: St.create(),
  typeName: j.ZodObject,
  ...L(t)
});
ne.strictCreate = (e, t) => new ne({
  shape: () => e,
  unknownKeys: "strict",
  catchall: St.create(),
  typeName: j.ZodObject,
  ...L(t)
});
ne.lazycreate = (e, t) => new ne({
  shape: e,
  unknownKeys: "strip",
  catchall: St.create(),
  typeName: j.ZodObject,
  ...L(t)
});
var pr = class extends z {
  _parse(t) {
    const { ctx: n } = this._processInputParams(t), r = this._def.options;
    function s(a) {
      for (const o of a)
        if (o.result.status === "valid")
          return o.result;
      for (const o of a)
        if (o.result.status === "dirty")
          return n.common.issues.push(...o.ctx.common.issues), o.result;
      const i = a.map((o) => new Bt(o.ctx.common.issues));
      return T(n, {
        code: _.invalid_union,
        unionErrors: i
      }), Z;
    }
    if (n.common.async)
      return Promise.all(r.map(async (a) => {
        const i = {
          ...n,
          common: {
            ...n.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await a._parseAsync({
            data: n.data,
            path: n.path,
            parent: i
          }),
          ctx: i
        };
      })).then(s);
    {
      let a;
      const i = [];
      for (const c of r) {
        const u = {
          ...n,
          common: {
            ...n.common,
            issues: []
          },
          parent: null
        }, d = c._parseSync({
          data: n.data,
          path: n.path,
          parent: u
        });
        if (d.status === "valid")
          return d;
        d.status === "dirty" && !a && (a = { result: d, ctx: u }), u.common.issues.length && i.push(u.common.issues);
      }
      if (a)
        return n.common.issues.push(...a.ctx.common.issues), a.result;
      const o = i.map((c) => new Bt(c));
      return T(n, {
        code: _.invalid_union,
        unionErrors: o
      }), Z;
    }
  }
  get options() {
    return this._def.options;
  }
};
pr.create = (e, t) => new pr({
  options: e,
  typeName: j.ZodUnion,
  ...L(t)
});
function Es(e, t) {
  const n = Lt(e), r = Lt(t);
  if (e === t)
    return { valid: true, data: e };
  if (n === P.object && r === P.object) {
    const s = V.objectKeys(t), a = V.objectKeys(e).filter((o) => s.indexOf(o) !== -1), i = { ...e, ...t };
    for (const o of a) {
      const c = Es(e[o], t[o]);
      if (!c.valid)
        return { valid: false };
      i[o] = c.data;
    }
    return { valid: true, data: i };
  } else if (n === P.array && r === P.array) {
    if (e.length !== t.length)
      return { valid: false };
    const s = [];
    for (let a = 0; a < e.length; a++) {
      const i = e[a], o = t[a], c = Es(i, o);
      if (!c.valid)
        return { valid: false };
      s.push(c.data);
    }
    return { valid: true, data: s };
  } else
    return n === P.date && r === P.date && +e == +t ? { valid: true, data: e } : { valid: false };
}
var mr = class extends z {
  _parse(t) {
    const { status: n, ctx: r } = this._processInputParams(t), s = (a, i) => {
      if (ci(a) || ci(i))
        return Z;
      const o = Es(a.value, i.value);
      return o.valid ? ((li(a) || li(i)) && n.dirty(), { status: n.value, value: o.data }) : (T(r, {
        code: _.invalid_intersection_types
      }), Z);
    };
    return r.common.async ? Promise.all([
      this._def.left._parseAsync({
        data: r.data,
        path: r.path,
        parent: r
      }),
      this._def.right._parseAsync({
        data: r.data,
        path: r.path,
        parent: r
      })
    ]).then(([a, i]) => s(a, i)) : s(this._def.left._parseSync({
      data: r.data,
      path: r.path,
      parent: r
    }), this._def.right._parseSync({
      data: r.data,
      path: r.path,
      parent: r
    }));
  }
};
mr.create = (e, t, n) => new mr({
  left: e,
  right: t,
  typeName: j.ZodIntersection,
  ...L(n)
});
var Wt = class _Wt extends z {
  _parse(t) {
    const { status: n, ctx: r } = this._processInputParams(t);
    if (r.parsedType !== P.array)
      return T(r, {
        code: _.invalid_type,
        expected: P.array,
        received: r.parsedType
      }), Z;
    if (r.data.length < this._def.items.length)
      return T(r, {
        code: _.too_small,
        minimum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      }), Z;
    !this._def.rest && r.data.length > this._def.items.length && (T(r, {
      code: _.too_big,
      maximum: this._def.items.length,
      inclusive: true,
      exact: false,
      type: "array"
    }), n.dirty());
    const s = [...r.data].map((a, i) => {
      const o = this._def.items[i] || this._def.rest;
      return o ? o._parse(new kt(r, a, r.path, i)) : null;
    }).filter((a) => !!a);
    return r.common.async ? Promise.all(s).then((a) => Ze.mergeArray(n, a)) : Ze.mergeArray(n, s);
  }
  get items() {
    return this._def.items;
  }
  rest(t) {
    return new _Wt({
      ...this._def,
      rest: t
    });
  }
};
Wt.create = (e, t) => {
  if (!Array.isArray(e))
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  return new Wt({
    items: e,
    typeName: j.ZodTuple,
    rest: null,
    ...L(t)
  });
};
var bi = class extends z {
  _parse(t) {
    const { status: n, ctx: r } = this._processInputParams(t);
    if (r.parsedType !== P.map)
      return T(r, {
        code: _.invalid_type,
        expected: P.map,
        received: r.parsedType
      }), Z;
    const s = this._def.keyType, a = this._def.valueType, i = [...r.data.entries()].map(([o, c], u) => ({
      key: s._parse(new kt(r, o, r.path, [u, "key"])),
      value: a._parse(new kt(r, c, r.path, [u, "value"]))
    }));
    if (r.common.async) {
      const o = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (const c of i) {
          const u = await c.key, d = await c.value;
          if (u.status === "aborted" || d.status === "aborted")
            return Z;
          (u.status === "dirty" || d.status === "dirty") && n.dirty(), o.set(u.value, d.value);
        }
        return { status: n.value, value: o };
      });
    } else {
      const o = /* @__PURE__ */ new Map();
      for (const c of i) {
        const u = c.key, d = c.value;
        if (u.status === "aborted" || d.status === "aborted")
          return Z;
        (u.status === "dirty" || d.status === "dirty") && n.dirty(), o.set(u.value, d.value);
      }
      return { status: n.value, value: o };
    }
  }
};
bi.create = (e, t, n) => new bi({
  valueType: t,
  keyType: e,
  typeName: j.ZodMap,
  ...L(n)
});
var wi = class Cs extends z {
  _parse(t) {
    const { status: n, ctx: r } = this._processInputParams(t);
    if (r.parsedType !== P.set)
      return T(r, {
        code: _.invalid_type,
        expected: P.set,
        received: r.parsedType
      }), Z;
    const s = this._def;
    s.minSize !== null && r.data.size < s.minSize.value && (T(r, {
      code: _.too_small,
      minimum: s.minSize.value,
      type: "set",
      inclusive: true,
      exact: false,
      message: s.minSize.message
    }), n.dirty()), s.maxSize !== null && r.data.size > s.maxSize.value && (T(r, {
      code: _.too_big,
      maximum: s.maxSize.value,
      type: "set",
      inclusive: true,
      exact: false,
      message: s.maxSize.message
    }), n.dirty());
    const a = this._def.valueType;
    function i(c) {
      const u = /* @__PURE__ */ new Set();
      for (const d of c) {
        if (d.status === "aborted")
          return Z;
        d.status === "dirty" && n.dirty(), u.add(d.value);
      }
      return { status: n.value, value: u };
    }
    const o = [...r.data.values()].map((c, u) => a._parse(new kt(r, c, r.path, u)));
    return r.common.async ? Promise.all(o).then((c) => i(c)) : i(o);
  }
  min(t, n) {
    return new Cs({
      ...this._def,
      minSize: { value: t, message: C.toString(n) }
    });
  }
  max(t, n) {
    return new Cs({
      ...this._def,
      maxSize: { value: t, message: C.toString(n) }
    });
  }
  size(t, n) {
    return this.min(t, n).max(t, n);
  }
  nonempty(t) {
    return this.min(1, t);
  }
};
wi.create = (e, t) => new wi({
  valueType: e,
  minSize: null,
  maxSize: null,
  typeName: j.ZodSet,
  ...L(t)
});
var xi = class extends z {
  get schema() {
    return this._def.getter();
  }
  _parse(t) {
    const { ctx: n } = this._processInputParams(t);
    return this._def.getter()._parse({ data: n.data, path: n.path, parent: n });
  }
};
xi.create = (e, t) => new xi({
  getter: e,
  typeName: j.ZodLazy,
  ...L(t)
});
var Rs = class extends z {
  _parse(t) {
    if (t.data !== this._def.value) {
      const n = this._getOrReturnCtx(t);
      return T(n, {
        received: n.data,
        code: _.invalid_literal,
        expected: this._def.value
      }), Z;
    }
    return { status: "valid", value: t.data };
  }
  get value() {
    return this._def.value;
  }
};
Rs.create = (e, t) => new Rs({
  value: e,
  typeName: j.ZodLiteral,
  ...L(t)
});
function To(e, t) {
  return new va({
    values: e,
    typeName: j.ZodEnum,
    ...L(t)
  });
}
var va = class As extends z {
  _parse(t) {
    if (typeof t.data != "string") {
      const n = this._getOrReturnCtx(t), r = this._def.values;
      return T(n, {
        expected: V.joinValues(r),
        received: n.parsedType,
        code: _.invalid_type
      }), Z;
    }
    if (this._def.values.indexOf(t.data) === -1) {
      const n = this._getOrReturnCtx(t), r = this._def.values;
      return T(n, {
        received: n.data,
        code: _.invalid_enum_value,
        options: r
      }), Z;
    }
    return De(t.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const t = {};
    for (const n of this._def.values)
      t[n] = n;
    return t;
  }
  get Values() {
    const t = {};
    for (const n of this._def.values)
      t[n] = n;
    return t;
  }
  get Enum() {
    const t = {};
    for (const n of this._def.values)
      t[n] = n;
    return t;
  }
  extract(t) {
    return As.create(t);
  }
  exclude(t) {
    return As.create(this.options.filter((n) => !t.includes(n)));
  }
};
va.create = To;
var ki = class extends z {
  _parse(t) {
    const n = V.getValidEnumValues(this._def.values), r = this._getOrReturnCtx(t);
    if (r.parsedType !== P.string && r.parsedType !== P.number) {
      const s = V.objectValues(n);
      return T(r, {
        expected: V.joinValues(s),
        received: r.parsedType,
        code: _.invalid_type
      }), Z;
    }
    if (n.indexOf(t.data) === -1) {
      const s = V.objectValues(n);
      return T(r, {
        received: r.data,
        code: _.invalid_enum_value,
        options: s
      }), Z;
    }
    return De(t.data);
  }
  get enum() {
    return this._def.values;
  }
};
ki.create = (e, t) => new ki({
  values: e,
  typeName: j.ZodNativeEnum,
  ...L(t)
});
var yr = class extends z {
  unwrap() {
    return this._def.type;
  }
  _parse(t) {
    const { ctx: n } = this._processInputParams(t);
    if (n.parsedType !== P.promise && n.common.async === false)
      return T(n, {
        code: _.invalid_type,
        expected: P.promise,
        received: n.parsedType
      }), Z;
    const r = n.parsedType === P.promise ? n.data : Promise.resolve(n.data);
    return De(r.then((s) => this._def.type.parseAsync(s, {
      path: n.path,
      errorMap: n.common.contextualErrorMap
    })));
  }
};
yr.create = (e, t) => new yr({
  type: e,
  typeName: j.ZodPromise,
  ...L(t)
});
var hn = class extends z {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === j.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(t) {
    const { status: n, ctx: r } = this._processInputParams(t), s = this._def.effect || null;
    if (s.type === "preprocess") {
      const i = s.transform(r.data);
      return r.common.async ? Promise.resolve(i).then((o) => this._def.schema._parseAsync({
        data: o,
        path: r.path,
        parent: r
      })) : this._def.schema._parseSync({
        data: i,
        path: r.path,
        parent: r
      });
    }
    const a = {
      addIssue: (i) => {
        T(r, i), i.fatal ? n.abort() : n.dirty();
      },
      get path() {
        return r.path;
      }
    };
    if (a.addIssue = a.addIssue.bind(a), s.type === "refinement") {
      const i = (o) => {
        const c = s.refinement(o, a);
        if (r.common.async)
          return Promise.resolve(c);
        if (c instanceof Promise)
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        return o;
      };
      if (r.common.async === false) {
        const o = this._def.schema._parseSync({
          data: r.data,
          path: r.path,
          parent: r
        });
        return o.status === "aborted" ? Z : (o.status === "dirty" && n.dirty(), i(o.value), { status: n.value, value: o.value });
      } else
        return this._def.schema._parseAsync({ data: r.data, path: r.path, parent: r }).then((o) => o.status === "aborted" ? Z : (o.status === "dirty" && n.dirty(), i(o.value).then(() => ({ status: n.value, value: o.value }))));
    }
    if (s.type === "transform")
      if (r.common.async === false) {
        const i = this._def.schema._parseSync({
          data: r.data,
          path: r.path,
          parent: r
        });
        if (!ws(i))
          return i;
        const o = s.transform(i.value, a);
        if (o instanceof Promise)
          throw new Error("Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.");
        return { status: n.value, value: o };
      } else
        return this._def.schema._parseAsync({ data: r.data, path: r.path, parent: r }).then((i) => ws(i) ? Promise.resolve(s.transform(i.value, a)).then((o) => ({ status: n.value, value: o })) : i);
    V.assertNever(s);
  }
};
hn.create = (e, t, n) => new hn({
  schema: e,
  typeName: j.ZodEffects,
  effect: t,
  ...L(n)
});
hn.createWithPreprocess = (e, t, n) => new hn({
  schema: t,
  effect: { type: "preprocess", transform: e },
  typeName: j.ZodEffects,
  ...L(n)
});
var gt = class extends z {
  _parse(t) {
    return this._getType(t) === P.undefined ? De(void 0) : this._def.innerType._parse(t);
  }
  unwrap() {
    return this._def.innerType;
  }
};
gt.create = (e, t) => new gt({
  innerType: e,
  typeName: j.ZodOptional,
  ...L(t)
});
var pn = class extends z {
  _parse(t) {
    return this._getType(t) === P.null ? De(null) : this._def.innerType._parse(t);
  }
  unwrap() {
    return this._def.innerType;
  }
};
pn.create = (e, t) => new pn({
  innerType: e,
  typeName: j.ZodNullable,
  ...L(t)
});
var Is = class extends z {
  _parse(t) {
    const { ctx: n } = this._processInputParams(t);
    let r = n.data;
    return n.parsedType === P.undefined && (r = this._def.defaultValue()), this._def.innerType._parse({
      data: r,
      path: n.path,
      parent: n
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
};
Is.create = (e, t) => new Is({
  innerType: e,
  typeName: j.ZodDefault,
  defaultValue: typeof t.default == "function" ? t.default : () => t.default,
  ...L(t)
});
var Ns = class extends z {
  _parse(t) {
    const { ctx: n } = this._processInputParams(t), r = {
      ...n,
      common: {
        ...n.common,
        issues: []
      }
    }, s = this._def.innerType._parse({
      data: r.data,
      path: r.path,
      parent: {
        ...r
      }
    });
    return xs(s) ? s.then((a) => ({
      status: "valid",
      value: a.status === "valid" ? a.value : this._def.catchValue({
        get error() {
          return new Bt(r.common.issues);
        },
        input: r.data
      })
    })) : {
      status: "valid",
      value: s.status === "valid" ? s.value : this._def.catchValue({
        get error() {
          return new Bt(r.common.issues);
        },
        input: r.data
      })
    };
  }
  removeCatch() {
    return this._def.innerType;
  }
};
Ns.create = (e, t) => new Ns({
  innerType: e,
  typeName: j.ZodCatch,
  catchValue: typeof t.catch == "function" ? t.catch : () => t.catch,
  ...L(t)
});
var Si = class extends z {
  _parse(t) {
    if (this._getType(t) !== P.nan) {
      const n = this._getOrReturnCtx(t);
      return T(n, {
        code: _.invalid_type,
        expected: P.nan,
        received: n.parsedType
      }), Z;
    }
    return { status: "valid", value: t.data };
  }
};
Si.create = (e) => new Si({
  typeName: j.ZodNaN,
  ...L(e)
});
var kd = class extends z {
  _parse(t) {
    const { ctx: n } = this._processInputParams(t), r = n.data;
    return this._def.type._parse({
      data: r,
      path: n.path,
      parent: n
    });
  }
  unwrap() {
    return this._def.type;
  }
};
var ga = class _ga extends z {
  _parse(t) {
    const { status: n, ctx: r } = this._processInputParams(t);
    if (r.common.async)
      return (async () => {
        const s = await this._def.in._parseAsync({
          data: r.data,
          path: r.path,
          parent: r
        });
        return s.status === "aborted" ? Z : s.status === "dirty" ? (n.dirty(), dd(s.value)) : this._def.out._parseAsync({
          data: s.value,
          path: r.path,
          parent: r
        });
      })();
    {
      const s = this._def.in._parseSync({
        data: r.data,
        path: r.path,
        parent: r
      });
      return s.status === "aborted" ? Z : s.status === "dirty" ? (n.dirty(), {
        status: "dirty",
        value: s.value
      }) : this._def.out._parseSync({
        data: s.value,
        path: r.path,
        parent: r
      });
    }
  }
  static create(t, n) {
    return new _ga({
      in: t,
      out: n,
      typeName: j.ZodPipeline
    });
  }
};
ne.lazycreate;
var j;
(function(e) {
  e.ZodString = "ZodString", e.ZodNumber = "ZodNumber", e.ZodNaN = "ZodNaN", e.ZodBigInt = "ZodBigInt", e.ZodBoolean = "ZodBoolean", e.ZodDate = "ZodDate", e.ZodSymbol = "ZodSymbol", e.ZodUndefined = "ZodUndefined", e.ZodNull = "ZodNull", e.ZodAny = "ZodAny", e.ZodUnknown = "ZodUnknown", e.ZodNever = "ZodNever", e.ZodVoid = "ZodVoid", e.ZodArray = "ZodArray", e.ZodObject = "ZodObject", e.ZodUnion = "ZodUnion", e.ZodDiscriminatedUnion = "ZodDiscriminatedUnion", e.ZodIntersection = "ZodIntersection", e.ZodTuple = "ZodTuple", e.ZodRecord = "ZodRecord", e.ZodMap = "ZodMap", e.ZodSet = "ZodSet", e.ZodFunction = "ZodFunction", e.ZodLazy = "ZodLazy", e.ZodLiteral = "ZodLiteral", e.ZodEnum = "ZodEnum", e.ZodEffects = "ZodEffects", e.ZodNativeEnum = "ZodNativeEnum", e.ZodOptional = "ZodOptional", e.ZodNullable = "ZodNullable", e.ZodDefault = "ZodDefault", e.ZodCatch = "ZodCatch", e.ZodPromise = "ZodPromise", e.ZodBranded = "ZodBranded", e.ZodPipeline = "ZodPipeline";
})(j || (j = {}));
var W = ks.create;
var $r = Ss.create;
var js = Os.create;
St.create;
var qn = fn.create;
var U = ne.create;
ne.strictCreate;
var Se = pr.create;
mr.create;
Wt.create;
var H = Rs.create;
va.create;
yr.create;
gt.create;
pn.create;
var Po = U({
  address: W(),
  label: W(),
  appearanceId: $r()
});
var zn = U({
  publicKey: W(),
  signature: W(),
  curve: Se([H("curve25519"), H("secp256k1")])
});
var Sd = U({
  accountAddress: W(),
  proof: zn
});
var Un = U({ identityAddress: W(), label: W() });
var Ti = {
  western: "western",
  eastern: "eastern"
};
var Td = Se([
  H(Ti.eastern),
  H(Ti.western)
]);
var Oo = U({
  variant: Td,
  familyName: W(),
  nickname: W(),
  givenNames: W()
});
var Ke = U({
  quantifier: Se([H("exactly"), H("atLeast")]),
  quantity: $r().gte(1)
});
var Ds = U({
  challenge: W().optional(),
  numberOfAccounts: Ke
});
var qs = U({
  accounts: qn(Po),
  challenge: W().optional(),
  proofs: qn(Sd).optional()
}).refine((e) => {
  var t;
  return e.challenge || e != null && e.proofs ? e.challenge && ((t = e == null ? void 0 : e.proofs) == null ? void 0 : t.length) : true;
}, "missing challenge or proofs");
var vr = U({
  isRequestingName: js().optional(),
  numberOfRequestedEmailAddresses: Ke.optional(),
  numberOfRequestedPhoneNumbers: Ke.optional()
});
var $s = U({
  name: Oo.optional(),
  emailAddresses: qn(W()).optional(),
  phoneNumbers: qn(W()).optional()
});
var Pd = U({
  accounts: js(),
  personaData: js()
});
var Eg = U({
  persona: Un,
  challenge: W().optional(),
  proof: zn.optional()
}).refine((e) => e.challenge || e.proof ? e.challenge && e.proof : true, "missing challenge or proof");
var Od = U({
  discriminator: H("unauthorizedRequest"),
  oneTimeAccounts: Ds.optional(),
  oneTimePersonaData: vr.optional()
});
var Ed = U({
  discriminator: H("usePersona"),
  identityAddress: W()
});
var Cd = U({
  discriminator: H("loginWithoutChallenge")
});
var Rd = U({
  discriminator: H("loginWithChallenge"),
  challenge: W()
});
var Ad = Se([
  Cd,
  Rd
]);
var Id = Se([
  Ed,
  Ad
]);
var Nd = U({
  discriminator: H("authorizedRequest"),
  auth: Id,
  reset: Pd.optional(),
  oneTimeAccounts: Ds.optional(),
  ongoingAccounts: Ds.optional(),
  oneTimePersonaData: vr.optional(),
  ongoingPersonaData: vr.optional()
});
var jd = Se([
  Od,
  Nd
]);
var Dd = U({
  transactionManifest: W(),
  version: $r(),
  blobs: qn(W()).optional(),
  message: W().optional()
});
var qd = U({
  discriminator: H("transaction"),
  send: Dd
});
var $d = U({
  transactionIntentHash: W()
});
var Ld = U({
  discriminator: H("transaction"),
  send: $d
});
var Zd = U({
  discriminator: H("cancelRequest")
});
var Md = Se([
  jd,
  qd,
  Zd
]);
var Eo = U({
  version: H(2),
  networkId: $r(),
  dAppDefinitionAddress: W()
});
var Fd = U({
  interactionId: W(),
  metadata: Eo,
  items: Md
});
var zd = U({
  discriminator: H("unauthorizedRequest"),
  oneTimeAccounts: qs.optional(),
  oneTimePersonaData: $s.optional()
});
var Ud = U({
  discriminator: H("loginWithoutChallenge"),
  persona: Un
});
var Vd = U({
  discriminator: H("loginWithChallenge"),
  persona: Un,
  challenge: W(),
  proof: zn
});
var Bd = Se([
  Ud,
  Vd
]);
var Wd = U({
  discriminator: H("usePersona"),
  persona: Un
});
var Kd = Se([
  Wd,
  Bd
]);
var Gd = U({
  discriminator: H("authorizedRequest"),
  auth: Kd,
  oneTimeAccounts: qs.optional(),
  ongoingAccounts: qs.optional(),
  oneTimePersonaData: $s.optional(),
  ongoingPersonaData: $s.optional()
});
var Hd = Se([
  zd,
  Gd
]);
var Jd = Se([
  Hd,
  Ld
]);
var Yd = U({
  discriminator: H("success"),
  interactionId: W(),
  items: Jd
});
var Xd = U({
  discriminator: H("failure"),
  interactionId: W(),
  error: W(),
  message: W().optional()
});
var Co = Se([
  Yd,
  Xd
]);
var er = {
  receivedByExtension: "receivedByExtension",
  receivedByWallet: "receivedByWallet",
  requestCancelSuccess: "requestCancelSuccess",
  requestCancelFail: "requestCancelFail"
};
var Qd = U({
  eventType: Se([
    H(er.receivedByExtension),
    H(er.receivedByWallet),
    H(er.requestCancelSuccess),
    H(er.requestCancelFail)
  ]),
  interactionId: W()
});
Se([
  Qd,
  Co
]);
var as = {
  outgoingMessage: "radix#chromeExtension#send",
  incomingMessage: "radix#chromeExtension#receive"
};
var ef = (e, t) => nt.fromPromise(
  e.parseAsync(t),
  (n) => n.issues
);
var Ro = (e) => (t, n, r = crypto.randomUUID()) => {
  const s = {
    items: n,
    interactionId: r,
    metadata: t
  };
  return ef(Fd, s).mapErr((a) => (e == null || e.error(" invalidWalletInteraction", a), mn(
    Nn.walletRequestValidation,
    s.interactionId
  )));
};
var Cg = Object.freeze(Object.defineProperty({
  __proto__: null,
  walletInteractionFactory: Ro
}, Symbol.toStringTag, { value: "Module" }));
var tf = (e) => e;
var Nn = {
  rejectedByUser: "rejectedByUser",
  missingExtension: "missingExtension",
  canceledByUser: "canceledByUser",
  walletRequestValidation: "walletRequestValidation",
  walletResponseValidation: "walletResponseValidation",
  wrongNetwork: "wrongNetwork",
  failedToPrepareTransaction: "failedToPrepareTransaction",
  failedToCompileTransaction: "failedToCompileTransaction",
  failedToSignTransaction: "failedToSignTransaction",
  failedToSubmitTransaction: "failedToSubmitTransaction",
  failedToPollSubmittedTransaction: "failedToPollSubmittedTransaction",
  submittedTransactionWasDuplicate: "submittedTransactionWasDuplicate",
  submittedTransactionHasFailedTransactionStatus: "submittedTransactionHasFailedTransactionStatus",
  submittedTransactionHasRejectedTransactionStatus: "submittedTransactionHasRejectedTransactionStatus",
  failedToFindAccountWithEnoughFundsToLockFee: "failedToFindAccountWithEnoughFundsToLockFee",
  wrongAccountType: "wrongAccountType",
  unknownWebsite: "unknownWebsite",
  radixJsonNotFound: "radixJsonNotFound",
  unknownDappDefinitionAddress: "unknownDappDefinitionAddress",
  invalidPersona: "invalidPersona"
};
var nf = (/* @__PURE__ */ new Map()).set(Nn.missingExtension, "extension could not be found").set(Nn.rejectedByUser, "user rejected request").set(Nn.canceledByUser, "user has canceled the request");
var mn = (e, t, n) => ({
  error: e,
  interactionId: t,
  message: n || nf.get(e) || ""
});
var Pi = (e) => nt.fromPromise(
  Co.parseAsync(e),
  (t) => t.issues
).andThen(
  (t) => t.discriminator === "success" ? We(t) : je(t)
).mapErr(() => mn("walletResponseValidation", ""));
var rf = (e, t) => {
  const n = e.logger, r = Ro(n);
  return {
    request: (s, a = {}) => r(e, s).andThen(
      (i) => t.send(i, a)
    ).andThen(Pi).map((i) => i.items),
    sendTransaction: (s, a = {}) => r(e, {
      discriminator: "transaction",
      send: s
    }).andThen(
      (i) => t.send(i, a)
    ).andThen(Pi).map(
      (i) => i.items.send
    )
  };
};
var Ls = function(e, t) {
  return Ls = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n, r) {
    n.__proto__ = r;
  } || function(n, r) {
    for (var s in r)
      Object.prototype.hasOwnProperty.call(r, s) && (n[s] = r[s]);
  }, Ls(e, t);
};
function Ot(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
  Ls(e, t);
  function n() {
    this.constructor = e;
  }
  e.prototype = t === null ? Object.create(t) : (n.prototype = t.prototype, new n());
}
function sf(e, t, n, r) {
  function s(a) {
    return a instanceof n ? a : new n(function(i) {
      i(a);
    });
  }
  return new (n || (n = Promise))(function(a, i) {
    function o(d) {
      try {
        u(r.next(d));
      } catch (h) {
        i(h);
      }
    }
    function c(d) {
      try {
        u(r.throw(d));
      } catch (h) {
        i(h);
      }
    }
    function u(d) {
      d.done ? a(d.value) : s(d.value).then(o, c);
    }
    u((r = r.apply(e, t || [])).next());
  });
}
function Ao(e, t) {
  var n = { label: 0, sent: function() {
    if (a[0] & 1)
      throw a[1];
    return a[1];
  }, trys: [], ops: [] }, r, s, a, i;
  return i = { next: o(0), throw: o(1), return: o(2) }, typeof Symbol == "function" && (i[Symbol.iterator] = function() {
    return this;
  }), i;
  function o(u) {
    return function(d) {
      return c([u, d]);
    };
  }
  function c(u) {
    if (r)
      throw new TypeError("Generator is already executing.");
    for (; i && (i = 0, u[0] && (n = 0)), n; )
      try {
        if (r = 1, s && (a = u[0] & 2 ? s.return : u[0] ? s.throw || ((a = s.return) && a.call(s), 0) : s.next) && !(a = a.call(s, u[1])).done)
          return a;
        switch (s = 0, a && (u = [u[0] & 2, a.value]), u[0]) {
          case 0:
          case 1:
            a = u;
            break;
          case 4:
            return n.label++, { value: u[1], done: false };
          case 5:
            n.label++, s = u[1], u = [0];
            continue;
          case 7:
            u = n.ops.pop(), n.trys.pop();
            continue;
          default:
            if (a = n.trys, !(a = a.length > 0 && a[a.length - 1]) && (u[0] === 6 || u[0] === 2)) {
              n = 0;
              continue;
            }
            if (u[0] === 3 && (!a || u[1] > a[0] && u[1] < a[3])) {
              n.label = u[1];
              break;
            }
            if (u[0] === 6 && n.label < a[1]) {
              n.label = a[1], a = u;
              break;
            }
            if (a && n.label < a[2]) {
              n.label = a[2], n.ops.push(u);
              break;
            }
            a[2] && n.ops.pop(), n.trys.pop();
            continue;
        }
        u = t.call(e, n);
      } catch (d) {
        u = [6, d], s = 0;
      } finally {
        r = a = 0;
      }
    if (u[0] & 5)
      throw u[1];
    return { value: u[0] ? u[1] : void 0, done: true };
  }
}
function yn(e) {
  var t = typeof Symbol == "function" && Symbol.iterator, n = t && e[t], r = 0;
  if (n)
    return n.call(e);
  if (e && typeof e.length == "number")
    return {
      next: function() {
        return e && r >= e.length && (e = void 0), { value: e && e[r++], done: !e };
      }
    };
  throw new TypeError(t ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function vn(e, t) {
  var n = typeof Symbol == "function" && e[Symbol.iterator];
  if (!n)
    return e;
  var r = n.call(e), s, a = [], i;
  try {
    for (; (t === void 0 || t-- > 0) && !(s = r.next()).done; )
      a.push(s.value);
  } catch (o) {
    i = { error: o };
  } finally {
    try {
      s && !s.done && (n = r.return) && n.call(r);
    } finally {
      if (i)
        throw i.error;
    }
  }
  return a;
}
function gn(e, t, n) {
  if (n || arguments.length === 2)
    for (var r = 0, s = t.length, a; r < s; r++)
      (a || !(r in t)) && (a || (a = Array.prototype.slice.call(t, 0, r)), a[r] = t[r]);
  return e.concat(a || Array.prototype.slice.call(t));
}
function un(e) {
  return this instanceof un ? (this.v = e, this) : new un(e);
}
function af(e, t, n) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var r = n.apply(e, t || []), s, a = [];
  return s = {}, i("next"), i("throw"), i("return"), s[Symbol.asyncIterator] = function() {
    return this;
  }, s;
  function i(p) {
    r[p] && (s[p] = function(b) {
      return new Promise(function(E, y) {
        a.push([p, b, E, y]) > 1 || o(p, b);
      });
    });
  }
  function o(p, b) {
    try {
      c(r[p](b));
    } catch (E) {
      h(a[0][3], E);
    }
  }
  function c(p) {
    p.value instanceof un ? Promise.resolve(p.value.v).then(u, d) : h(a[0][2], p);
  }
  function u(p) {
    o("next", p);
  }
  function d(p) {
    o("throw", p);
  }
  function h(p, b) {
    p(b), a.shift(), a.length && o(a[0][0], a[0][1]);
  }
}
function of(e) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var t = e[Symbol.asyncIterator], n;
  return t ? t.call(e) : (e = typeof yn == "function" ? yn(e) : e[Symbol.iterator](), n = {}, r("next"), r("throw"), r("return"), n[Symbol.asyncIterator] = function() {
    return this;
  }, n);
  function r(a) {
    n[a] = e[a] && function(i) {
      return new Promise(function(o, c) {
        i = e[a](i), s(o, c, i.done, i.value);
      });
    };
  }
  function s(a, i, o, c) {
    Promise.resolve(c).then(function(u) {
      a({ value: u, done: o });
    }, i);
  }
}
function oe(e) {
  return typeof e == "function";
}
function _a(e) {
  var t = function(r) {
    Error.call(r), r.stack = new Error().stack;
  }, n = e(t);
  return n.prototype = Object.create(Error.prototype), n.prototype.constructor = n, n;
}
var is = _a(function(e) {
  return function(t) {
    e(this), this.message = t ? t.length + ` errors occurred during unsubscription:
` + t.map(function(n, r) {
      return r + 1 + ") " + n.toString();
    }).join(`
  `) : "", this.name = "UnsubscriptionError", this.errors = t;
  };
});
function gr(e, t) {
  if (e) {
    var n = e.indexOf(t);
    0 <= n && e.splice(n, 1);
  }
}
var Pn = function() {
  function e(t) {
    this.initialTeardown = t, this.closed = false, this._parentage = null, this._finalizers = null;
  }
  return e.prototype.unsubscribe = function() {
    var t, n, r, s, a;
    if (!this.closed) {
      this.closed = true;
      var i = this._parentage;
      if (i)
        if (this._parentage = null, Array.isArray(i))
          try {
            for (var o = yn(i), c = o.next(); !c.done; c = o.next()) {
              var u = c.value;
              u.remove(this);
            }
          } catch (y) {
            t = { error: y };
          } finally {
            try {
              c && !c.done && (n = o.return) && n.call(o);
            } finally {
              if (t)
                throw t.error;
            }
          }
        else
          i.remove(this);
      var d = this.initialTeardown;
      if (oe(d))
        try {
          d();
        } catch (y) {
          a = y instanceof is ? y.errors : [y];
        }
      var h = this._finalizers;
      if (h) {
        this._finalizers = null;
        try {
          for (var p = yn(h), b = p.next(); !b.done; b = p.next()) {
            var E = b.value;
            try {
              Oi(E);
            } catch (y) {
              a = a ?? [], y instanceof is ? a = gn(gn([], vn(a)), vn(y.errors)) : a.push(y);
            }
          }
        } catch (y) {
          r = { error: y };
        } finally {
          try {
            b && !b.done && (s = p.return) && s.call(p);
          } finally {
            if (r)
              throw r.error;
          }
        }
      }
      if (a)
        throw new is(a);
    }
  }, e.prototype.add = function(t) {
    var n;
    if (t && t !== this)
      if (this.closed)
        Oi(t);
      else {
        if (t instanceof e) {
          if (t.closed || t._hasParent(this))
            return;
          t._addParent(this);
        }
        (this._finalizers = (n = this._finalizers) !== null && n !== void 0 ? n : []).push(t);
      }
  }, e.prototype._hasParent = function(t) {
    var n = this._parentage;
    return n === t || Array.isArray(n) && n.includes(t);
  }, e.prototype._addParent = function(t) {
    var n = this._parentage;
    this._parentage = Array.isArray(n) ? (n.push(t), n) : n ? [n, t] : t;
  }, e.prototype._removeParent = function(t) {
    var n = this._parentage;
    n === t ? this._parentage = null : Array.isArray(n) && gr(n, t);
  }, e.prototype.remove = function(t) {
    var n = this._finalizers;
    n && gr(n, t), t instanceof e && t._removeParent(this);
  }, e.EMPTY = function() {
    var t = new e();
    return t.closed = true, t;
  }(), e;
}();
var Io = Pn.EMPTY;
function No(e) {
  return e instanceof Pn || e && "closed" in e && oe(e.remove) && oe(e.add) && oe(e.unsubscribe);
}
function Oi(e) {
  oe(e) ? e() : e.unsubscribe();
}
var jo = {
  onUnhandledError: null,
  onStoppedNotification: null,
  Promise: void 0,
  useDeprecatedSynchronousErrorHandling: false,
  useDeprecatedNextContext: false
};
var uf = {
  setTimeout: function(e, t) {
    for (var n = [], r = 2; r < arguments.length; r++)
      n[r - 2] = arguments[r];
    return setTimeout.apply(void 0, gn([e, t], vn(n)));
  },
  clearTimeout: function(e) {
    return clearTimeout(e);
  },
  delegate: void 0
};
function Do(e) {
  uf.setTimeout(function() {
    throw e;
  });
}
function Zs() {
}
function ur(e) {
  e();
}
var ba = function(e) {
  Ot(t, e);
  function t(n) {
    var r = e.call(this) || this;
    return r.isStopped = false, n ? (r.destination = n, No(n) && n.add(r)) : r.destination = ff, r;
  }
  return t.create = function(n, r, s) {
    return new _n(n, r, s);
  }, t.prototype.next = function(n) {
    this.isStopped || this._next(n);
  }, t.prototype.error = function(n) {
    this.isStopped || (this.isStopped = true, this._error(n));
  }, t.prototype.complete = function() {
    this.isStopped || (this.isStopped = true, this._complete());
  }, t.prototype.unsubscribe = function() {
    this.closed || (this.isStopped = true, e.prototype.unsubscribe.call(this), this.destination = null);
  }, t.prototype._next = function(n) {
    this.destination.next(n);
  }, t.prototype._error = function(n) {
    try {
      this.destination.error(n);
    } finally {
      this.unsubscribe();
    }
  }, t.prototype._complete = function() {
    try {
      this.destination.complete();
    } finally {
      this.unsubscribe();
    }
  }, t;
}(Pn);
var cf = Function.prototype.bind;
function os(e, t) {
  return cf.call(e, t);
}
var lf = function() {
  function e(t) {
    this.partialObserver = t;
  }
  return e.prototype.next = function(t) {
    var n = this.partialObserver;
    if (n.next)
      try {
        n.next(t);
      } catch (r) {
        tr(r);
      }
  }, e.prototype.error = function(t) {
    var n = this.partialObserver;
    if (n.error)
      try {
        n.error(t);
      } catch (r) {
        tr(r);
      }
    else
      tr(t);
  }, e.prototype.complete = function() {
    var t = this.partialObserver;
    if (t.complete)
      try {
        t.complete();
      } catch (n) {
        tr(n);
      }
  }, e;
}();
var _n = function(e) {
  Ot(t, e);
  function t(n, r, s) {
    var a = e.call(this) || this, i;
    if (oe(n) || !n)
      i = {
        next: n ?? void 0,
        error: r ?? void 0,
        complete: s ?? void 0
      };
    else {
      var o;
      a && jo.useDeprecatedNextContext ? (o = Object.create(n), o.unsubscribe = function() {
        return a.unsubscribe();
      }, i = {
        next: n.next && os(n.next, o),
        error: n.error && os(n.error, o),
        complete: n.complete && os(n.complete, o)
      }) : i = n;
    }
    return a.destination = new lf(i), a;
  }
  return t;
}(ba);
function tr(e) {
  Do(e);
}
function df(e) {
  throw e;
}
var ff = {
  closed: true,
  next: Zs,
  error: df,
  complete: Zs
};
var wa = function() {
  return typeof Symbol == "function" && Symbol.observable || "@@observable";
}();
function Lr(e) {
  return e;
}
function hf(e) {
  return e.length === 0 ? Lr : e.length === 1 ? e[0] : function(t) {
    return e.reduce(function(n, r) {
      return r(n);
    }, t);
  };
}
var Oe = function() {
  function e(t) {
    t && (this._subscribe = t);
  }
  return e.prototype.lift = function(t) {
    var n = new e();
    return n.source = this, n.operator = t, n;
  }, e.prototype.subscribe = function(t, n, r) {
    var s = this, a = mf(t) ? t : new _n(t, n, r);
    return ur(function() {
      var i = s, o = i.operator, c = i.source;
      a.add(o ? o.call(a, c) : c ? s._subscribe(a) : s._trySubscribe(a));
    }), a;
  }, e.prototype._trySubscribe = function(t) {
    try {
      return this._subscribe(t);
    } catch (n) {
      t.error(n);
    }
  }, e.prototype.forEach = function(t, n) {
    var r = this;
    return n = Ei(n), new n(function(s, a) {
      var i = new _n({
        next: function(o) {
          try {
            t(o);
          } catch (c) {
            a(c), i.unsubscribe();
          }
        },
        error: a,
        complete: s
      });
      r.subscribe(i);
    });
  }, e.prototype._subscribe = function(t) {
    var n;
    return (n = this.source) === null || n === void 0 ? void 0 : n.subscribe(t);
  }, e.prototype[wa] = function() {
    return this;
  }, e.prototype.pipe = function() {
    for (var t = [], n = 0; n < arguments.length; n++)
      t[n] = arguments[n];
    return hf(t)(this);
  }, e.prototype.toPromise = function(t) {
    var n = this;
    return t = Ei(t), new t(function(r, s) {
      var a;
      n.subscribe(function(i) {
        return a = i;
      }, function(i) {
        return s(i);
      }, function() {
        return r(a);
      });
    });
  }, e.create = function(t) {
    return new e(t);
  }, e;
}();
function Ei(e) {
  var t;
  return (t = e ?? jo.Promise) !== null && t !== void 0 ? t : Promise;
}
function pf(e) {
  return e && oe(e.next) && oe(e.error) && oe(e.complete);
}
function mf(e) {
  return e && e instanceof ba || pf(e) && No(e);
}
function yf(e) {
  return oe(e == null ? void 0 : e.lift);
}
function Me(e) {
  return function(t) {
    if (yf(t))
      return t.lift(function(n) {
        try {
          return e(n, this);
        } catch (r) {
          this.error(r);
        }
      });
    throw new TypeError("Unable to lift unknown Observable type");
  };
}
function Ye(e, t, n, r, s) {
  return new vf(e, t, n, r, s);
}
var vf = function(e) {
  Ot(t, e);
  function t(n, r, s, a, i, o) {
    var c = e.call(this, n) || this;
    return c.onFinalize = i, c.shouldUnsubscribe = o, c._next = r ? function(u) {
      try {
        r(u);
      } catch (d) {
        n.error(d);
      }
    } : e.prototype._next, c._error = a ? function(u) {
      try {
        a(u);
      } catch (d) {
        n.error(d);
      } finally {
        this.unsubscribe();
      }
    } : e.prototype._error, c._complete = s ? function() {
      try {
        s();
      } catch (u) {
        n.error(u);
      } finally {
        this.unsubscribe();
      }
    } : e.prototype._complete, c;
  }
  return t.prototype.unsubscribe = function() {
    var n;
    if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) {
      var r = this.closed;
      e.prototype.unsubscribe.call(this), !r && ((n = this.onFinalize) === null || n === void 0 || n.call(this));
    }
  }, t;
}(ba);
var gf = _a(function(e) {
  return function() {
    e(this), this.name = "ObjectUnsubscribedError", this.message = "object unsubscribed";
  };
});
var zt = function(e) {
  Ot(t, e);
  function t() {
    var n = e.call(this) || this;
    return n.closed = false, n.currentObservers = null, n.observers = [], n.isStopped = false, n.hasError = false, n.thrownError = null, n;
  }
  return t.prototype.lift = function(n) {
    var r = new Ci(this, this);
    return r.operator = n, r;
  }, t.prototype._throwIfClosed = function() {
    if (this.closed)
      throw new gf();
  }, t.prototype.next = function(n) {
    var r = this;
    ur(function() {
      var s, a;
      if (r._throwIfClosed(), !r.isStopped) {
        r.currentObservers || (r.currentObservers = Array.from(r.observers));
        try {
          for (var i = yn(r.currentObservers), o = i.next(); !o.done; o = i.next()) {
            var c = o.value;
            c.next(n);
          }
        } catch (u) {
          s = { error: u };
        } finally {
          try {
            o && !o.done && (a = i.return) && a.call(i);
          } finally {
            if (s)
              throw s.error;
          }
        }
      }
    });
  }, t.prototype.error = function(n) {
    var r = this;
    ur(function() {
      if (r._throwIfClosed(), !r.isStopped) {
        r.hasError = r.isStopped = true, r.thrownError = n;
        for (var s = r.observers; s.length; )
          s.shift().error(n);
      }
    });
  }, t.prototype.complete = function() {
    var n = this;
    ur(function() {
      if (n._throwIfClosed(), !n.isStopped) {
        n.isStopped = true;
        for (var r = n.observers; r.length; )
          r.shift().complete();
      }
    });
  }, t.prototype.unsubscribe = function() {
    this.isStopped = this.closed = true, this.observers = this.currentObservers = null;
  }, Object.defineProperty(t.prototype, "observed", {
    get: function() {
      var n;
      return ((n = this.observers) === null || n === void 0 ? void 0 : n.length) > 0;
    },
    enumerable: false,
    configurable: true
  }), t.prototype._trySubscribe = function(n) {
    return this._throwIfClosed(), e.prototype._trySubscribe.call(this, n);
  }, t.prototype._subscribe = function(n) {
    return this._throwIfClosed(), this._checkFinalizedStatuses(n), this._innerSubscribe(n);
  }, t.prototype._innerSubscribe = function(n) {
    var r = this, s = this, a = s.hasError, i = s.isStopped, o = s.observers;
    return a || i ? Io : (this.currentObservers = null, o.push(n), new Pn(function() {
      r.currentObservers = null, gr(o, n);
    }));
  }, t.prototype._checkFinalizedStatuses = function(n) {
    var r = this, s = r.hasError, a = r.thrownError, i = r.isStopped;
    s ? n.error(a) : i && n.complete();
  }, t.prototype.asObservable = function() {
    var n = new Oe();
    return n.source = this, n;
  }, t.create = function(n, r) {
    return new Ci(n, r);
  }, t;
}(Oe);
var Ci = function(e) {
  Ot(t, e);
  function t(n, r) {
    var s = e.call(this) || this;
    return s.destination = n, s.source = r, s;
  }
  return t.prototype.next = function(n) {
    var r, s;
    (s = (r = this.destination) === null || r === void 0 ? void 0 : r.next) === null || s === void 0 || s.call(r, n);
  }, t.prototype.error = function(n) {
    var r, s;
    (s = (r = this.destination) === null || r === void 0 ? void 0 : r.error) === null || s === void 0 || s.call(r, n);
  }, t.prototype.complete = function() {
    var n, r;
    (r = (n = this.destination) === null || n === void 0 ? void 0 : n.complete) === null || r === void 0 || r.call(n);
  }, t.prototype._subscribe = function(n) {
    var r, s;
    return (s = (r = this.source) === null || r === void 0 ? void 0 : r.subscribe(n)) !== null && s !== void 0 ? s : Io;
  }, t;
}(zt);
var _f = {
  now: function() {
    return Date.now();
  },
  delegate: void 0
};
var bf = function(e) {
  Ot(t, e);
  function t(n, r) {
    return e.call(this) || this;
  }
  return t.prototype.schedule = function(n, r) {
    return this;
  }, t;
}(Pn);
var Ms = {
  setInterval: function(e, t) {
    for (var n = [], r = 2; r < arguments.length; r++)
      n[r - 2] = arguments[r];
    var s = Ms.delegate;
    return s != null && s.setInterval ? s.setInterval.apply(s, gn([e, t], vn(n))) : setInterval.apply(void 0, gn([e, t], vn(n)));
  },
  clearInterval: function(e) {
    return clearInterval(e);
  },
  delegate: void 0
};
var wf = function(e) {
  Ot(t, e);
  function t(n, r) {
    var s = e.call(this, n, r) || this;
    return s.scheduler = n, s.work = r, s.pending = false, s;
  }
  return t.prototype.schedule = function(n, r) {
    var s;
    if (r === void 0 && (r = 0), this.closed)
      return this;
    this.state = n;
    var a = this.id, i = this.scheduler;
    return a != null && (this.id = this.recycleAsyncId(i, a, r)), this.pending = true, this.delay = r, this.id = (s = this.id) !== null && s !== void 0 ? s : this.requestAsyncId(i, this.id, r), this;
  }, t.prototype.requestAsyncId = function(n, r, s) {
    return s === void 0 && (s = 0), Ms.setInterval(n.flush.bind(n, this), s);
  }, t.prototype.recycleAsyncId = function(n, r, s) {
    if (s === void 0 && (s = 0), s != null && this.delay === s && this.pending === false)
      return r;
    r != null && Ms.clearInterval(r);
  }, t.prototype.execute = function(n, r) {
    if (this.closed)
      return new Error("executing a cancelled action");
    this.pending = false;
    var s = this._execute(n, r);
    if (s)
      return s;
    this.pending === false && this.id != null && (this.id = this.recycleAsyncId(this.scheduler, this.id, null));
  }, t.prototype._execute = function(n, r) {
    var s = false, a;
    try {
      this.work(n);
    } catch (i) {
      s = true, a = i || new Error("Scheduled action threw falsy error");
    }
    if (s)
      return this.unsubscribe(), a;
  }, t.prototype.unsubscribe = function() {
    if (!this.closed) {
      var n = this, r = n.id, s = n.scheduler, a = s.actions;
      this.work = this.state = this.scheduler = null, this.pending = false, gr(a, this), r != null && (this.id = this.recycleAsyncId(s, r, null)), this.delay = null, e.prototype.unsubscribe.call(this);
    }
  }, t;
}(bf);
var Ri = function() {
  function e(t, n) {
    n === void 0 && (n = e.now), this.schedulerActionCtor = t, this.now = n;
  }
  return e.prototype.schedule = function(t, n, r) {
    return n === void 0 && (n = 0), new this.schedulerActionCtor(this, t).schedule(r, n);
  }, e.now = _f.now, e;
}();
var xf = function(e) {
  Ot(t, e);
  function t(n, r) {
    r === void 0 && (r = Ri.now);
    var s = e.call(this, n, r) || this;
    return s.actions = [], s._active = false, s;
  }
  return t.prototype.flush = function(n) {
    var r = this.actions;
    if (this._active) {
      r.push(n);
      return;
    }
    var s;
    this._active = true;
    do
      if (s = n.execute(n.state, n.delay))
        break;
    while (n = r.shift());
    if (this._active = false, s) {
      for (; n = r.shift(); )
        n.unsubscribe();
      throw s;
    }
  }, t;
}(Ri);
var kf = new xf(wf);
var Sf = kf;
var qo = new Oe(function(e) {
  return e.complete();
});
function $o(e) {
  return e && oe(e.schedule);
}
function Lo(e) {
  return e[e.length - 1];
}
function Zo(e) {
  return $o(Lo(e)) ? e.pop() : void 0;
}
function Tf(e, t) {
  return typeof Lo(e) == "number" ? e.pop() : t;
}
var Mo = function(e) {
  return e && typeof e.length == "number" && typeof e != "function";
};
function Fo(e) {
  return oe(e == null ? void 0 : e.then);
}
function zo(e) {
  return oe(e[wa]);
}
function Uo(e) {
  return Symbol.asyncIterator && oe(e == null ? void 0 : e[Symbol.asyncIterator]);
}
function Vo(e) {
  return new TypeError("You provided " + (e !== null && typeof e == "object" ? "an invalid object" : "'" + e + "'") + " where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.");
}
function Pf() {
  return typeof Symbol != "function" || !Symbol.iterator ? "@@iterator" : Symbol.iterator;
}
var Bo = Pf();
function Wo(e) {
  return oe(e == null ? void 0 : e[Bo]);
}
function Ko(e) {
  return af(this, arguments, function() {
    var t, n, r, s;
    return Ao(this, function(a) {
      switch (a.label) {
        case 0:
          t = e.getReader(), a.label = 1;
        case 1:
          a.trys.push([1, , 9, 10]), a.label = 2;
        case 2:
          return [4, un(t.read())];
        case 3:
          return n = a.sent(), r = n.value, s = n.done, s ? [4, un(void 0)] : [3, 5];
        case 4:
          return [2, a.sent()];
        case 5:
          return [4, un(r)];
        case 6:
          return [4, a.sent()];
        case 7:
          return a.sent(), [3, 2];
        case 8:
          return [3, 10];
        case 9:
          return t.releaseLock(), [7];
        case 10:
          return [2];
      }
    });
  });
}
function Go(e) {
  return oe(e == null ? void 0 : e.getReader);
}
function ft(e) {
  if (e instanceof Oe)
    return e;
  if (e != null) {
    if (zo(e))
      return Of(e);
    if (Mo(e))
      return Ef(e);
    if (Fo(e))
      return Cf(e);
    if (Uo(e))
      return Ho(e);
    if (Wo(e))
      return Rf(e);
    if (Go(e))
      return Af(e);
  }
  throw Vo(e);
}
function Of(e) {
  return new Oe(function(t) {
    var n = e[wa]();
    if (oe(n.subscribe))
      return n.subscribe(t);
    throw new TypeError("Provided object does not correctly implement Symbol.observable");
  });
}
function Ef(e) {
  return new Oe(function(t) {
    for (var n = 0; n < e.length && !t.closed; n++)
      t.next(e[n]);
    t.complete();
  });
}
function Cf(e) {
  return new Oe(function(t) {
    e.then(function(n) {
      t.closed || (t.next(n), t.complete());
    }, function(n) {
      return t.error(n);
    }).then(null, Do);
  });
}
function Rf(e) {
  return new Oe(function(t) {
    var n, r;
    try {
      for (var s = yn(e), a = s.next(); !a.done; a = s.next()) {
        var i = a.value;
        if (t.next(i), t.closed)
          return;
      }
    } catch (o) {
      n = { error: o };
    } finally {
      try {
        a && !a.done && (r = s.return) && r.call(s);
      } finally {
        if (n)
          throw n.error;
      }
    }
    t.complete();
  });
}
function Ho(e) {
  return new Oe(function(t) {
    If(e, t).catch(function(n) {
      return t.error(n);
    });
  });
}
function Af(e) {
  return Ho(Ko(e));
}
function If(e, t) {
  var n, r, s, a;
  return sf(this, void 0, void 0, function() {
    var i, o;
    return Ao(this, function(c) {
      switch (c.label) {
        case 0:
          c.trys.push([0, 5, 6, 11]), n = of(e), c.label = 1;
        case 1:
          return [4, n.next()];
        case 2:
          if (r = c.sent(), !!r.done)
            return [3, 4];
          if (i = r.value, t.next(i), t.closed)
            return [2];
          c.label = 3;
        case 3:
          return [3, 1];
        case 4:
          return [3, 11];
        case 5:
          return o = c.sent(), s = { error: o }, [3, 11];
        case 6:
          return c.trys.push([6, , 9, 10]), r && !r.done && (a = n.return) ? [4, a.call(n)] : [3, 8];
        case 7:
          c.sent(), c.label = 8;
        case 8:
          return [3, 10];
        case 9:
          if (s)
            throw s.error;
          return [7];
        case 10:
          return [7];
        case 11:
          return t.complete(), [2];
      }
    });
  });
}
function _t(e, t, n, r, s) {
  r === void 0 && (r = 0), s === void 0 && (s = false);
  var a = t.schedule(function() {
    n(), s ? e.add(this.schedule(null, r)) : this.unsubscribe();
  }, r);
  if (e.add(a), !s)
    return a;
}
function Jo(e, t) {
  return t === void 0 && (t = 0), Me(function(n, r) {
    n.subscribe(Ye(r, function(s) {
      return _t(r, e, function() {
        return r.next(s);
      }, t);
    }, function() {
      return _t(r, e, function() {
        return r.complete();
      }, t);
    }, function(s) {
      return _t(r, e, function() {
        return r.error(s);
      }, t);
    }));
  });
}
function Yo(e, t) {
  return t === void 0 && (t = 0), Me(function(n, r) {
    r.add(e.schedule(function() {
      return n.subscribe(r);
    }, t));
  });
}
function Nf(e, t) {
  return ft(e).pipe(Yo(t), Jo(t));
}
function jf(e, t) {
  return ft(e).pipe(Yo(t), Jo(t));
}
function Df(e, t) {
  return new Oe(function(n) {
    var r = 0;
    return t.schedule(function() {
      r === e.length ? n.complete() : (n.next(e[r++]), n.closed || this.schedule());
    });
  });
}
function qf(e, t) {
  return new Oe(function(n) {
    var r;
    return _t(n, t, function() {
      r = e[Bo](), _t(n, t, function() {
        var s, a, i;
        try {
          s = r.next(), a = s.value, i = s.done;
        } catch (o) {
          n.error(o);
          return;
        }
        i ? n.complete() : n.next(a);
      }, 0, true);
    }), function() {
      return oe(r == null ? void 0 : r.return) && r.return();
    };
  });
}
function Xo(e, t) {
  if (!e)
    throw new Error("Iterable cannot be null");
  return new Oe(function(n) {
    _t(n, t, function() {
      var r = e[Symbol.asyncIterator]();
      _t(n, t, function() {
        r.next().then(function(s) {
          s.done ? n.complete() : n.next(s.value);
        });
      }, 0, true);
    });
  });
}
function $f(e, t) {
  return Xo(Ko(e), t);
}
function Lf(e, t) {
  if (e != null) {
    if (zo(e))
      return Nf(e, t);
    if (Mo(e))
      return Df(e, t);
    if (Fo(e))
      return jf(e, t);
    if (Uo(e))
      return Xo(e, t);
    if (Wo(e))
      return qf(e, t);
    if (Go(e))
      return $f(e, t);
  }
  throw Vo(e);
}
function Qo(e, t) {
  return t ? Lf(e, t) : ft(e);
}
function Zf() {
  for (var e = [], t = 0; t < arguments.length; t++)
    e[t] = arguments[t];
  var n = Zo(e);
  return Qo(e, n);
}
var xa = _a(function(e) {
  return function() {
    e(this), this.name = "EmptyError", this.message = "no elements in sequence";
  };
});
function eu(e, t) {
  var n = typeof t == "object";
  return new Promise(function(r, s) {
    var a = new _n({
      next: function(i) {
        r(i), a.unsubscribe();
      },
      error: s,
      complete: function() {
        n ? r(t.defaultValue) : s(new xa());
      }
    });
    e.subscribe(a);
  });
}
function Mf(e) {
  return e instanceof Date && !isNaN(e);
}
function tn(e, t) {
  return Me(function(n, r) {
    var s = 0;
    n.subscribe(Ye(r, function(a) {
      r.next(e.call(t, a, s++));
    }));
  });
}
function Ff(e, t, n, r, s, a, i, o) {
  var c = [], u = 0, d = 0, h = false, p = function() {
    h && !c.length && !u && t.complete();
  }, b = function(y) {
    return u < r ? E(y) : c.push(y);
  }, E = function(y) {
    a && t.next(y), u++;
    var A = false;
    ft(n(y, d++)).subscribe(Ye(t, function(O) {
      s == null || s(O), a ? b(O) : t.next(O);
    }, function() {
      A = true;
    }, void 0, function() {
      if (A)
        try {
          u--;
          for (var O = function() {
            var I = c.shift();
            i ? _t(t, i, function() {
              return E(I);
            }) : E(I);
          }; c.length && u < r; )
            O();
          p();
        } catch (I) {
          t.error(I);
        }
    }));
  };
  return e.subscribe(Ye(t, b, function() {
    h = true, p();
  })), function() {
    o == null || o();
  };
}
function tu(e, t, n) {
  return n === void 0 && (n = 1 / 0), oe(t) ? tu(function(r, s) {
    return tn(function(a, i) {
      return t(r, a, s, i);
    })(ft(e(r, s)));
  }, n) : (typeof t == "number" && (n = t), Me(function(r, s) {
    return Ff(r, s, e, n);
  }));
}
function zf(e) {
  return e === void 0 && (e = 1 / 0), tu(Lr, e);
}
function Uf(e, t, n) {
  e === void 0 && (e = 0), n === void 0 && (n = Sf);
  var r = -1;
  return t != null && ($o(t) ? n = t : r = t), new Oe(function(s) {
    var a = Mf(e) ? +e - n.now() : e;
    a < 0 && (a = 0);
    var i = 0;
    return n.schedule(function() {
      s.closed || (s.next(i++), 0 <= r ? this.schedule(void 0, r) : s.complete());
    }, a);
  });
}
function nr() {
  for (var e = [], t = 0; t < arguments.length; t++)
    e[t] = arguments[t];
  var n = Zo(e), r = Tf(e, 1 / 0), s = e;
  return s.length ? s.length === 1 ? ft(s[0]) : zf(r)(Qo(s, n)) : qo;
}
function nn(e, t) {
  return Me(function(n, r) {
    var s = 0;
    n.subscribe(Ye(r, function(a) {
      return e.call(t, a, s++) && r.next(a);
    }));
  });
}
function Vf(e) {
  return Me(function(t, n) {
    var r = false;
    t.subscribe(Ye(n, function(s) {
      r = true, n.next(s);
    }, function() {
      r || n.next(e), n.complete();
    }));
  });
}
function Bf(e) {
  return e <= 0 ? function() {
    return qo;
  } : Me(function(t, n) {
    var r = 0;
    t.subscribe(Ye(n, function(s) {
      ++r <= e && (n.next(s), e <= r && n.complete());
    }));
  });
}
function Wf(e) {
  return e === void 0 && (e = Kf), Me(function(t, n) {
    var r = false;
    t.subscribe(Ye(n, function(s) {
      r = true, n.next(s);
    }, function() {
      return r ? n.complete() : n.error(e());
    }));
  });
}
function Kf() {
  return new xa();
}
function Ai(e, t) {
  var n = arguments.length >= 2;
  return function(r) {
    return r.pipe(e ? nn(function(s, a) {
      return e(s, a, r);
    }) : Lr, Bf(1), n ? Vf(t) : Wf(function() {
      return new xa();
    }));
  };
}
function Gf(e) {
  e === void 0 && (e = {});
  var t = e.connector, n = t === void 0 ? function() {
    return new zt();
  } : t, r = e.resetOnError, s = r === void 0 ? true : r, a = e.resetOnComplete, i = a === void 0 ? true : a, o = e.resetOnRefCountZero, c = o === void 0 ? true : o;
  return function(u) {
    var d, h, p, b = 0, E = false, y = false, A = function() {
      h == null || h.unsubscribe(), h = void 0;
    }, O = function() {
      A(), d = p = void 0, E = y = false;
    }, I = function() {
      var X = d;
      O(), X == null || X.unsubscribe();
    };
    return Me(function(X, F) {
      b++, !y && !E && A();
      var ue = p = p ?? n();
      F.add(function() {
        b--, b === 0 && !y && !E && (h = us(I, c));
      }), ue.subscribe(F), !d && b > 0 && (d = new _n({
        next: function(G) {
          return ue.next(G);
        },
        error: function(G) {
          y = true, A(), h = us(O, s, G), ue.error(G);
        },
        complete: function() {
          E = true, A(), h = us(O, i), ue.complete();
        }
      }), ft(X).subscribe(d));
    })(u);
  };
}
function us(e, t) {
  for (var n = [], r = 2; r < arguments.length; r++)
    n[r - 2] = arguments[r];
  if (t === true) {
    e();
    return;
  }
  if (t !== false) {
    var s = new _n({
      next: function() {
        s.unsubscribe(), e();
      }
    });
    return ft(t.apply(void 0, gn([], vn(n)))).subscribe(s);
  }
}
function Hf(e) {
  return Me(function(t, n) {
    ft(e).subscribe(Ye(n, function() {
      return n.complete();
    }, Zs)), !n.closed && t.subscribe(n);
  });
}
function An(e, t, n) {
  var r = oe(e) || t || n ? { next: e, error: t, complete: n } : e;
  return r ? Me(function(s, a) {
    var i;
    (i = r.subscribe) === null || i === void 0 || i.call(r);
    var o = true;
    s.subscribe(Ye(a, function(c) {
      var u;
      (u = r.next) === null || u === void 0 || u.call(r, c), a.next(c);
    }, function() {
      var c;
      o = false, (c = r.complete) === null || c === void 0 || c.call(r), a.complete();
    }, function(c) {
      var u;
      o = false, (u = r.error) === null || u === void 0 || u.call(r, c), a.error(c);
    }, function() {
      var c, u;
      o && ((c = r.unsubscribe) === null || c === void 0 || c.call(r)), (u = r.finalize) === null || u === void 0 || u.call(r);
    }));
  }) : Lr;
}
var Jf = () => ({
  outgoingMessageSubject: new zt(),
  incomingMessageSubject: new zt(),
  responseSubject: new zt(),
  messageLifeCycleEventSubject: new zt()
});
var Yf = (e) => nt.fromPromise(eu(e), tf).andThen(
  (t) => t
);
var Xf = {
  extensionDetectionTime: 100
};
var Qf = (e) => {
  const t = e == null ? void 0 : e.logger, n = (e == null ? void 0 : e.subjects) ?? Jf(), r = new Pn();
  r.add(
    n.incomingMessageSubject.pipe(
      An((a) => {
        "eventType" in a ? (t == null || t.debug(" messageLifecycleEvent", a), n.messageLifeCycleEventSubject.next(a)) : (t == null || t.debug(" walletResponse", a), n.responseSubject.next(a));
      })
    ).subscribe()
  ), r.add(
    n.outgoingMessageSubject.pipe(
      An((a) => {
        t == null || t.debug(" walletRequest", a), window.dispatchEvent(
          new CustomEvent(as.outgoingMessage, {
            detail: a
          })
        );
      })
    ).subscribe()
  );
  const s = (a) => {
    const i = a.detail;
    n.incomingMessageSubject.next(i);
  };
  return addEventListener(as.incomingMessage, s), {
    send: (a, i) => {
      const o = new zt(), c = n.responseSubject.pipe(
        nn(
          (O) => O.interactionId === a.interactionId
        ),
        tn(
          (O) => O.discriminator === "success" ? We(O) : je(O)
        )
      ), u = n.messageLifeCycleEventSubject.pipe(
        nn(
          ({ interactionId: O, eventType: I }) => a.interactionId === O && ["requestCancelSuccess", "requestCancelFail"].includes(I)
        ),
        tn((O) => {
          const I = mn("canceledByUser", O.interactionId);
          return t == null || t.debug(" walletRequestCanceled", I), o.next(je(I)), O;
        })
      ), d = () => (n.outgoingMessageSubject.next({
        interactionId: a.interactionId,
        items: { discriminator: "cancelRequest" },
        metadata: a.metadata
      }), nt.fromSafePromise(
        eu(
          nr(
            c.pipe(tn(() => "requestCancelFail")),
            u.pipe(tn(({ eventType: O }) => O))
          )
        )
      ));
      i.requestControl && i.requestControl({
        cancelRequest: () => d().andThen(
          (O) => O === "requestCancelSuccess" ? We("requestCancelSuccess") : je("requestCancelFail")
        ),
        getRequest: () => a
      });
      const h = nr(
        c,
        o
      ).pipe(Ai()), p = n.messageLifeCycleEventSubject.pipe(
        nn(
          ({ interactionId: O }) => a.interactionId === O
        ),
        An((O) => {
          i.eventCallback && i.eventCallback(O.eventType);
        }),
        Hf(c),
        Gf()
      ), b = p.subscribe(), E = Uf(Xf.extensionDetectionTime).pipe(
        tn(
          () => je(mn("missingExtension", a.interactionId))
        )
      ), y = nr(
        E,
        p
      ).pipe(
        Ai(),
        nn((O) => !("eventType" in O))
      ), A = Zf(a).pipe(
        An((O) => {
          n.outgoingMessageSubject.next(O);
        }),
        nn((O) => false)
      );
      return Yf(
        nr(
          h,
          y,
          A
        ).pipe(
          An(() => {
            b.unsubscribe();
          })
        )
      );
    },
    destroy: () => {
      r.unsubscribe(), removeEventListener(as.incomingMessage, s);
    }
  };
};
var Fs = {
  reset: [0, 0],
  bold: [1, 22],
  dim: [2, 22],
  italic: [3, 23],
  underline: [4, 24],
  overline: [53, 55],
  inverse: [7, 27],
  hidden: [8, 28],
  strikethrough: [9, 29],
  black: [30, 39],
  red: [31, 39],
  green: [32, 39],
  yellow: [33, 39],
  blue: [34, 39],
  magenta: [35, 39],
  cyan: [36, 39],
  white: [37, 39],
  blackBright: [90, 39],
  redBright: [91, 39],
  greenBright: [92, 39],
  yellowBright: [93, 39],
  blueBright: [94, 39],
  magentaBright: [95, 39],
  cyanBright: [96, 39],
  whiteBright: [97, 39],
  bgBlack: [40, 49],
  bgRed: [41, 49],
  bgGreen: [42, 49],
  bgYellow: [43, 49],
  bgBlue: [44, 49],
  bgMagenta: [45, 49],
  bgCyan: [46, 49],
  bgWhite: [47, 49],
  bgBlackBright: [100, 49],
  bgRedBright: [101, 49],
  bgGreenBright: [102, 49],
  bgYellowBright: [103, 49],
  bgBlueBright: [104, 49],
  bgMagentaBright: [105, 49],
  bgCyanBright: [106, 49],
  bgWhiteBright: [107, 49]
};
function zs(e, t, n, r = false) {
  const s = String(t), a = (o, c) => `\x1B[${c[0]}m${o}\x1B[${c[1]}m`, i = (o, c) => c != null && typeof c == "string" ? a(o, Fs[c]) : c != null && Array.isArray(c) ? c.reduce((u, d) => i(u, d), o) : c != null && c[o.trim()] != null ? i(o, c[o.trim()]) : c != null && c["*"] != null ? i(o, c["*"]) : o;
  return s.replace(/{{(.+?)}}/g, (o, c) => {
    var u;
    const d = n[c] != null ? n[c] : r ? "" : o;
    return e.stylePrettyLogs ? i(d, (u = e == null ? void 0 : e.prettyLogStyles) == null ? void 0 : u[c]) + a("", Fs.reset) : d;
  });
}
function nu(e) {
  const t = /* @__PURE__ */ new Set();
  return JSON.stringify(e, (n, r) => {
    if (typeof r == "object" && r !== null) {
      if (t.has(r))
        return "[Circular]";
      t.add(r);
    }
    return r;
  });
}
function be(e, t) {
  const n = {
    seen: [],
    stylize: ru
  };
  return t != null && ou(n, t), sn(n.showHidden) && (n.showHidden = false), sn(n.depth) && (n.depth = 2), sn(n.colors) && (n.colors = true), sn(n.customInspect) && (n.customInspect = true), n.colors && (n.stylize = th), _r(n, e, n.depth);
}
be.colors = Fs;
be.styles = {
  special: "cyan",
  number: "yellow",
  boolean: "yellow",
  undefined: "grey",
  null: "bold",
  string: "green",
  date: "magenta",
  regexp: "red"
};
function eh(e) {
  return typeof e == "boolean";
}
function sn(e) {
  return e == null;
}
function ru(e) {
  return e;
}
function th(e, t) {
  var n, r, s, a;
  const i = be.styles[t];
  return i != null && ((r = (n = be == null ? void 0 : be.colors) == null ? void 0 : n[i]) == null ? void 0 : r[0]) != null && ((a = (s = be == null ? void 0 : be.colors) == null ? void 0 : s[i]) == null ? void 0 : a[1]) != null ? "\x1B[" + be.colors[i][0] + "m" + e + "\x1B[" + be.colors[i][1] + "m" : e;
}
function rr(e) {
  return typeof e == "function";
}
function su(e) {
  return typeof e == "string";
}
function nh(e) {
  return typeof e == "number";
}
function au(e) {
  return e === null;
}
function iu(e, t) {
  return Object.prototype.hasOwnProperty.call(e, t);
}
function cs(e) {
  return Zr(e) && ka(e) === "[object RegExp]";
}
function Zr(e) {
  return typeof e == "object" && e !== null;
}
function ls(e) {
  return Zr(e) && (ka(e) === "[object Error]" || e instanceof Error);
}
function Ii(e) {
  return Zr(e) && ka(e) === "[object Date]";
}
function ka(e) {
  return Object.prototype.toString.call(e);
}
function rh(e) {
  const t = {};
  return e.forEach((n) => {
    t[n] = true;
  }), t;
}
function sh(e, t, n, r, s) {
  const a = [];
  for (let i = 0, o = t.length; i < o; ++i)
    iu(t, String(i)) ? a.push(Us(e, t, n, r, String(i), true)) : a.push("");
  return s.forEach((i) => {
    i.match(/^\d+$/) || a.push(Us(e, t, n, r, i, true));
  }), a;
}
function ds(e) {
  return "[" + Error.prototype.toString.call(e) + "]";
}
function _r(e, t, n = 0) {
  if (e.customInspect && t != null && rr(t) && (t == null ? void 0 : t.inspect) !== be && !(t != null && t.constructor && (t == null ? void 0 : t.constructor.prototype) === t)) {
    if (typeof t.inspect != "function" && t.toString != null)
      return t.toString();
    let d = t == null ? void 0 : t.inspect(n, e);
    return su(d) || (d = _r(e, d, n)), d;
  }
  const r = Dt(e, t);
  if (r)
    return r;
  let s = Object.keys(t);
  const a = rh(s);
  try {
    e.showHidden && Object.getOwnPropertyNames && (s = Object.getOwnPropertyNames(t));
  } catch {
  }
  if (ls(t) && (s.indexOf("message") >= 0 || s.indexOf("description") >= 0))
    return ds(t);
  if (s.length === 0)
    if (rr(e.stylize)) {
      if (rr(t)) {
        const d = t.name ? ": " + t.name : "";
        return e.stylize("[Function" + d + "]", "special");
      }
      if (cs(t))
        return e.stylize(RegExp.prototype.toString.call(t), "regexp");
      if (Ii(t))
        return e.stylize(Date.prototype.toString.call(t), "date");
      if (ls(t))
        return ds(t);
    } else
      return t;
  let i = "", o = false, c = [`{
`, `
}`];
  if (Array.isArray(t) && (o = true, c = [`[
`, `
]`]), rr(t) && (i = " [Function" + (t.name ? ": " + t.name : "") + "]"), cs(t) && (i = " " + RegExp.prototype.toString.call(t)), Ii(t) && (i = " " + Date.prototype.toUTCString.call(t)), ls(t) && (i = " " + ds(t)), s.length === 0 && (!o || t.length == 0))
    return c[0] + i + c[1];
  if (n < 0)
    return cs(t) ? e.stylize(RegExp.prototype.toString.call(t), "regexp") : e.stylize("[Object]", "special");
  e.seen.push(t);
  let u;
  return o ? u = sh(e, t, n, a, s) : u = s.map((d) => Us(e, t, n, a, d, o)), e.seen.pop(), ah(u, i, c);
}
function Us(e, t, n, r, s, a) {
  let i, o, c;
  c = { value: void 0 };
  try {
    c.value = t[s];
  } catch {
  }
  try {
    Object.getOwnPropertyDescriptor && (c = Object.getOwnPropertyDescriptor(t, s) || c);
  } catch {
  }
  if (c.get ? c.set ? o = e.stylize("[Getter/Setter]", "special") : o = e.stylize("[Getter]", "special") : c.set && (o = e.stylize("[Setter]", "special")), iu(r, s) || (i = "[" + s + "]"), o || (e.seen.indexOf(c.value) < 0 ? (au(n) ? o = _r(e, c.value, void 0) : o = _r(e, c.value, n - 1), o.indexOf(`
`) > -1 && (a ? o = o.split(`
`).map((u) => "  " + u).join(`
`).substr(2) : o = `
` + o.split(`
`).map((u) => "   " + u).join(`
`))) : o = e.stylize("[Circular]", "special")), sn(i)) {
    if (a && s.match(/^\d+$/))
      return o;
    i = JSON.stringify("" + s), i.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (i = i.substr(1, i.length - 2), i = e.stylize(i, "name")) : (i = i.replace(/'/g, "\\'").replace(/\\"/g, "\\'").replace(/(^"|"$)/g, "'"), i = e.stylize(i, "string"));
  }
  return i + ": " + o;
}
function Dt(e, t) {
  if (sn(t))
    return e.stylize("undefined", "undefined");
  if (su(t)) {
    const n = "'" + JSON.stringify(t).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, "\\'") + "'";
    return e.stylize(n, "string");
  }
  if (nh(t))
    return e.stylize("" + t, "number");
  if (eh(t))
    return e.stylize("" + t, "boolean");
  if (au(t))
    return e.stylize("null", "null");
}
function ah(e, t, n) {
  return n[0] + (t === "" ? "" : t + `
`) + "  " + e.join(`,
  `) + " " + n[1];
}
function ou(e, t) {
  if (!t || !Zr(t))
    return e;
  const n = Object.keys(t);
  let r = n.length;
  for (; r--; )
    e[n[r]] = t[n[r]];
  return e;
}
function ih(e, ...t) {
  const n = {
    seen: [],
    stylize: ru
  };
  e != null && ou(n, e);
  const r = t[0];
  let s = 0, a = "", i = "";
  if (typeof r == "string") {
    if (t.length === 1)
      return r;
    let o, c = 0;
    for (let u = 0; u < r.length - 1; u++)
      if (r.charCodeAt(u) === 37) {
        const d = r.charCodeAt(++u);
        if (s + 1 !== t.length) {
          switch (d) {
            case 115: {
              const h = t[++s];
              typeof h == "number" || typeof h == "bigint" ? o = Dt(n, h) : typeof h != "object" || h === null ? o = String(h) : o = be(h, {
                ...e,
                compact: 3,
                colors: false,
                depth: 0
              });
              break;
            }
            case 106:
              o = nu(t[++s]);
              break;
            case 100: {
              const h = t[++s];
              typeof h == "bigint" ? o = Dt(n, h) : typeof h == "symbol" ? o = "NaN" : o = Dt(n, h);
              break;
            }
            case 79:
              o = be(t[++s], e);
              break;
            case 111:
              o = be(t[++s], {
                ...e,
                showHidden: true,
                showProxy: true,
                depth: 4
              });
              break;
            case 105: {
              const h = t[++s];
              typeof h == "bigint" ? o = Dt(n, h) : typeof h == "symbol" ? o = "NaN" : o = Dt(n, parseInt(o));
              break;
            }
            case 102: {
              const h = t[++s];
              typeof h == "symbol" ? o = "NaN" : o = Dt(n, parseInt(h));
              break;
            }
            case 99:
              s += 1, o = "";
              break;
            case 37:
              a += r.slice(c, u), c = u + 1;
              continue;
            default:
              continue;
          }
          c !== u - 1 && (a += r.slice(c, u - 1)), a += o, c = u + 1;
        } else
          d === 37 && (a += r.slice(c, u), c = u + 1);
      }
    c !== 0 && (s++, i = " ", c < r.length && (a += r.slice(c)));
  }
  for (; s < t.length; ) {
    const o = t[s];
    a += i, a += typeof o != "string" ? be(o, e) : o, i = " ", s++;
  }
  return a;
}
var Ni;
var oh = {
  runtime: [typeof window, typeof document].includes("undefined") ? "Generic" : "Browser",
  browser: (Ni = globalThis == null ? void 0 : globalThis.navigator) == null ? void 0 : Ni.userAgent
};
var uh = /(?:(?:file|https?|global code|[^@]+)@)?(?:file:)?((?:\/[^:/]+){2,})(?::(\d+))?(?::(\d+))?/;
function ch(e, t, n, r, s, a) {
  return Object.assign({}, oh, {
    name: s,
    parentNames: a,
    date: /* @__PURE__ */ new Date(),
    logLevelId: e,
    logLevelName: t,
    path: r ? void 0 : lh(n)
  });
}
function lh(e, t = Error()) {
  var n, r, s;
  return cu((s = (r = (n = t == null ? void 0 : t.stack) == null ? void 0 : n.split(`
`)) == null ? void 0 : r.filter((a) => !a.includes("Error: "))) == null ? void 0 : s[e]);
}
function uu(e) {
  var t, n, r;
  return (r = (n = (t = e == null ? void 0 : e.stack) == null ? void 0 : t.split(`
`)) == null ? void 0 : n.filter((s) => !s.includes("Error: "))) == null ? void 0 : r.reduce((s, a) => (s.push(cu(a)), s), []);
}
function cu(e) {
  const t = globalThis.location.origin, n = {
    fullFilePath: void 0,
    fileName: void 0,
    fileNameWithLine: void 0,
    fileColumn: void 0,
    fileLine: void 0,
    filePath: void 0,
    filePathWithLine: void 0,
    method: void 0
  };
  if (e != null) {
    const r = e.match(uh);
    if (r) {
      n.filePath = r[1].replace(/\?.*$/, ""), n.fullFilePath = `${t}${n.filePath}`;
      const s = n.filePath.split("/");
      n.fileName = s[s.length - 1], n.fileLine = r[2], n.fileColumn = r[3], n.filePathWithLine = `${n.filePath}:${n.fileLine}`, n.fileNameWithLine = `${n.fileName}:${n.fileLine}`;
    }
  }
  return n;
}
function Vs(e) {
  return e instanceof Error;
}
function dh(e, t) {
  return e.reduce((n, r) => (Vs(r) ? n.errors.push(fh(r, t)) : n.args.push(r), n), { args: [], errors: [] });
}
function fh(e, t) {
  const n = uu(e).map((s) => zs(t, t.prettyErrorStackTemplate, { ...s }, true)), r = {
    errorName: ` ${e.name} `,
    errorMessage: e.message,
    errorStack: n.join(`
`)
  };
  return zs(t, t.prettyErrorTemplate, r);
}
function hh(e, t, n, r) {
  const s = (n.length > 0 && t.length > 0 ? `
` : "") + n.join(`
`);
  r.prettyInspectOptions.colors = r.stylePrettyLogs, console.log(e + ih(r.prettyInspectOptions, ...t) + s);
}
function ph(e) {
  console.log(nu(e));
}
function Ne(e, t = 2, n = 0) {
  return e != null && isNaN(e) ? "" : (e = e != null ? e + n : e, t === 2 ? e == null ? "--" : e < 10 ? "0" + e : e.toString() : e == null ? "---" : e < 10 ? "00" + e : e < 100 ? "0" + e : e.toString());
}
var mh = class {
  constructor(t, n, r = 4) {
    var s, a, i, o, c, u, d;
    this.logObj = n, this.stackDepthLevel = r;
    const h = ![typeof window, typeof document].includes("undefined"), p = Object.prototype.toString.call(typeof process < "u" ? process : 0) === "[object process]";
    this.runtime = h ? "browser" : p ? "nodejs" : "unknown";
    const b = h ? (((window == null ? void 0 : window.chrome) || window.Intl && (Intl == null ? void 0 : Intl.v8BreakIterator)) && "CSS" in window) != null : false, E = h ? /^((?!chrome|android).)*safari/i.test(navigator == null ? void 0 : navigator.userAgent) : false;
    this.stackDepthLevel = E ? 4 : this.stackDepthLevel, this.settings = {
      type: (t == null ? void 0 : t.type) ?? "pretty",
      name: t == null ? void 0 : t.name,
      parentNames: t == null ? void 0 : t.parentNames,
      minLevel: (t == null ? void 0 : t.minLevel) ?? 0,
      argumentsArrayName: t == null ? void 0 : t.argumentsArrayName,
      hideLogPositionForProduction: (t == null ? void 0 : t.hideLogPositionForProduction) ?? false,
      prettyLogTemplate: (t == null ? void 0 : t.prettyLogTemplate) ?? "{{yyyy}}.{{mm}}.{{dd}} {{hh}}:{{MM}}:{{ss}}:{{ms}}	{{logLevelName}}	{{filePathWithLine}}{{nameWithDelimiterPrefix}}	",
      prettyErrorTemplate: (t == null ? void 0 : t.prettyErrorTemplate) ?? `
{{errorName}} {{errorMessage}}
error stack:
{{errorStack}}`,
      prettyErrorStackTemplate: (t == null ? void 0 : t.prettyErrorStackTemplate) ?? `   {{fileName}}	{{method}}
	{{filePathWithLine}}`,
      prettyErrorParentNamesSeparator: (t == null ? void 0 : t.prettyErrorParentNamesSeparator) ?? ":",
      prettyErrorLoggerNameDelimiter: (t == null ? void 0 : t.prettyErrorLoggerNameDelimiter) ?? "	",
      stylePrettyLogs: (t == null ? void 0 : t.stylePrettyLogs) ?? true,
      prettyLogTimeZone: (t == null ? void 0 : t.prettyLogTimeZone) ?? "UTC",
      prettyLogStyles: (t == null ? void 0 : t.prettyLogStyles) ?? {
        logLevelName: {
          "*": ["bold", "black", "bgWhiteBright", "dim"],
          SILLY: ["bold", "white"],
          TRACE: ["bold", "whiteBright"],
          DEBUG: ["bold", "green"],
          INFO: ["bold", "blue"],
          WARN: ["bold", "yellow"],
          ERROR: ["bold", "red"],
          FATAL: ["bold", "redBright"]
        },
        dateIsoStr: "white",
        filePathWithLine: "white",
        name: ["white", "bold"],
        nameWithDelimiterPrefix: ["white", "bold"],
        nameWithDelimiterSuffix: ["white", "bold"],
        errorName: ["bold", "bgRedBright", "whiteBright"],
        fileName: ["yellow"],
        fileNameWithLine: "white"
      },
      prettyInspectOptions: (t == null ? void 0 : t.prettyInspectOptions) ?? {
        colors: true,
        compact: false,
        depth: 1 / 0
      },
      metaProperty: (t == null ? void 0 : t.metaProperty) ?? "_meta",
      maskPlaceholder: (t == null ? void 0 : t.maskPlaceholder) ?? "[***]",
      maskValuesOfKeys: (t == null ? void 0 : t.maskValuesOfKeys) ?? ["password"],
      maskValuesOfKeysCaseInsensitive: (t == null ? void 0 : t.maskValuesOfKeysCaseInsensitive) ?? false,
      maskValuesRegEx: t == null ? void 0 : t.maskValuesRegEx,
      prefix: [...(t == null ? void 0 : t.prefix) ?? []],
      attachedTransports: [...(t == null ? void 0 : t.attachedTransports) ?? []],
      overwrite: {
        mask: (s = t == null ? void 0 : t.overwrite) == null ? void 0 : s.mask,
        toLogObj: (a = t == null ? void 0 : t.overwrite) == null ? void 0 : a.toLogObj,
        addMeta: (i = t == null ? void 0 : t.overwrite) == null ? void 0 : i.addMeta,
        formatMeta: (o = t == null ? void 0 : t.overwrite) == null ? void 0 : o.formatMeta,
        formatLogObj: (c = t == null ? void 0 : t.overwrite) == null ? void 0 : c.formatLogObj,
        transportFormatted: (u = t == null ? void 0 : t.overwrite) == null ? void 0 : u.transportFormatted,
        transportJSON: (d = t == null ? void 0 : t.overwrite) == null ? void 0 : d.transportJSON
      }
    }, this.settings.stylePrettyLogs = this.settings.stylePrettyLogs && h && !b ? false : this.settings.stylePrettyLogs;
  }
  log(t, n, ...r) {
    var s, a, i, o, c, u, d, h, p, b, E, y, A, O;
    if (t < this.settings.minLevel)
      return;
    const I = [...this.settings.prefix, ...r], X = ((s = this.settings.overwrite) == null ? void 0 : s.mask) != null ? (a = this.settings.overwrite) == null ? void 0 : a.mask(I) : this.settings.maskValuesOfKeys != null && this.settings.maskValuesOfKeys.length > 0 ? this._mask(I) : I, F = this.logObj != null ? this._recursiveCloneAndExecuteFunctions(this.logObj) : void 0, ue = ((i = this.settings.overwrite) == null ? void 0 : i.toLogObj) != null ? (o = this.settings.overwrite) == null ? void 0 : o.toLogObj(X, F) : this._toLogObj(X, F), G = ((c = this.settings.overwrite) == null ? void 0 : c.addMeta) != null ? (u = this.settings.overwrite) == null ? void 0 : u.addMeta(ue, t, n) : this._addMetaToLogObj(ue, t, n);
    let S, se;
    return ((d = this.settings.overwrite) == null ? void 0 : d.formatMeta) != null && (S = (h = this.settings.overwrite) == null ? void 0 : h.formatMeta(G == null ? void 0 : G[this.settings.metaProperty])), ((p = this.settings.overwrite) == null ? void 0 : p.formatLogObj) != null && (se = (b = this.settings.overwrite) == null ? void 0 : b.formatLogObj(X, this.settings)), this.settings.type === "pretty" && (S = S ?? this._prettyFormatLogObjMeta(G == null ? void 0 : G[this.settings.metaProperty]), se = se ?? dh(X, this.settings)), S != null && se != null ? ((E = this.settings.overwrite) == null ? void 0 : E.transportFormatted) != null ? (y = this.settings.overwrite) == null || y.transportFormatted(S, se.args, se.errors, this.settings) : hh(S, se.args, se.errors, this.settings) : ((A = this.settings.overwrite) == null ? void 0 : A.transportJSON) != null ? (O = this.settings.overwrite) == null || O.transportJSON(G) : this.settings.type !== "hidden" && ph(G), this.settings.attachedTransports != null && this.settings.attachedTransports.length > 0 && this.settings.attachedTransports.forEach((Q) => {
      Q(G);
    }), G;
  }
  attachTransport(t) {
    this.settings.attachedTransports.push(t);
  }
  getSubLogger(t, n) {
    var r, s, a;
    const i = {
      ...this.settings,
      ...t,
      parentNames: ((r = this.settings) == null ? void 0 : r.parentNames) != null && ((s = this.settings) == null ? void 0 : s.name) != null ? [...this.settings.parentNames, this.settings.name] : ((a = this.settings) == null ? void 0 : a.name) != null ? [this.settings.name] : void 0,
      prefix: [...this.settings.prefix, ...(t == null ? void 0 : t.prefix) ?? []]
    };
    return new this.constructor(i, n ?? this.logObj, this.stackDepthLevel);
  }
  _mask(t) {
    const n = this.settings.maskValuesOfKeysCaseInsensitive !== true ? this.settings.maskValuesOfKeys : this.settings.maskValuesOfKeys.map((r) => r.toLowerCase());
    return t == null ? void 0 : t.map((r) => this._recursiveCloneAndMaskValuesOfKeys(r, n));
  }
  _recursiveCloneAndMaskValuesOfKeys(t, n, r = []) {
    return r.includes(t) ? { ...t } : (typeof t == "object" && t != null && r.push(t), t instanceof Map ? new Map(t) : t instanceof Set ? new Set(t) : Array.isArray(t) ? t.map((s) => this._recursiveCloneAndMaskValuesOfKeys(s, n, r)) : t instanceof Date ? new Date(t.getTime()) : Vs(t) ? Object.getOwnPropertyNames(t).reduce((s, a) => {
      var i;
      return s[a] = n.includes(((i = this.settings) == null ? void 0 : i.maskValuesOfKeysCaseInsensitive) !== true ? a : a.toLowerCase()) ? this.settings.maskPlaceholder : this._recursiveCloneAndMaskValuesOfKeys(t[a], n, r), s;
    }, this._cloneError(t)) : t != null && typeof t == "object" ? Object.getOwnPropertyNames(t).reduce((s, a) => {
      var i;
      return s[a] = n.includes(((i = this.settings) == null ? void 0 : i.maskValuesOfKeysCaseInsensitive) !== true ? a : a.toLowerCase()) ? this.settings.maskPlaceholder : this._recursiveCloneAndMaskValuesOfKeys(t[a], n, r), s;
    }, Object.create(Object.getPrototypeOf(t))) : ((s) => {
      var a, i;
      return (i = (a = this.settings) == null ? void 0 : a.maskValuesRegEx) == null || i.forEach((o) => {
        var c;
        s = (c = s == null ? void 0 : s.toString()) == null ? void 0 : c.replace(o, this.settings.maskPlaceholder);
      }), s;
    })(t));
  }
  _recursiveCloneAndExecuteFunctions(t, n = []) {
    return n.includes(t) ? { ...t } : (typeof t == "object" && n.push(t), Array.isArray(t) ? t.map((r) => this._recursiveCloneAndExecuteFunctions(r, n)) : t instanceof Date ? new Date(t.getTime()) : t && typeof t == "object" ? Object.getOwnPropertyNames(t).reduce((r, s) => (Object.defineProperty(r, s, Object.getOwnPropertyDescriptor(t, s)), r[s] = typeof t[s] == "function" ? t[s]() : this._recursiveCloneAndExecuteFunctions(t[s], n), r), Object.create(Object.getPrototypeOf(t))) : t);
  }
  _toLogObj(t, n = {}) {
    return t = t == null ? void 0 : t.map((r) => Vs(r) ? this._toErrorObject(r) : r), this.settings.argumentsArrayName == null ? t.length === 1 && !Array.isArray(t[0]) && (t[0], true) && !(t[0] instanceof Date) ? n = typeof t[0] == "object" && t[0] != null ? { ...t[0], ...n } : { 0: t[0], ...n } : n = { ...n, ...t } : n = {
      ...n,
      [this.settings.argumentsArrayName]: t
    }, n;
  }
  _cloneError(t) {
    const n = t.constructor, r = new n(t.message);
    Object.assign(r, t);
    const s = Object.getOwnPropertyNames(r);
    for (const a of s) {
      const i = Object.getOwnPropertyDescriptor(r, a);
      i && (i.writable = true, Object.defineProperty(r, a, i));
    }
    return r;
  }
  _toErrorObject(t) {
    return {
      nativeError: t,
      name: t.name ?? "Error",
      message: t.message,
      stack: uu(t)
    };
  }
  _addMetaToLogObj(t, n, r) {
    return {
      ...t,
      [this.settings.metaProperty]: ch(n, r, this.stackDepthLevel, this.settings.hideLogPositionForProduction, this.settings.name, this.settings.parentNames)
    };
  }
  _prettyFormatLogObjMeta(t) {
    var n, r, s, a, i, o, c, u, d, h, p, b, E, y, A, O, I, X, F, ue;
    if (t == null)
      return "";
    let G = this.settings.prettyLogTemplate;
    const S = {};
    G.includes("{{yyyy}}.{{mm}}.{{dd}} {{hh}}:{{MM}}:{{ss}}:{{ms}}") ? G = G.replace("{{yyyy}}.{{mm}}.{{dd}} {{hh}}:{{MM}}:{{ss}}:{{ms}}", "{{dateIsoStr}}") : this.settings.prettyLogTimeZone === "UTC" ? (S.yyyy = ((n = t == null ? void 0 : t.date) == null ? void 0 : n.getUTCFullYear()) ?? "----", S.mm = Ne((r = t == null ? void 0 : t.date) == null ? void 0 : r.getUTCMonth(), 2, 1), S.dd = Ne((s = t == null ? void 0 : t.date) == null ? void 0 : s.getUTCDate(), 2), S.hh = Ne((a = t == null ? void 0 : t.date) == null ? void 0 : a.getUTCHours(), 2), S.MM = Ne((i = t == null ? void 0 : t.date) == null ? void 0 : i.getUTCMinutes(), 2), S.ss = Ne((o = t == null ? void 0 : t.date) == null ? void 0 : o.getUTCSeconds(), 2), S.ms = Ne((c = t == null ? void 0 : t.date) == null ? void 0 : c.getUTCMilliseconds(), 3)) : (S.yyyy = ((u = t == null ? void 0 : t.date) == null ? void 0 : u.getFullYear()) ?? "----", S.mm = Ne((d = t == null ? void 0 : t.date) == null ? void 0 : d.getMonth(), 2, 1), S.dd = Ne((h = t == null ? void 0 : t.date) == null ? void 0 : h.getDate(), 2), S.hh = Ne((p = t == null ? void 0 : t.date) == null ? void 0 : p.getHours(), 2), S.MM = Ne((b = t == null ? void 0 : t.date) == null ? void 0 : b.getMinutes(), 2), S.ss = Ne((E = t == null ? void 0 : t.date) == null ? void 0 : E.getSeconds(), 2), S.ms = Ne((y = t == null ? void 0 : t.date) == null ? void 0 : y.getMilliseconds(), 3));
    const se = this.settings.prettyLogTimeZone === "UTC" ? t == null ? void 0 : t.date : new Date(((A = t == null ? void 0 : t.date) == null ? void 0 : A.getTime()) - ((O = t == null ? void 0 : t.date) == null ? void 0 : O.getTimezoneOffset()) * 6e4);
    S.rawIsoStr = se == null ? void 0 : se.toISOString(), S.dateIsoStr = se == null ? void 0 : se.toISOString().replace("T", " ").replace("Z", ""), S.logLevelName = t == null ? void 0 : t.logLevelName, S.fileNameWithLine = ((I = t == null ? void 0 : t.path) == null ? void 0 : I.fileNameWithLine) ?? "", S.filePathWithLine = ((X = t == null ? void 0 : t.path) == null ? void 0 : X.filePathWithLine) ?? "", S.fullFilePath = ((F = t == null ? void 0 : t.path) == null ? void 0 : F.fullFilePath) ?? "";
    let Q = (ue = this.settings.parentNames) == null ? void 0 : ue.join(this.settings.prettyErrorParentNamesSeparator);
    return Q = Q != null && (t == null ? void 0 : t.name) != null ? Q + this.settings.prettyErrorParentNamesSeparator : void 0, S.name = (t == null ? void 0 : t.name) != null || Q != null ? (Q ?? "") + (t == null ? void 0 : t.name) : "", S.nameWithDelimiterPrefix = S.name.length > 0 ? this.settings.prettyErrorLoggerNameDelimiter + S.name : "", S.nameWithDelimiterSuffix = S.name.length > 0 ? S.name + this.settings.prettyErrorLoggerNameDelimiter : "", zs(this.settings, G, S);
  }
};
var yh = class extends mh {
  constructor(t, n) {
    super(t, n, 5);
  }
  log(t, n, ...r) {
    return super.log(t, n, ...r);
  }
  silly(...t) {
    return super.log(0, "SILLY", ...t);
  }
  trace(...t) {
    return super.log(1, "TRACE", ...t);
  }
  debug(...t) {
    return super.log(2, "DEBUG", ...t);
  }
  info(...t) {
    return super.log(3, "INFO", ...t);
  }
  warn(...t) {
    return super.log(4, "WARN", ...t);
  }
  error(...t) {
    return super.log(5, "ERROR", ...t);
  }
  fatal(...t) {
    return super.log(6, "FATAL", ...t);
  }
  getSubLogger(t, n) {
    return super.getSubLogger(t, n);
  }
};
var Rg = (e) => new yh({
  minLevel: e,
  prettyLogTemplate: "{{hh}}:{{MM}}:{{ss}}:{{ms}}	{{logLevelName}}	"
});
var vh = (e) => {
  var t, n;
  const r = {
    version: 2,
    dAppDefinitionAddress: e.dAppDefinitionAddress,
    networkId: e.networkId
  };
  Eo.parse(r), (t = e.logger) == null || t.debug(" walletSdkInstantiated", r);
  const s = e.logger, a = ((n = e.providers) == null ? void 0 : n.connectorExtensionClient) ?? Qf({ logger: s });
  return {
    ...rf(
      {
        version: 2,
        logger: e.logger,
        dAppDefinitionAddress: e.dAppDefinitionAddress,
        networkId: e.networkId
      },
      a
    ),
    destroy: () => {
      s == null || s.debug(" walletSdkInstantiatedDestroyed"), a.destroy();
    }
  };
};
var B;
(function(e) {
  e.assertEqual = (s) => s;
  function t(s) {
  }
  e.assertIs = t;
  function n(s) {
    throw new Error();
  }
  e.assertNever = n, e.arrayToEnum = (s) => {
    const a = {};
    for (const i of s)
      a[i] = i;
    return a;
  }, e.getValidEnumValues = (s) => {
    const a = e.objectKeys(s).filter((o) => typeof s[s[o]] != "number"), i = {};
    for (const o of a)
      i[o] = s[o];
    return e.objectValues(i);
  }, e.objectValues = (s) => e.objectKeys(s).map(function(a) {
    return s[a];
  }), e.objectKeys = typeof Object.keys == "function" ? (s) => Object.keys(s) : (s) => {
    const a = [];
    for (const i in s)
      Object.prototype.hasOwnProperty.call(s, i) && a.push(i);
    return a;
  }, e.find = (s, a) => {
    for (const i of s)
      if (a(i))
        return i;
  }, e.isInteger = typeof Number.isInteger == "function" ? (s) => Number.isInteger(s) : (s) => typeof s == "number" && isFinite(s) && Math.floor(s) === s;
  function r(s, a = " | ") {
    return s.map((i) => typeof i == "string" ? `'${i}'` : i).join(a);
  }
  e.joinValues = r, e.jsonStringifyReplacer = (s, a) => typeof a == "bigint" ? a.toString() : a;
})(B || (B = {}));
var ji;
(function(e) {
  e.mergeShapes = (t, n) => ({
    ...t,
    ...n
    // second overwrites first
  });
})(ji || (ji = {}));
var w = B.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]);
var Zt = (e) => {
  switch (typeof e) {
    case "undefined":
      return w.undefined;
    case "string":
      return w.string;
    case "number":
      return isNaN(e) ? w.nan : w.number;
    case "boolean":
      return w.boolean;
    case "function":
      return w.function;
    case "bigint":
      return w.bigint;
    case "symbol":
      return w.symbol;
    case "object":
      return Array.isArray(e) ? w.array : e === null ? w.null : e.then && typeof e.then == "function" && e.catch && typeof e.catch == "function" ? w.promise : typeof Map < "u" && e instanceof Map ? w.map : typeof Set < "u" && e instanceof Set ? w.set : typeof Date < "u" && e instanceof Date ? w.date : w.object;
    default:
      return w.unknown;
  }
};
var g = B.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]);
var Ge = class extends Error {
  constructor(t) {
    super(), this.issues = [], this.addIssue = (r) => {
      this.issues = [...this.issues, r];
    }, this.addIssues = (r = []) => {
      this.issues = [...this.issues, ...r];
    };
    const n = new.target.prototype;
    Object.setPrototypeOf ? Object.setPrototypeOf(this, n) : this.__proto__ = n, this.name = "ZodError", this.issues = t;
  }
  get errors() {
    return this.issues;
  }
  format(t) {
    const n = t || function(a) {
      return a.message;
    }, r = { _errors: [] }, s = (a) => {
      for (const i of a.issues)
        if (i.code === "invalid_union")
          i.unionErrors.map(s);
        else if (i.code === "invalid_return_type")
          s(i.returnTypeError);
        else if (i.code === "invalid_arguments")
          s(i.argumentsError);
        else if (i.path.length === 0)
          r._errors.push(n(i));
        else {
          let o = r, c = 0;
          for (; c < i.path.length; ) {
            const u = i.path[c];
            c === i.path.length - 1 ? (o[u] = o[u] || { _errors: [] }, o[u]._errors.push(n(i))) : o[u] = o[u] || { _errors: [] }, o = o[u], c++;
          }
        }
    };
    return s(this), r;
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, B.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(t = (n) => n.message) {
    const n = {}, r = [];
    for (const s of this.issues)
      s.path.length > 0 ? (n[s.path[0]] = n[s.path[0]] || [], n[s.path[0]].push(t(s))) : r.push(t(s));
    return { formErrors: r, fieldErrors: n };
  }
  get formErrors() {
    return this.flatten();
  }
};
Ge.create = (e) => new Ge(e);
var br = (e, t) => {
  let n;
  switch (e.code) {
    case g.invalid_type:
      e.received === w.undefined ? n = "Required" : n = `Expected ${e.expected}, received ${e.received}`;
      break;
    case g.invalid_literal:
      n = `Invalid literal value, expected ${JSON.stringify(e.expected, B.jsonStringifyReplacer)}`;
      break;
    case g.unrecognized_keys:
      n = `Unrecognized key(s) in object: ${B.joinValues(e.keys, ", ")}`;
      break;
    case g.invalid_union:
      n = "Invalid input";
      break;
    case g.invalid_union_discriminator:
      n = `Invalid discriminator value. Expected ${B.joinValues(e.options)}`;
      break;
    case g.invalid_enum_value:
      n = `Invalid enum value. Expected ${B.joinValues(e.options)}, received '${e.received}'`;
      break;
    case g.invalid_arguments:
      n = "Invalid function arguments";
      break;
    case g.invalid_return_type:
      n = "Invalid function return type";
      break;
    case g.invalid_date:
      n = "Invalid date";
      break;
    case g.invalid_string:
      typeof e.validation == "object" ? "includes" in e.validation ? (n = `Invalid input: must include "${e.validation.includes}"`, typeof e.validation.position == "number" && (n = `${n} at one or more positions greater than or equal to ${e.validation.position}`)) : "startsWith" in e.validation ? n = `Invalid input: must start with "${e.validation.startsWith}"` : "endsWith" in e.validation ? n = `Invalid input: must end with "${e.validation.endsWith}"` : B.assertNever(e.validation) : e.validation !== "regex" ? n = `Invalid ${e.validation}` : n = "Invalid";
      break;
    case g.too_small:
      e.type === "array" ? n = `Array must contain ${e.exact ? "exactly" : e.inclusive ? "at least" : "more than"} ${e.minimum} element(s)` : e.type === "string" ? n = `String must contain ${e.exact ? "exactly" : e.inclusive ? "at least" : "over"} ${e.minimum} character(s)` : e.type === "number" ? n = `Number must be ${e.exact ? "exactly equal to " : e.inclusive ? "greater than or equal to " : "greater than "}${e.minimum}` : e.type === "date" ? n = `Date must be ${e.exact ? "exactly equal to " : e.inclusive ? "greater than or equal to " : "greater than "}${new Date(Number(e.minimum))}` : n = "Invalid input";
      break;
    case g.too_big:
      e.type === "array" ? n = `Array must contain ${e.exact ? "exactly" : e.inclusive ? "at most" : "less than"} ${e.maximum} element(s)` : e.type === "string" ? n = `String must contain ${e.exact ? "exactly" : e.inclusive ? "at most" : "under"} ${e.maximum} character(s)` : e.type === "number" ? n = `Number must be ${e.exact ? "exactly" : e.inclusive ? "less than or equal to" : "less than"} ${e.maximum}` : e.type === "bigint" ? n = `BigInt must be ${e.exact ? "exactly" : e.inclusive ? "less than or equal to" : "less than"} ${e.maximum}` : e.type === "date" ? n = `Date must be ${e.exact ? "exactly" : e.inclusive ? "smaller than or equal to" : "smaller than"} ${new Date(Number(e.maximum))}` : n = "Invalid input";
      break;
    case g.custom:
      n = "Invalid input";
      break;
    case g.invalid_intersection_types:
      n = "Intersection results could not be merged";
      break;
    case g.not_multiple_of:
      n = `Number must be a multiple of ${e.multipleOf}`;
      break;
    case g.not_finite:
      n = "Number must be finite";
      break;
    default:
      n = t.defaultError, B.assertNever(e);
  }
  return { message: n };
};
var gh = br;
function Bs() {
  return gh;
}
var Ws = (e) => {
  const { data: t, path: n, errorMaps: r, issueData: s } = e, a = [...n, ...s.path || []], i = {
    ...s,
    path: a
  };
  let o = "";
  const c = r.filter((u) => !!u).slice().reverse();
  for (const u of c)
    o = u(i, { data: t, defaultError: o }).message;
  return {
    ...s,
    path: a,
    message: s.message || o
  };
};
function k(e, t) {
  const n = Ws({
    issueData: t,
    data: e.data,
    path: e.path,
    errorMaps: [
      e.common.contextualErrorMap,
      e.schemaErrorMap,
      Bs(),
      br
      // then global default map
    ].filter((r) => !!r)
  });
  e.common.issues.push(n);
}
var ge = class _ge {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    this.value === "valid" && (this.value = "dirty");
  }
  abort() {
    this.value !== "aborted" && (this.value = "aborted");
  }
  static mergeArray(t, n) {
    const r = [];
    for (const s of n) {
      if (s.status === "aborted")
        return D;
      s.status === "dirty" && t.dirty(), r.push(s.value);
    }
    return { status: t.value, value: r };
  }
  static async mergeObjectAsync(t, n) {
    const r = [];
    for (const s of n)
      r.push({
        key: await s.key,
        value: await s.value
      });
    return _ge.mergeObjectSync(t, r);
  }
  static mergeObjectSync(t, n) {
    const r = {};
    for (const s of n) {
      const { key: a, value: i } = s;
      if (a.status === "aborted" || i.status === "aborted")
        return D;
      a.status === "dirty" && t.dirty(), i.status === "dirty" && t.dirty(), (typeof i.value < "u" || s.alwaysSet) && (r[a.value] = i.value);
    }
    return { status: t.value, value: r };
  }
};
var D = Object.freeze({
  status: "aborted"
});
var _h = (e) => ({ status: "dirty", value: e });
var ke = (e) => ({ status: "valid", value: e });
var Di = (e) => e.status === "aborted";
var qi = (e) => e.status === "dirty";
var Ks = (e) => e.status === "valid";
var Gs = (e) => typeof Promise < "u" && e instanceof Promise;
var R;
(function(e) {
  e.errToObj = (t) => typeof t == "string" ? { message: t } : t || {}, e.toString = (t) => typeof t == "string" ? t : t == null ? void 0 : t.message;
})(R || (R = {}));
var Xe = class {
  constructor(t, n, r, s) {
    this._cachedPath = [], this.parent = t, this.data = n, this._path = r, this._key = s;
  }
  get path() {
    return this._cachedPath.length || (this._key instanceof Array ? this._cachedPath.push(...this._path, ...this._key) : this._cachedPath.push(...this._path, this._key)), this._cachedPath;
  }
};
var $i = (e, t) => {
  if (Ks(t))
    return { success: true, data: t.value };
  if (!e.common.issues.length)
    throw new Error("Validation failed but no issues detected.");
  return {
    success: false,
    get error() {
      if (this._error)
        return this._error;
      const n = new Ge(e.common.issues);
      return this._error = n, this._error;
    }
  };
};
function $(e) {
  if (!e)
    return {};
  const { errorMap: t, invalid_type_error: n, required_error: r, description: s } = e;
  if (t && (n || r))
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  return t ? { errorMap: t, description: s } : { errorMap: (i, o) => i.code !== "invalid_type" ? { message: o.defaultError } : typeof o.data > "u" ? { message: r ?? o.defaultError } : { message: n ?? o.defaultError }, description: s };
}
var M = class {
  constructor(t) {
    this.spa = this.safeParseAsync, this._def = t, this.parse = this.parse.bind(this), this.safeParse = this.safeParse.bind(this), this.parseAsync = this.parseAsync.bind(this), this.safeParseAsync = this.safeParseAsync.bind(this), this.spa = this.spa.bind(this), this.refine = this.refine.bind(this), this.refinement = this.refinement.bind(this), this.superRefine = this.superRefine.bind(this), this.optional = this.optional.bind(this), this.nullable = this.nullable.bind(this), this.nullish = this.nullish.bind(this), this.array = this.array.bind(this), this.promise = this.promise.bind(this), this.or = this.or.bind(this), this.and = this.and.bind(this), this.transform = this.transform.bind(this), this.brand = this.brand.bind(this), this.default = this.default.bind(this), this.catch = this.catch.bind(this), this.describe = this.describe.bind(this), this.pipe = this.pipe.bind(this), this.isNullable = this.isNullable.bind(this), this.isOptional = this.isOptional.bind(this);
  }
  get description() {
    return this._def.description;
  }
  _getType(t) {
    return Zt(t.data);
  }
  _getOrReturnCtx(t, n) {
    return n || {
      common: t.parent.common,
      data: t.data,
      parsedType: Zt(t.data),
      schemaErrorMap: this._def.errorMap,
      path: t.path,
      parent: t.parent
    };
  }
  _processInputParams(t) {
    return {
      status: new ge(),
      ctx: {
        common: t.parent.common,
        data: t.data,
        parsedType: Zt(t.data),
        schemaErrorMap: this._def.errorMap,
        path: t.path,
        parent: t.parent
      }
    };
  }
  _parseSync(t) {
    const n = this._parse(t);
    if (Gs(n))
      throw new Error("Synchronous parse encountered promise.");
    return n;
  }
  _parseAsync(t) {
    const n = this._parse(t);
    return Promise.resolve(n);
  }
  parse(t, n) {
    const r = this.safeParse(t, n);
    if (r.success)
      return r.data;
    throw r.error;
  }
  safeParse(t, n) {
    var r;
    const s = {
      common: {
        issues: [],
        async: (r = n == null ? void 0 : n.async) !== null && r !== void 0 ? r : false,
        contextualErrorMap: n == null ? void 0 : n.errorMap
      },
      path: (n == null ? void 0 : n.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: t,
      parsedType: Zt(t)
    }, a = this._parseSync({ data: t, path: s.path, parent: s });
    return $i(s, a);
  }
  async parseAsync(t, n) {
    const r = await this.safeParseAsync(t, n);
    if (r.success)
      return r.data;
    throw r.error;
  }
  async safeParseAsync(t, n) {
    const r = {
      common: {
        issues: [],
        contextualErrorMap: n == null ? void 0 : n.errorMap,
        async: true
      },
      path: (n == null ? void 0 : n.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: t,
      parsedType: Zt(t)
    }, s = this._parse({ data: t, path: r.path, parent: r }), a = await (Gs(s) ? s : Promise.resolve(s));
    return $i(r, a);
  }
  refine(t, n) {
    const r = (s) => typeof n == "string" || typeof n > "u" ? { message: n } : typeof n == "function" ? n(s) : n;
    return this._refinement((s, a) => {
      const i = t(s), o = () => a.addIssue({
        code: g.custom,
        ...r(s)
      });
      return typeof Promise < "u" && i instanceof Promise ? i.then((c) => c ? true : (o(), false)) : i ? true : (o(), false);
    });
  }
  refinement(t, n) {
    return this._refinement((r, s) => t(r) ? true : (s.addIssue(typeof n == "function" ? n(r, s) : n), false));
  }
  _refinement(t) {
    return new dt({
      schema: this,
      typeName: N.ZodEffects,
      effect: { type: "refinement", refinement: t }
    });
  }
  superRefine(t) {
    return this._refinement(t);
  }
  optional() {
    return bt.create(this, this._def);
  }
  nullable() {
    return kn.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return He.create(this, this._def);
  }
  promise() {
    return Ln.create(this, this._def);
  }
  or(t) {
    return kr.create([this, t], this._def);
  }
  and(t) {
    return Sr.create(this, t, this._def);
  }
  transform(t) {
    return new dt({
      ...$(this._def),
      schema: this,
      typeName: N.ZodEffects,
      effect: { type: "transform", transform: t }
    });
  }
  default(t) {
    const n = typeof t == "function" ? t : () => t;
    return new Cr({
      ...$(this._def),
      innerType: this,
      defaultValue: n,
      typeName: N.ZodDefault
    });
  }
  brand() {
    return new Ah({
      typeName: N.ZodBranded,
      type: this,
      ...$(this._def)
    });
  }
  catch(t) {
    const n = typeof t == "function" ? t : () => t;
    return new ta({
      ...$(this._def),
      innerType: this,
      catchValue: n,
      typeName: N.ZodCatch
    });
  }
  describe(t) {
    const n = this.constructor;
    return new n({
      ...this._def,
      description: t
    });
  }
  pipe(t) {
    return Mr.create(this, t);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
};
var bh = /^c[^\s-]{8,}$/i;
var wh = /^[a-z][a-z0-9]*$/;
var xh = /[0-9A-HJKMNP-TV-Z]{26}/;
var kh = /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[a-f0-9]{4}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i;
var Sh = /^(([^<>()[\]\\.,;:\s@\"]+(\.[^<>()[\]\\.,;:\s@\"]+)*)|(\".+\"))@((\[(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\])|(\[IPv6:(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))\])|([A-Za-z0-9]([A-Za-z0-9-]*[A-Za-z0-9])*(\.[A-Za-z]{2,})+))$/;
var Th = /^(\p{Extended_Pictographic}|\p{Emoji_Component})+$/u;
var Ph = /^(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))$/;
var Oh = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/;
var Eh = (e) => e.precision ? e.offset ? new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${e.precision}}(([+-]\\d{2}(:?\\d{2})?)|Z)$`) : new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${e.precision}}Z$`) : e.precision === 0 ? e.offset ? new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(([+-]\\d{2}(:?\\d{2})?)|Z)$") : new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}Z$") : e.offset ? new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(([+-]\\d{2}(:?\\d{2})?)|Z)$") : new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?Z$");
function Ch(e, t) {
  return !!((t === "v4" || !t) && Ph.test(e) || (t === "v6" || !t) && Oh.test(e));
}
var ut = class _ut extends M {
  constructor() {
    super(...arguments), this._regex = (t, n, r) => this.refinement((s) => t.test(s), {
      validation: n,
      code: g.invalid_string,
      ...R.errToObj(r)
    }), this.nonempty = (t) => this.min(1, R.errToObj(t)), this.trim = () => new _ut({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    }), this.toLowerCase = () => new _ut({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    }), this.toUpperCase = () => new _ut({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  _parse(t) {
    if (this._def.coerce && (t.data = String(t.data)), this._getType(t) !== w.string) {
      const a = this._getOrReturnCtx(t);
      return k(
        a,
        {
          code: g.invalid_type,
          expected: w.string,
          received: a.parsedType
        }
        //
      ), D;
    }
    const r = new ge();
    let s;
    for (const a of this._def.checks)
      if (a.kind === "min")
        t.data.length < a.value && (s = this._getOrReturnCtx(t, s), k(s, {
          code: g.too_small,
          minimum: a.value,
          type: "string",
          inclusive: true,
          exact: false,
          message: a.message
        }), r.dirty());
      else if (a.kind === "max")
        t.data.length > a.value && (s = this._getOrReturnCtx(t, s), k(s, {
          code: g.too_big,
          maximum: a.value,
          type: "string",
          inclusive: true,
          exact: false,
          message: a.message
        }), r.dirty());
      else if (a.kind === "length") {
        const i = t.data.length > a.value, o = t.data.length < a.value;
        (i || o) && (s = this._getOrReturnCtx(t, s), i ? k(s, {
          code: g.too_big,
          maximum: a.value,
          type: "string",
          inclusive: true,
          exact: true,
          message: a.message
        }) : o && k(s, {
          code: g.too_small,
          minimum: a.value,
          type: "string",
          inclusive: true,
          exact: true,
          message: a.message
        }), r.dirty());
      } else if (a.kind === "email")
        Sh.test(t.data) || (s = this._getOrReturnCtx(t, s), k(s, {
          validation: "email",
          code: g.invalid_string,
          message: a.message
        }), r.dirty());
      else if (a.kind === "emoji")
        Th.test(t.data) || (s = this._getOrReturnCtx(t, s), k(s, {
          validation: "emoji",
          code: g.invalid_string,
          message: a.message
        }), r.dirty());
      else if (a.kind === "uuid")
        kh.test(t.data) || (s = this._getOrReturnCtx(t, s), k(s, {
          validation: "uuid",
          code: g.invalid_string,
          message: a.message
        }), r.dirty());
      else if (a.kind === "cuid")
        bh.test(t.data) || (s = this._getOrReturnCtx(t, s), k(s, {
          validation: "cuid",
          code: g.invalid_string,
          message: a.message
        }), r.dirty());
      else if (a.kind === "cuid2")
        wh.test(t.data) || (s = this._getOrReturnCtx(t, s), k(s, {
          validation: "cuid2",
          code: g.invalid_string,
          message: a.message
        }), r.dirty());
      else if (a.kind === "ulid")
        xh.test(t.data) || (s = this._getOrReturnCtx(t, s), k(s, {
          validation: "ulid",
          code: g.invalid_string,
          message: a.message
        }), r.dirty());
      else if (a.kind === "url")
        try {
          new URL(t.data);
        } catch {
          s = this._getOrReturnCtx(t, s), k(s, {
            validation: "url",
            code: g.invalid_string,
            message: a.message
          }), r.dirty();
        }
      else
        a.kind === "regex" ? (a.regex.lastIndex = 0, a.regex.test(t.data) || (s = this._getOrReturnCtx(t, s), k(s, {
          validation: "regex",
          code: g.invalid_string,
          message: a.message
        }), r.dirty())) : a.kind === "trim" ? t.data = t.data.trim() : a.kind === "includes" ? t.data.includes(a.value, a.position) || (s = this._getOrReturnCtx(t, s), k(s, {
          code: g.invalid_string,
          validation: { includes: a.value, position: a.position },
          message: a.message
        }), r.dirty()) : a.kind === "toLowerCase" ? t.data = t.data.toLowerCase() : a.kind === "toUpperCase" ? t.data = t.data.toUpperCase() : a.kind === "startsWith" ? t.data.startsWith(a.value) || (s = this._getOrReturnCtx(t, s), k(s, {
          code: g.invalid_string,
          validation: { startsWith: a.value },
          message: a.message
        }), r.dirty()) : a.kind === "endsWith" ? t.data.endsWith(a.value) || (s = this._getOrReturnCtx(t, s), k(s, {
          code: g.invalid_string,
          validation: { endsWith: a.value },
          message: a.message
        }), r.dirty()) : a.kind === "datetime" ? Eh(a).test(t.data) || (s = this._getOrReturnCtx(t, s), k(s, {
          code: g.invalid_string,
          validation: "datetime",
          message: a.message
        }), r.dirty()) : a.kind === "ip" ? Ch(t.data, a.version) || (s = this._getOrReturnCtx(t, s), k(s, {
          validation: "ip",
          code: g.invalid_string,
          message: a.message
        }), r.dirty()) : B.assertNever(a);
    return { status: r.value, value: t.data };
  }
  _addCheck(t) {
    return new _ut({
      ...this._def,
      checks: [...this._def.checks, t]
    });
  }
  email(t) {
    return this._addCheck({ kind: "email", ...R.errToObj(t) });
  }
  url(t) {
    return this._addCheck({ kind: "url", ...R.errToObj(t) });
  }
  emoji(t) {
    return this._addCheck({ kind: "emoji", ...R.errToObj(t) });
  }
  uuid(t) {
    return this._addCheck({ kind: "uuid", ...R.errToObj(t) });
  }
  cuid(t) {
    return this._addCheck({ kind: "cuid", ...R.errToObj(t) });
  }
  cuid2(t) {
    return this._addCheck({ kind: "cuid2", ...R.errToObj(t) });
  }
  ulid(t) {
    return this._addCheck({ kind: "ulid", ...R.errToObj(t) });
  }
  ip(t) {
    return this._addCheck({ kind: "ip", ...R.errToObj(t) });
  }
  datetime(t) {
    var n;
    return typeof t == "string" ? this._addCheck({
      kind: "datetime",
      precision: null,
      offset: false,
      message: t
    }) : this._addCheck({
      kind: "datetime",
      precision: typeof (t == null ? void 0 : t.precision) > "u" ? null : t == null ? void 0 : t.precision,
      offset: (n = t == null ? void 0 : t.offset) !== null && n !== void 0 ? n : false,
      ...R.errToObj(t == null ? void 0 : t.message)
    });
  }
  regex(t, n) {
    return this._addCheck({
      kind: "regex",
      regex: t,
      ...R.errToObj(n)
    });
  }
  includes(t, n) {
    return this._addCheck({
      kind: "includes",
      value: t,
      position: n == null ? void 0 : n.position,
      ...R.errToObj(n == null ? void 0 : n.message)
    });
  }
  startsWith(t, n) {
    return this._addCheck({
      kind: "startsWith",
      value: t,
      ...R.errToObj(n)
    });
  }
  endsWith(t, n) {
    return this._addCheck({
      kind: "endsWith",
      value: t,
      ...R.errToObj(n)
    });
  }
  min(t, n) {
    return this._addCheck({
      kind: "min",
      value: t,
      ...R.errToObj(n)
    });
  }
  max(t, n) {
    return this._addCheck({
      kind: "max",
      value: t,
      ...R.errToObj(n)
    });
  }
  length(t, n) {
    return this._addCheck({
      kind: "length",
      value: t,
      ...R.errToObj(n)
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((t) => t.kind === "datetime");
  }
  get isEmail() {
    return !!this._def.checks.find((t) => t.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((t) => t.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((t) => t.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((t) => t.kind === "uuid");
  }
  get isCUID() {
    return !!this._def.checks.find((t) => t.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((t) => t.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((t) => t.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((t) => t.kind === "ip");
  }
  get minLength() {
    let t = null;
    for (const n of this._def.checks)
      n.kind === "min" && (t === null || n.value > t) && (t = n.value);
    return t;
  }
  get maxLength() {
    let t = null;
    for (const n of this._def.checks)
      n.kind === "max" && (t === null || n.value < t) && (t = n.value);
    return t;
  }
};
ut.create = (e) => {
  var t;
  return new ut({
    checks: [],
    typeName: N.ZodString,
    coerce: (t = e == null ? void 0 : e.coerce) !== null && t !== void 0 ? t : false,
    ...$(e)
  });
};
function Rh(e, t) {
  const n = (e.toString().split(".")[1] || "").length, r = (t.toString().split(".")[1] || "").length, s = n > r ? n : r, a = parseInt(e.toFixed(s).replace(".", "")), i = parseInt(t.toFixed(s).replace(".", ""));
  return a % i / Math.pow(10, s);
}
var bn = class _bn extends M {
  constructor() {
    super(...arguments), this.min = this.gte, this.max = this.lte, this.step = this.multipleOf;
  }
  _parse(t) {
    if (this._def.coerce && (t.data = Number(t.data)), this._getType(t) !== w.number) {
      const a = this._getOrReturnCtx(t);
      return k(a, {
        code: g.invalid_type,
        expected: w.number,
        received: a.parsedType
      }), D;
    }
    let r;
    const s = new ge();
    for (const a of this._def.checks)
      a.kind === "int" ? B.isInteger(t.data) || (r = this._getOrReturnCtx(t, r), k(r, {
        code: g.invalid_type,
        expected: "integer",
        received: "float",
        message: a.message
      }), s.dirty()) : a.kind === "min" ? (a.inclusive ? t.data < a.value : t.data <= a.value) && (r = this._getOrReturnCtx(t, r), k(r, {
        code: g.too_small,
        minimum: a.value,
        type: "number",
        inclusive: a.inclusive,
        exact: false,
        message: a.message
      }), s.dirty()) : a.kind === "max" ? (a.inclusive ? t.data > a.value : t.data >= a.value) && (r = this._getOrReturnCtx(t, r), k(r, {
        code: g.too_big,
        maximum: a.value,
        type: "number",
        inclusive: a.inclusive,
        exact: false,
        message: a.message
      }), s.dirty()) : a.kind === "multipleOf" ? Rh(t.data, a.value) !== 0 && (r = this._getOrReturnCtx(t, r), k(r, {
        code: g.not_multiple_of,
        multipleOf: a.value,
        message: a.message
      }), s.dirty()) : a.kind === "finite" ? Number.isFinite(t.data) || (r = this._getOrReturnCtx(t, r), k(r, {
        code: g.not_finite,
        message: a.message
      }), s.dirty()) : B.assertNever(a);
    return { status: s.value, value: t.data };
  }
  gte(t, n) {
    return this.setLimit("min", t, true, R.toString(n));
  }
  gt(t, n) {
    return this.setLimit("min", t, false, R.toString(n));
  }
  lte(t, n) {
    return this.setLimit("max", t, true, R.toString(n));
  }
  lt(t, n) {
    return this.setLimit("max", t, false, R.toString(n));
  }
  setLimit(t, n, r, s) {
    return new _bn({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind: t,
          value: n,
          inclusive: r,
          message: R.toString(s)
        }
      ]
    });
  }
  _addCheck(t) {
    return new _bn({
      ...this._def,
      checks: [...this._def.checks, t]
    });
  }
  int(t) {
    return this._addCheck({
      kind: "int",
      message: R.toString(t)
    });
  }
  positive(t) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: false,
      message: R.toString(t)
    });
  }
  negative(t) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: false,
      message: R.toString(t)
    });
  }
  nonpositive(t) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: true,
      message: R.toString(t)
    });
  }
  nonnegative(t) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: true,
      message: R.toString(t)
    });
  }
  multipleOf(t, n) {
    return this._addCheck({
      kind: "multipleOf",
      value: t,
      message: R.toString(n)
    });
  }
  finite(t) {
    return this._addCheck({
      kind: "finite",
      message: R.toString(t)
    });
  }
  safe(t) {
    return this._addCheck({
      kind: "min",
      inclusive: true,
      value: Number.MIN_SAFE_INTEGER,
      message: R.toString(t)
    })._addCheck({
      kind: "max",
      inclusive: true,
      value: Number.MAX_SAFE_INTEGER,
      message: R.toString(t)
    });
  }
  get minValue() {
    let t = null;
    for (const n of this._def.checks)
      n.kind === "min" && (t === null || n.value > t) && (t = n.value);
    return t;
  }
  get maxValue() {
    let t = null;
    for (const n of this._def.checks)
      n.kind === "max" && (t === null || n.value < t) && (t = n.value);
    return t;
  }
  get isInt() {
    return !!this._def.checks.find((t) => t.kind === "int" || t.kind === "multipleOf" && B.isInteger(t.value));
  }
  get isFinite() {
    let t = null, n = null;
    for (const r of this._def.checks) {
      if (r.kind === "finite" || r.kind === "int" || r.kind === "multipleOf")
        return true;
      r.kind === "min" ? (n === null || r.value > n) && (n = r.value) : r.kind === "max" && (t === null || r.value < t) && (t = r.value);
    }
    return Number.isFinite(n) && Number.isFinite(t);
  }
};
bn.create = (e) => new bn({
  checks: [],
  typeName: N.ZodNumber,
  coerce: (e == null ? void 0 : e.coerce) || false,
  ...$(e)
});
var wn = class _wn extends M {
  constructor() {
    super(...arguments), this.min = this.gte, this.max = this.lte;
  }
  _parse(t) {
    if (this._def.coerce && (t.data = BigInt(t.data)), this._getType(t) !== w.bigint) {
      const a = this._getOrReturnCtx(t);
      return k(a, {
        code: g.invalid_type,
        expected: w.bigint,
        received: a.parsedType
      }), D;
    }
    let r;
    const s = new ge();
    for (const a of this._def.checks)
      a.kind === "min" ? (a.inclusive ? t.data < a.value : t.data <= a.value) && (r = this._getOrReturnCtx(t, r), k(r, {
        code: g.too_small,
        type: "bigint",
        minimum: a.value,
        inclusive: a.inclusive,
        message: a.message
      }), s.dirty()) : a.kind === "max" ? (a.inclusive ? t.data > a.value : t.data >= a.value) && (r = this._getOrReturnCtx(t, r), k(r, {
        code: g.too_big,
        type: "bigint",
        maximum: a.value,
        inclusive: a.inclusive,
        message: a.message
      }), s.dirty()) : a.kind === "multipleOf" ? t.data % a.value !== BigInt(0) && (r = this._getOrReturnCtx(t, r), k(r, {
        code: g.not_multiple_of,
        multipleOf: a.value,
        message: a.message
      }), s.dirty()) : B.assertNever(a);
    return { status: s.value, value: t.data };
  }
  gte(t, n) {
    return this.setLimit("min", t, true, R.toString(n));
  }
  gt(t, n) {
    return this.setLimit("min", t, false, R.toString(n));
  }
  lte(t, n) {
    return this.setLimit("max", t, true, R.toString(n));
  }
  lt(t, n) {
    return this.setLimit("max", t, false, R.toString(n));
  }
  setLimit(t, n, r, s) {
    return new _wn({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind: t,
          value: n,
          inclusive: r,
          message: R.toString(s)
        }
      ]
    });
  }
  _addCheck(t) {
    return new _wn({
      ...this._def,
      checks: [...this._def.checks, t]
    });
  }
  positive(t) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: false,
      message: R.toString(t)
    });
  }
  negative(t) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: false,
      message: R.toString(t)
    });
  }
  nonpositive(t) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: true,
      message: R.toString(t)
    });
  }
  nonnegative(t) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: true,
      message: R.toString(t)
    });
  }
  multipleOf(t, n) {
    return this._addCheck({
      kind: "multipleOf",
      value: t,
      message: R.toString(n)
    });
  }
  get minValue() {
    let t = null;
    for (const n of this._def.checks)
      n.kind === "min" && (t === null || n.value > t) && (t = n.value);
    return t;
  }
  get maxValue() {
    let t = null;
    for (const n of this._def.checks)
      n.kind === "max" && (t === null || n.value < t) && (t = n.value);
    return t;
  }
};
wn.create = (e) => {
  var t;
  return new wn({
    checks: [],
    typeName: N.ZodBigInt,
    coerce: (t = e == null ? void 0 : e.coerce) !== null && t !== void 0 ? t : false,
    ...$(e)
  });
};
var Hs = class extends M {
  _parse(t) {
    if (this._def.coerce && (t.data = !!t.data), this._getType(t) !== w.boolean) {
      const r = this._getOrReturnCtx(t);
      return k(r, {
        code: g.invalid_type,
        expected: w.boolean,
        received: r.parsedType
      }), D;
    }
    return ke(t.data);
  }
};
Hs.create = (e) => new Hs({
  typeName: N.ZodBoolean,
  coerce: (e == null ? void 0 : e.coerce) || false,
  ...$(e)
});
var $n = class _$n extends M {
  _parse(t) {
    if (this._def.coerce && (t.data = new Date(t.data)), this._getType(t) !== w.date) {
      const a = this._getOrReturnCtx(t);
      return k(a, {
        code: g.invalid_type,
        expected: w.date,
        received: a.parsedType
      }), D;
    }
    if (isNaN(t.data.getTime())) {
      const a = this._getOrReturnCtx(t);
      return k(a, {
        code: g.invalid_date
      }), D;
    }
    const r = new ge();
    let s;
    for (const a of this._def.checks)
      a.kind === "min" ? t.data.getTime() < a.value && (s = this._getOrReturnCtx(t, s), k(s, {
        code: g.too_small,
        message: a.message,
        inclusive: true,
        exact: false,
        minimum: a.value,
        type: "date"
      }), r.dirty()) : a.kind === "max" ? t.data.getTime() > a.value && (s = this._getOrReturnCtx(t, s), k(s, {
        code: g.too_big,
        message: a.message,
        inclusive: true,
        exact: false,
        maximum: a.value,
        type: "date"
      }), r.dirty()) : B.assertNever(a);
    return {
      status: r.value,
      value: new Date(t.data.getTime())
    };
  }
  _addCheck(t) {
    return new _$n({
      ...this._def,
      checks: [...this._def.checks, t]
    });
  }
  min(t, n) {
    return this._addCheck({
      kind: "min",
      value: t.getTime(),
      message: R.toString(n)
    });
  }
  max(t, n) {
    return this._addCheck({
      kind: "max",
      value: t.getTime(),
      message: R.toString(n)
    });
  }
  get minDate() {
    let t = null;
    for (const n of this._def.checks)
      n.kind === "min" && (t === null || n.value > t) && (t = n.value);
    return t != null ? new Date(t) : null;
  }
  get maxDate() {
    let t = null;
    for (const n of this._def.checks)
      n.kind === "max" && (t === null || n.value < t) && (t = n.value);
    return t != null ? new Date(t) : null;
  }
};
$n.create = (e) => new $n({
  checks: [],
  coerce: (e == null ? void 0 : e.coerce) || false,
  typeName: N.ZodDate,
  ...$(e)
});
var Js = class extends M {
  _parse(t) {
    if (this._getType(t) !== w.symbol) {
      const r = this._getOrReturnCtx(t);
      return k(r, {
        code: g.invalid_type,
        expected: w.symbol,
        received: r.parsedType
      }), D;
    }
    return ke(t.data);
  }
};
Js.create = (e) => new Js({
  typeName: N.ZodSymbol,
  ...$(e)
});
var wr = class extends M {
  _parse(t) {
    if (this._getType(t) !== w.undefined) {
      const r = this._getOrReturnCtx(t);
      return k(r, {
        code: g.invalid_type,
        expected: w.undefined,
        received: r.parsedType
      }), D;
    }
    return ke(t.data);
  }
};
wr.create = (e) => new wr({
  typeName: N.ZodUndefined,
  ...$(e)
});
var xr = class extends M {
  _parse(t) {
    if (this._getType(t) !== w.null) {
      const r = this._getOrReturnCtx(t);
      return k(r, {
        code: g.invalid_type,
        expected: w.null,
        received: r.parsedType
      }), D;
    }
    return ke(t.data);
  }
};
xr.create = (e) => new xr({
  typeName: N.ZodNull,
  ...$(e)
});
var Ys = class extends M {
  constructor() {
    super(...arguments), this._any = true;
  }
  _parse(t) {
    return ke(t.data);
  }
};
Ys.create = (e) => new Ys({
  typeName: N.ZodAny,
  ...$(e)
});
var cn = class extends M {
  constructor() {
    super(...arguments), this._unknown = true;
  }
  _parse(t) {
    return ke(t.data);
  }
};
cn.create = (e) => new cn({
  typeName: N.ZodUnknown,
  ...$(e)
});
var Tt = class extends M {
  _parse(t) {
    const n = this._getOrReturnCtx(t);
    return k(n, {
      code: g.invalid_type,
      expected: w.never,
      received: n.parsedType
    }), D;
  }
};
Tt.create = (e) => new Tt({
  typeName: N.ZodNever,
  ...$(e)
});
var Xs = class extends M {
  _parse(t) {
    if (this._getType(t) !== w.undefined) {
      const r = this._getOrReturnCtx(t);
      return k(r, {
        code: g.invalid_type,
        expected: w.void,
        received: r.parsedType
      }), D;
    }
    return ke(t.data);
  }
};
Xs.create = (e) => new Xs({
  typeName: N.ZodVoid,
  ...$(e)
});
var He = class _He extends M {
  _parse(t) {
    const { ctx: n, status: r } = this._processInputParams(t), s = this._def;
    if (n.parsedType !== w.array)
      return k(n, {
        code: g.invalid_type,
        expected: w.array,
        received: n.parsedType
      }), D;
    if (s.exactLength !== null) {
      const i = n.data.length > s.exactLength.value, o = n.data.length < s.exactLength.value;
      (i || o) && (k(n, {
        code: i ? g.too_big : g.too_small,
        minimum: o ? s.exactLength.value : void 0,
        maximum: i ? s.exactLength.value : void 0,
        type: "array",
        inclusive: true,
        exact: true,
        message: s.exactLength.message
      }), r.dirty());
    }
    if (s.minLength !== null && n.data.length < s.minLength.value && (k(n, {
      code: g.too_small,
      minimum: s.minLength.value,
      type: "array",
      inclusive: true,
      exact: false,
      message: s.minLength.message
    }), r.dirty()), s.maxLength !== null && n.data.length > s.maxLength.value && (k(n, {
      code: g.too_big,
      maximum: s.maxLength.value,
      type: "array",
      inclusive: true,
      exact: false,
      message: s.maxLength.message
    }), r.dirty()), n.common.async)
      return Promise.all([...n.data].map((i, o) => s.type._parseAsync(new Xe(n, i, n.path, o)))).then((i) => ge.mergeArray(r, i));
    const a = [...n.data].map((i, o) => s.type._parseSync(new Xe(n, i, n.path, o)));
    return ge.mergeArray(r, a);
  }
  get element() {
    return this._def.type;
  }
  min(t, n) {
    return new _He({
      ...this._def,
      minLength: { value: t, message: R.toString(n) }
    });
  }
  max(t, n) {
    return new _He({
      ...this._def,
      maxLength: { value: t, message: R.toString(n) }
    });
  }
  length(t, n) {
    return new _He({
      ...this._def,
      exactLength: { value: t, message: R.toString(n) }
    });
  }
  nonempty(t) {
    return this.min(1, t);
  }
};
He.create = (e, t) => new He({
  type: e,
  minLength: null,
  maxLength: null,
  exactLength: null,
  typeName: N.ZodArray,
  ...$(t)
});
function rn(e) {
  if (e instanceof re) {
    const t = {};
    for (const n in e.shape) {
      const r = e.shape[n];
      t[n] = bt.create(rn(r));
    }
    return new re({
      ...e._def,
      shape: () => t
    });
  } else
    return e instanceof He ? new He({
      ...e._def,
      type: rn(e.element)
    }) : e instanceof bt ? bt.create(rn(e.unwrap())) : e instanceof kn ? kn.create(rn(e.unwrap())) : e instanceof lt ? lt.create(e.items.map((t) => rn(t))) : e;
}
var re = class _re extends M {
  constructor() {
    super(...arguments), this._cached = null, this.nonstrict = this.passthrough, this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const t = this._def.shape(), n = B.objectKeys(t);
    return this._cached = { shape: t, keys: n };
  }
  _parse(t) {
    if (this._getType(t) !== w.object) {
      const u = this._getOrReturnCtx(t);
      return k(u, {
        code: g.invalid_type,
        expected: w.object,
        received: u.parsedType
      }), D;
    }
    const { status: r, ctx: s } = this._processInputParams(t), { shape: a, keys: i } = this._getCached(), o = [];
    if (!(this._def.catchall instanceof Tt && this._def.unknownKeys === "strip"))
      for (const u in s.data)
        i.includes(u) || o.push(u);
    const c = [];
    for (const u of i) {
      const d = a[u], h = s.data[u];
      c.push({
        key: { status: "valid", value: u },
        value: d._parse(new Xe(s, h, s.path, u)),
        alwaysSet: u in s.data
      });
    }
    if (this._def.catchall instanceof Tt) {
      const u = this._def.unknownKeys;
      if (u === "passthrough")
        for (const d of o)
          c.push({
            key: { status: "valid", value: d },
            value: { status: "valid", value: s.data[d] }
          });
      else if (u === "strict")
        o.length > 0 && (k(s, {
          code: g.unrecognized_keys,
          keys: o
        }), r.dirty());
      else if (u !== "strip")
        throw new Error("Internal ZodObject error: invalid unknownKeys value.");
    } else {
      const u = this._def.catchall;
      for (const d of o) {
        const h = s.data[d];
        c.push({
          key: { status: "valid", value: d },
          value: u._parse(
            new Xe(s, h, s.path, d)
            //, ctx.child(key), value, getParsedType(value)
          ),
          alwaysSet: d in s.data
        });
      }
    }
    return s.common.async ? Promise.resolve().then(async () => {
      const u = [];
      for (const d of c) {
        const h = await d.key;
        u.push({
          key: h,
          value: await d.value,
          alwaysSet: d.alwaysSet
        });
      }
      return u;
    }).then((u) => ge.mergeObjectSync(r, u)) : ge.mergeObjectSync(r, c);
  }
  get shape() {
    return this._def.shape();
  }
  strict(t) {
    return R.errToObj, new _re({
      ...this._def,
      unknownKeys: "strict",
      ...t !== void 0 ? {
        errorMap: (n, r) => {
          var s, a, i, o;
          const c = (i = (a = (s = this._def).errorMap) === null || a === void 0 ? void 0 : a.call(s, n, r).message) !== null && i !== void 0 ? i : r.defaultError;
          return n.code === "unrecognized_keys" ? {
            message: (o = R.errToObj(t).message) !== null && o !== void 0 ? o : c
          } : {
            message: c
          };
        }
      } : {}
    });
  }
  strip() {
    return new _re({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new _re({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  // const AugmentFactory =
  //   <Def extends ZodObjectDef>(def: Def) =>
  //   <Augmentation extends ZodRawShape>(
  //     augmentation: Augmentation
  //   ): ZodObject<
  //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
  //     Def["unknownKeys"],
  //     Def["catchall"]
  //   > => {
  //     return new ZodObject({
  //       ...def,
  //       shape: () => ({
  //         ...def.shape(),
  //         ...augmentation,
  //       }),
  //     }) as any;
  //   };
  extend(t) {
    return new _re({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...t
      })
    });
  }
  /**
   * Prior to zod@1.0.12 there was a bug in the
   * inferred type of merged objects. Please
   * upgrade if you are experiencing issues.
   */
  merge(t) {
    return new _re({
      unknownKeys: t._def.unknownKeys,
      catchall: t._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...t._def.shape()
      }),
      typeName: N.ZodObject
    });
  }
  // merge<
  //   Incoming extends AnyZodObject,
  //   Augmentation extends Incoming["shape"],
  //   NewOutput extends {
  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
  //       ? Augmentation[k]["_output"]
  //       : k extends keyof Output
  //       ? Output[k]
  //       : never;
  //   },
  //   NewInput extends {
  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
  //       ? Augmentation[k]["_input"]
  //       : k extends keyof Input
  //       ? Input[k]
  //       : never;
  //   }
  // >(
  //   merging: Incoming
  // ): ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"],
  //   NewOutput,
  //   NewInput
  // > {
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  setKey(t, n) {
    return this.augment({ [t]: n });
  }
  // merge<Incoming extends AnyZodObject>(
  //   merging: Incoming
  // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
  // ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"]
  // > {
  //   // const mergedShape = objectUtil.mergeShapes(
  //   //   this._def.shape(),
  //   //   merging._def.shape()
  //   // );
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  catchall(t) {
    return new _re({
      ...this._def,
      catchall: t
    });
  }
  pick(t) {
    const n = {};
    return B.objectKeys(t).forEach((r) => {
      t[r] && this.shape[r] && (n[r] = this.shape[r]);
    }), new _re({
      ...this._def,
      shape: () => n
    });
  }
  omit(t) {
    const n = {};
    return B.objectKeys(this.shape).forEach((r) => {
      t[r] || (n[r] = this.shape[r]);
    }), new _re({
      ...this._def,
      shape: () => n
    });
  }
  /**
   * @deprecated
   */
  deepPartial() {
    return rn(this);
  }
  partial(t) {
    const n = {};
    return B.objectKeys(this.shape).forEach((r) => {
      const s = this.shape[r];
      t && !t[r] ? n[r] = s : n[r] = s.optional();
    }), new _re({
      ...this._def,
      shape: () => n
    });
  }
  required(t) {
    const n = {};
    return B.objectKeys(this.shape).forEach((r) => {
      if (t && !t[r])
        n[r] = this.shape[r];
      else {
        let a = this.shape[r];
        for (; a instanceof bt; )
          a = a._def.innerType;
        n[r] = a;
      }
    }), new _re({
      ...this._def,
      shape: () => n
    });
  }
  keyof() {
    return lu(B.objectKeys(this.shape));
  }
};
re.create = (e, t) => new re({
  shape: () => e,
  unknownKeys: "strip",
  catchall: Tt.create(),
  typeName: N.ZodObject,
  ...$(t)
});
re.strictCreate = (e, t) => new re({
  shape: () => e,
  unknownKeys: "strict",
  catchall: Tt.create(),
  typeName: N.ZodObject,
  ...$(t)
});
re.lazycreate = (e, t) => new re({
  shape: e,
  unknownKeys: "strip",
  catchall: Tt.create(),
  typeName: N.ZodObject,
  ...$(t)
});
var kr = class extends M {
  _parse(t) {
    const { ctx: n } = this._processInputParams(t), r = this._def.options;
    function s(a) {
      for (const o of a)
        if (o.result.status === "valid")
          return o.result;
      for (const o of a)
        if (o.result.status === "dirty")
          return n.common.issues.push(...o.ctx.common.issues), o.result;
      const i = a.map((o) => new Ge(o.ctx.common.issues));
      return k(n, {
        code: g.invalid_union,
        unionErrors: i
      }), D;
    }
    if (n.common.async)
      return Promise.all(r.map(async (a) => {
        const i = {
          ...n,
          common: {
            ...n.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await a._parseAsync({
            data: n.data,
            path: n.path,
            parent: i
          }),
          ctx: i
        };
      })).then(s);
    {
      let a;
      const i = [];
      for (const c of r) {
        const u = {
          ...n,
          common: {
            ...n.common,
            issues: []
          },
          parent: null
        }, d = c._parseSync({
          data: n.data,
          path: n.path,
          parent: u
        });
        if (d.status === "valid")
          return d;
        d.status === "dirty" && !a && (a = { result: d, ctx: u }), u.common.issues.length && i.push(u.common.issues);
      }
      if (a)
        return n.common.issues.push(...a.ctx.common.issues), a.result;
      const o = i.map((c) => new Ge(c));
      return k(n, {
        code: g.invalid_union,
        unionErrors: o
      }), D;
    }
  }
  get options() {
    return this._def.options;
  }
};
kr.create = (e, t) => new kr({
  options: e,
  typeName: N.ZodUnion,
  ...$(t)
});
var cr = (e) => e instanceof Pr ? cr(e.schema) : e instanceof dt ? cr(e.innerType()) : e instanceof Or ? [e.value] : e instanceof Kt ? e.options : e instanceof Er ? Object.keys(e.enum) : e instanceof Cr ? cr(e._def.innerType) : e instanceof wr ? [void 0] : e instanceof xr ? [null] : null;
var Sa = class _Sa extends M {
  _parse(t) {
    const { ctx: n } = this._processInputParams(t);
    if (n.parsedType !== w.object)
      return k(n, {
        code: g.invalid_type,
        expected: w.object,
        received: n.parsedType
      }), D;
    const r = this.discriminator, s = n.data[r], a = this.optionsMap.get(s);
    return a ? n.common.async ? a._parseAsync({
      data: n.data,
      path: n.path,
      parent: n
    }) : a._parseSync({
      data: n.data,
      path: n.path,
      parent: n
    }) : (k(n, {
      code: g.invalid_union_discriminator,
      options: Array.from(this.optionsMap.keys()),
      path: [r]
    }), D);
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  /**
   * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
   * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
   * have a different value for each object in the union.
   * @param discriminator the name of the discriminator property
   * @param types an array of object schemas
   * @param params
   */
  static create(t, n, r) {
    const s = /* @__PURE__ */ new Map();
    for (const a of n) {
      const i = cr(a.shape[t]);
      if (!i)
        throw new Error(`A discriminator value for key \`${t}\` could not be extracted from all schema options`);
      for (const o of i) {
        if (s.has(o))
          throw new Error(`Discriminator property ${String(t)} has duplicate value ${String(o)}`);
        s.set(o, a);
      }
    }
    return new _Sa({
      typeName: N.ZodDiscriminatedUnion,
      discriminator: t,
      options: n,
      optionsMap: s,
      ...$(r)
    });
  }
};
function Qs(e, t) {
  const n = Zt(e), r = Zt(t);
  if (e === t)
    return { valid: true, data: e };
  if (n === w.object && r === w.object) {
    const s = B.objectKeys(t), a = B.objectKeys(e).filter((o) => s.indexOf(o) !== -1), i = { ...e, ...t };
    for (const o of a) {
      const c = Qs(e[o], t[o]);
      if (!c.valid)
        return { valid: false };
      i[o] = c.data;
    }
    return { valid: true, data: i };
  } else if (n === w.array && r === w.array) {
    if (e.length !== t.length)
      return { valid: false };
    const s = [];
    for (let a = 0; a < e.length; a++) {
      const i = e[a], o = t[a], c = Qs(i, o);
      if (!c.valid)
        return { valid: false };
      s.push(c.data);
    }
    return { valid: true, data: s };
  } else
    return n === w.date && r === w.date && +e == +t ? { valid: true, data: e } : { valid: false };
}
var Sr = class extends M {
  _parse(t) {
    const { status: n, ctx: r } = this._processInputParams(t), s = (a, i) => {
      if (Di(a) || Di(i))
        return D;
      const o = Qs(a.value, i.value);
      return o.valid ? ((qi(a) || qi(i)) && n.dirty(), { status: n.value, value: o.data }) : (k(r, {
        code: g.invalid_intersection_types
      }), D);
    };
    return r.common.async ? Promise.all([
      this._def.left._parseAsync({
        data: r.data,
        path: r.path,
        parent: r
      }),
      this._def.right._parseAsync({
        data: r.data,
        path: r.path,
        parent: r
      })
    ]).then(([a, i]) => s(a, i)) : s(this._def.left._parseSync({
      data: r.data,
      path: r.path,
      parent: r
    }), this._def.right._parseSync({
      data: r.data,
      path: r.path,
      parent: r
    }));
  }
};
Sr.create = (e, t, n) => new Sr({
  left: e,
  right: t,
  typeName: N.ZodIntersection,
  ...$(n)
});
var lt = class _lt extends M {
  _parse(t) {
    const { status: n, ctx: r } = this._processInputParams(t);
    if (r.parsedType !== w.array)
      return k(r, {
        code: g.invalid_type,
        expected: w.array,
        received: r.parsedType
      }), D;
    if (r.data.length < this._def.items.length)
      return k(r, {
        code: g.too_small,
        minimum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      }), D;
    !this._def.rest && r.data.length > this._def.items.length && (k(r, {
      code: g.too_big,
      maximum: this._def.items.length,
      inclusive: true,
      exact: false,
      type: "array"
    }), n.dirty());
    const a = [...r.data].map((i, o) => {
      const c = this._def.items[o] || this._def.rest;
      return c ? c._parse(new Xe(r, i, r.path, o)) : null;
    }).filter((i) => !!i);
    return r.common.async ? Promise.all(a).then((i) => ge.mergeArray(n, i)) : ge.mergeArray(n, a);
  }
  get items() {
    return this._def.items;
  }
  rest(t) {
    return new _lt({
      ...this._def,
      rest: t
    });
  }
};
lt.create = (e, t) => {
  if (!Array.isArray(e))
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  return new lt({
    items: e,
    typeName: N.ZodTuple,
    rest: null,
    ...$(t)
  });
};
var Tr = class _Tr extends M {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(t) {
    const { status: n, ctx: r } = this._processInputParams(t);
    if (r.parsedType !== w.object)
      return k(r, {
        code: g.invalid_type,
        expected: w.object,
        received: r.parsedType
      }), D;
    const s = [], a = this._def.keyType, i = this._def.valueType;
    for (const o in r.data)
      s.push({
        key: a._parse(new Xe(r, o, r.path, o)),
        value: i._parse(new Xe(r, r.data[o], r.path, o))
      });
    return r.common.async ? ge.mergeObjectAsync(n, s) : ge.mergeObjectSync(n, s);
  }
  get element() {
    return this._def.valueType;
  }
  static create(t, n, r) {
    return n instanceof M ? new _Tr({
      keyType: t,
      valueType: n,
      typeName: N.ZodRecord,
      ...$(r)
    }) : new _Tr({
      keyType: ut.create(),
      valueType: t,
      typeName: N.ZodRecord,
      ...$(n)
    });
  }
};
var ea = class extends M {
  _parse(t) {
    const { status: n, ctx: r } = this._processInputParams(t);
    if (r.parsedType !== w.map)
      return k(r, {
        code: g.invalid_type,
        expected: w.map,
        received: r.parsedType
      }), D;
    const s = this._def.keyType, a = this._def.valueType, i = [...r.data.entries()].map(([o, c], u) => ({
      key: s._parse(new Xe(r, o, r.path, [u, "key"])),
      value: a._parse(new Xe(r, c, r.path, [u, "value"]))
    }));
    if (r.common.async) {
      const o = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (const c of i) {
          const u = await c.key, d = await c.value;
          if (u.status === "aborted" || d.status === "aborted")
            return D;
          (u.status === "dirty" || d.status === "dirty") && n.dirty(), o.set(u.value, d.value);
        }
        return { status: n.value, value: o };
      });
    } else {
      const o = /* @__PURE__ */ new Map();
      for (const c of i) {
        const u = c.key, d = c.value;
        if (u.status === "aborted" || d.status === "aborted")
          return D;
        (u.status === "dirty" || d.status === "dirty") && n.dirty(), o.set(u.value, d.value);
      }
      return { status: n.value, value: o };
    }
  }
};
ea.create = (e, t, n) => new ea({
  valueType: t,
  keyType: e,
  typeName: N.ZodMap,
  ...$(n)
});
var xn = class _xn extends M {
  _parse(t) {
    const { status: n, ctx: r } = this._processInputParams(t);
    if (r.parsedType !== w.set)
      return k(r, {
        code: g.invalid_type,
        expected: w.set,
        received: r.parsedType
      }), D;
    const s = this._def;
    s.minSize !== null && r.data.size < s.minSize.value && (k(r, {
      code: g.too_small,
      minimum: s.minSize.value,
      type: "set",
      inclusive: true,
      exact: false,
      message: s.minSize.message
    }), n.dirty()), s.maxSize !== null && r.data.size > s.maxSize.value && (k(r, {
      code: g.too_big,
      maximum: s.maxSize.value,
      type: "set",
      inclusive: true,
      exact: false,
      message: s.maxSize.message
    }), n.dirty());
    const a = this._def.valueType;
    function i(c) {
      const u = /* @__PURE__ */ new Set();
      for (const d of c) {
        if (d.status === "aborted")
          return D;
        d.status === "dirty" && n.dirty(), u.add(d.value);
      }
      return { status: n.value, value: u };
    }
    const o = [...r.data.values()].map((c, u) => a._parse(new Xe(r, c, r.path, u)));
    return r.common.async ? Promise.all(o).then((c) => i(c)) : i(o);
  }
  min(t, n) {
    return new _xn({
      ...this._def,
      minSize: { value: t, message: R.toString(n) }
    });
  }
  max(t, n) {
    return new _xn({
      ...this._def,
      maxSize: { value: t, message: R.toString(n) }
    });
  }
  size(t, n) {
    return this.min(t, n).max(t, n);
  }
  nonempty(t) {
    return this.min(1, t);
  }
};
xn.create = (e, t) => new xn({
  valueType: e,
  minSize: null,
  maxSize: null,
  typeName: N.ZodSet,
  ...$(t)
});
var jn = class _jn extends M {
  constructor() {
    super(...arguments), this.validate = this.implement;
  }
  _parse(t) {
    const { ctx: n } = this._processInputParams(t);
    if (n.parsedType !== w.function)
      return k(n, {
        code: g.invalid_type,
        expected: w.function,
        received: n.parsedType
      }), D;
    function r(o, c) {
      return Ws({
        data: o,
        path: n.path,
        errorMaps: [
          n.common.contextualErrorMap,
          n.schemaErrorMap,
          Bs(),
          br
        ].filter((u) => !!u),
        issueData: {
          code: g.invalid_arguments,
          argumentsError: c
        }
      });
    }
    function s(o, c) {
      return Ws({
        data: o,
        path: n.path,
        errorMaps: [
          n.common.contextualErrorMap,
          n.schemaErrorMap,
          Bs(),
          br
        ].filter((u) => !!u),
        issueData: {
          code: g.invalid_return_type,
          returnTypeError: c
        }
      });
    }
    const a = { errorMap: n.common.contextualErrorMap }, i = n.data;
    return this._def.returns instanceof Ln ? ke(async (...o) => {
      const c = new Ge([]), u = await this._def.args.parseAsync(o, a).catch((p) => {
        throw c.addIssue(r(o, p)), c;
      }), d = await i(...u);
      return await this._def.returns._def.type.parseAsync(d, a).catch((p) => {
        throw c.addIssue(s(d, p)), c;
      });
    }) : ke((...o) => {
      const c = this._def.args.safeParse(o, a);
      if (!c.success)
        throw new Ge([r(o, c.error)]);
      const u = i(...c.data), d = this._def.returns.safeParse(u, a);
      if (!d.success)
        throw new Ge([s(u, d.error)]);
      return d.data;
    });
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...t) {
    return new _jn({
      ...this._def,
      args: lt.create(t).rest(cn.create())
    });
  }
  returns(t) {
    return new _jn({
      ...this._def,
      returns: t
    });
  }
  implement(t) {
    return this.parse(t);
  }
  strictImplement(t) {
    return this.parse(t);
  }
  static create(t, n, r) {
    return new _jn({
      args: t || lt.create([]).rest(cn.create()),
      returns: n || cn.create(),
      typeName: N.ZodFunction,
      ...$(r)
    });
  }
};
var Pr = class extends M {
  get schema() {
    return this._def.getter();
  }
  _parse(t) {
    const { ctx: n } = this._processInputParams(t);
    return this._def.getter()._parse({ data: n.data, path: n.path, parent: n });
  }
};
Pr.create = (e, t) => new Pr({
  getter: e,
  typeName: N.ZodLazy,
  ...$(t)
});
var Or = class extends M {
  _parse(t) {
    if (t.data !== this._def.value) {
      const n = this._getOrReturnCtx(t);
      return k(n, {
        received: n.data,
        code: g.invalid_literal,
        expected: this._def.value
      }), D;
    }
    return { status: "valid", value: t.data };
  }
  get value() {
    return this._def.value;
  }
};
Or.create = (e, t) => new Or({
  value: e,
  typeName: N.ZodLiteral,
  ...$(t)
});
function lu(e, t) {
  return new Kt({
    values: e,
    typeName: N.ZodEnum,
    ...$(t)
  });
}
var Kt = class _Kt extends M {
  _parse(t) {
    if (typeof t.data != "string") {
      const n = this._getOrReturnCtx(t), r = this._def.values;
      return k(n, {
        expected: B.joinValues(r),
        received: n.parsedType,
        code: g.invalid_type
      }), D;
    }
    if (this._def.values.indexOf(t.data) === -1) {
      const n = this._getOrReturnCtx(t), r = this._def.values;
      return k(n, {
        received: n.data,
        code: g.invalid_enum_value,
        options: r
      }), D;
    }
    return ke(t.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const t = {};
    for (const n of this._def.values)
      t[n] = n;
    return t;
  }
  get Values() {
    const t = {};
    for (const n of this._def.values)
      t[n] = n;
    return t;
  }
  get Enum() {
    const t = {};
    for (const n of this._def.values)
      t[n] = n;
    return t;
  }
  extract(t) {
    return _Kt.create(t);
  }
  exclude(t) {
    return _Kt.create(this.options.filter((n) => !t.includes(n)));
  }
};
Kt.create = lu;
var Er = class extends M {
  _parse(t) {
    const n = B.getValidEnumValues(this._def.values), r = this._getOrReturnCtx(t);
    if (r.parsedType !== w.string && r.parsedType !== w.number) {
      const s = B.objectValues(n);
      return k(r, {
        expected: B.joinValues(s),
        received: r.parsedType,
        code: g.invalid_type
      }), D;
    }
    if (n.indexOf(t.data) === -1) {
      const s = B.objectValues(n);
      return k(r, {
        received: r.data,
        code: g.invalid_enum_value,
        options: s
      }), D;
    }
    return ke(t.data);
  }
  get enum() {
    return this._def.values;
  }
};
Er.create = (e, t) => new Er({
  values: e,
  typeName: N.ZodNativeEnum,
  ...$(t)
});
var Ln = class extends M {
  unwrap() {
    return this._def.type;
  }
  _parse(t) {
    const { ctx: n } = this._processInputParams(t);
    if (n.parsedType !== w.promise && n.common.async === false)
      return k(n, {
        code: g.invalid_type,
        expected: w.promise,
        received: n.parsedType
      }), D;
    const r = n.parsedType === w.promise ? n.data : Promise.resolve(n.data);
    return ke(r.then((s) => this._def.type.parseAsync(s, {
      path: n.path,
      errorMap: n.common.contextualErrorMap
    })));
  }
};
Ln.create = (e, t) => new Ln({
  type: e,
  typeName: N.ZodPromise,
  ...$(t)
});
var dt = class extends M {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === N.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(t) {
    const { status: n, ctx: r } = this._processInputParams(t), s = this._def.effect || null;
    if (s.type === "preprocess") {
      const i = s.transform(r.data);
      return r.common.async ? Promise.resolve(i).then((o) => this._def.schema._parseAsync({
        data: o,
        path: r.path,
        parent: r
      })) : this._def.schema._parseSync({
        data: i,
        path: r.path,
        parent: r
      });
    }
    const a = {
      addIssue: (i) => {
        k(r, i), i.fatal ? n.abort() : n.dirty();
      },
      get path() {
        return r.path;
      }
    };
    if (a.addIssue = a.addIssue.bind(a), s.type === "refinement") {
      const i = (o) => {
        const c = s.refinement(o, a);
        if (r.common.async)
          return Promise.resolve(c);
        if (c instanceof Promise)
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        return o;
      };
      if (r.common.async === false) {
        const o = this._def.schema._parseSync({
          data: r.data,
          path: r.path,
          parent: r
        });
        return o.status === "aborted" ? D : (o.status === "dirty" && n.dirty(), i(o.value), { status: n.value, value: o.value });
      } else
        return this._def.schema._parseAsync({ data: r.data, path: r.path, parent: r }).then((o) => o.status === "aborted" ? D : (o.status === "dirty" && n.dirty(), i(o.value).then(() => ({ status: n.value, value: o.value }))));
    }
    if (s.type === "transform")
      if (r.common.async === false) {
        const i = this._def.schema._parseSync({
          data: r.data,
          path: r.path,
          parent: r
        });
        if (!Ks(i))
          return i;
        const o = s.transform(i.value, a);
        if (o instanceof Promise)
          throw new Error("Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.");
        return { status: n.value, value: o };
      } else
        return this._def.schema._parseAsync({ data: r.data, path: r.path, parent: r }).then((i) => Ks(i) ? Promise.resolve(s.transform(i.value, a)).then((o) => ({ status: n.value, value: o })) : i);
    B.assertNever(s);
  }
};
dt.create = (e, t, n) => new dt({
  schema: e,
  typeName: N.ZodEffects,
  effect: t,
  ...$(n)
});
dt.createWithPreprocess = (e, t, n) => new dt({
  schema: t,
  effect: { type: "preprocess", transform: e },
  typeName: N.ZodEffects,
  ...$(n)
});
var bt = class extends M {
  _parse(t) {
    return this._getType(t) === w.undefined ? ke(void 0) : this._def.innerType._parse(t);
  }
  unwrap() {
    return this._def.innerType;
  }
};
bt.create = (e, t) => new bt({
  innerType: e,
  typeName: N.ZodOptional,
  ...$(t)
});
var kn = class extends M {
  _parse(t) {
    return this._getType(t) === w.null ? ke(null) : this._def.innerType._parse(t);
  }
  unwrap() {
    return this._def.innerType;
  }
};
kn.create = (e, t) => new kn({
  innerType: e,
  typeName: N.ZodNullable,
  ...$(t)
});
var Cr = class extends M {
  _parse(t) {
    const { ctx: n } = this._processInputParams(t);
    let r = n.data;
    return n.parsedType === w.undefined && (r = this._def.defaultValue()), this._def.innerType._parse({
      data: r,
      path: n.path,
      parent: n
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
};
Cr.create = (e, t) => new Cr({
  innerType: e,
  typeName: N.ZodDefault,
  defaultValue: typeof t.default == "function" ? t.default : () => t.default,
  ...$(t)
});
var ta = class extends M {
  _parse(t) {
    const { ctx: n } = this._processInputParams(t), r = {
      ...n,
      common: {
        ...n.common,
        issues: []
      }
    }, s = this._def.innerType._parse({
      data: r.data,
      path: r.path,
      parent: {
        ...r
      }
    });
    return Gs(s) ? s.then((a) => ({
      status: "valid",
      value: a.status === "valid" ? a.value : this._def.catchValue({
        get error() {
          return new Ge(r.common.issues);
        },
        input: r.data
      })
    })) : {
      status: "valid",
      value: s.status === "valid" ? s.value : this._def.catchValue({
        get error() {
          return new Ge(r.common.issues);
        },
        input: r.data
      })
    };
  }
  removeCatch() {
    return this._def.innerType;
  }
};
ta.create = (e, t) => new ta({
  innerType: e,
  typeName: N.ZodCatch,
  catchValue: typeof t.catch == "function" ? t.catch : () => t.catch,
  ...$(t)
});
var na = class extends M {
  _parse(t) {
    if (this._getType(t) !== w.nan) {
      const r = this._getOrReturnCtx(t);
      return k(r, {
        code: g.invalid_type,
        expected: w.nan,
        received: r.parsedType
      }), D;
    }
    return { status: "valid", value: t.data };
  }
};
na.create = (e) => new na({
  typeName: N.ZodNaN,
  ...$(e)
});
var Ah = class extends M {
  _parse(t) {
    const { ctx: n } = this._processInputParams(t), r = n.data;
    return this._def.type._parse({
      data: r,
      path: n.path,
      parent: n
    });
  }
  unwrap() {
    return this._def.type;
  }
};
var Mr = class _Mr extends M {
  _parse(t) {
    const { status: n, ctx: r } = this._processInputParams(t);
    if (r.common.async)
      return (async () => {
        const a = await this._def.in._parseAsync({
          data: r.data,
          path: r.path,
          parent: r
        });
        return a.status === "aborted" ? D : a.status === "dirty" ? (n.dirty(), _h(a.value)) : this._def.out._parseAsync({
          data: a.value,
          path: r.path,
          parent: r
        });
      })();
    {
      const s = this._def.in._parseSync({
        data: r.data,
        path: r.path,
        parent: r
      });
      return s.status === "aborted" ? D : s.status === "dirty" ? (n.dirty(), {
        status: "dirty",
        value: s.value
      }) : this._def.out._parseSync({
        data: s.value,
        path: r.path,
        parent: r
      });
    }
  }
  static create(t, n) {
    return new _Mr({
      in: t,
      out: n,
      typeName: N.ZodPipeline
    });
  }
};
re.lazycreate;
var N;
(function(e) {
  e.ZodString = "ZodString", e.ZodNumber = "ZodNumber", e.ZodNaN = "ZodNaN", e.ZodBigInt = "ZodBigInt", e.ZodBoolean = "ZodBoolean", e.ZodDate = "ZodDate", e.ZodSymbol = "ZodSymbol", e.ZodUndefined = "ZodUndefined", e.ZodNull = "ZodNull", e.ZodAny = "ZodAny", e.ZodUnknown = "ZodUnknown", e.ZodNever = "ZodNever", e.ZodVoid = "ZodVoid", e.ZodArray = "ZodArray", e.ZodObject = "ZodObject", e.ZodUnion = "ZodUnion", e.ZodDiscriminatedUnion = "ZodDiscriminatedUnion", e.ZodIntersection = "ZodIntersection", e.ZodTuple = "ZodTuple", e.ZodRecord = "ZodRecord", e.ZodMap = "ZodMap", e.ZodSet = "ZodSet", e.ZodFunction = "ZodFunction", e.ZodLazy = "ZodLazy", e.ZodLiteral = "ZodLiteral", e.ZodEnum = "ZodEnum", e.ZodEffects = "ZodEffects", e.ZodNativeEnum = "ZodNativeEnum", e.ZodOptional = "ZodOptional", e.ZodNullable = "ZodNullable", e.ZodDefault = "ZodDefault", e.ZodCatch = "ZodCatch", e.ZodPromise = "ZodPromise", e.ZodBranded = "ZodBranded", e.ZodPipeline = "ZodPipeline";
})(N || (N = {}));
var Ve = ut.create;
bn.create;
na.create;
wn.create;
var ze = Hs.create;
$n.create;
Js.create;
wr.create;
xr.create;
Ys.create;
cn.create;
Tt.create;
Xs.create;
var Dn = He.create;
var ve = re.create;
re.strictCreate;
kr.create;
var du = Sa.create;
Sr.create;
lt.create;
Tr.create;
ea.create;
xn.create;
jn.create;
Pr.create;
var Vn = Or.create;
Kt.create;
Er.create;
Ln.create;
dt.create;
bt.create;
kn.create;
dt.createWithPreprocess;
Mr.create;
var an = {
  persona: "persona",
  account: "account"
};
var Ih = ve({
  challenge: Ve(),
  proof: zn,
  address: Ve(),
  type: Vn(an.persona)
});
var Nh = ve({
  challenge: Ve(),
  proof: zn,
  address: Ve(),
  type: Vn(an.account)
});
var jh = du("type", [
  Ih,
  Nh
]);
var Dh = ve({
  entry: Vn("fullName"),
  fields: Oo
});
var qh = ve({
  entry: Vn("emailAddresses"),
  fields: Dn(Ve())
});
var $h = ve({
  entry: Vn("phoneNumbers"),
  fields: Dn(Ve())
});
var Lh = du("entry", [
  Dh,
  qh,
  $h
]);
var Zh = ve({
  accounts: Dn(Po),
  personaData: Dn(Lh),
  persona: Un.optional(),
  proofs: Dn(jh)
});
var Mh = ve({
  ongoingAccounts: Ke.optional(),
  ongoingPersonaData: vr.optional()
});
var Fh = ve({
  walletData: Zh,
  sharedData: Mh
});
var fu = {
  accounts: [],
  personaData: [],
  proofs: [],
  persona: void 0
};
var zh = () => ({
  state: new Pe({
    walletData: fu,
    sharedData: {}
  }),
  initialized: new Pe(false)
});
function fs(e, t, n, r) {
  function s(a) {
    return a instanceof n ? a : new n(function(i) {
      i(a);
    });
  }
  return new (n || (n = Promise))(function(a, i) {
    function o(d) {
      try {
        u(r.next(d));
      } catch (h) {
        i(h);
      }
    }
    function c(d) {
      try {
        u(r.throw(d));
      } catch (h) {
        i(h);
      }
    }
    function u(d) {
      d.done ? a(d.value) : s(d.value).then(o, c);
    }
    u((r = r.apply(e, t || [])).next());
  });
}
function hs(e, t) {
  var n = { label: 0, sent: function() {
    if (a[0] & 1)
      throw a[1];
    return a[1];
  }, trys: [], ops: [] }, r, s, a, i;
  return i = { next: o(0), throw: o(1), return: o(2) }, typeof Symbol == "function" && (i[Symbol.iterator] = function() {
    return this;
  }), i;
  function o(u) {
    return function(d) {
      return c([u, d]);
    };
  }
  function c(u) {
    if (r)
      throw new TypeError("Generator is already executing.");
    for (; n; )
      try {
        if (r = 1, s && (a = u[0] & 2 ? s.return : u[0] ? s.throw || ((a = s.return) && a.call(s), 0) : s.next) && !(a = a.call(s, u[1])).done)
          return a;
        switch (s = 0, a && (u = [u[0] & 2, a.value]), u[0]) {
          case 0:
          case 1:
            a = u;
            break;
          case 4:
            return n.label++, { value: u[1], done: false };
          case 5:
            n.label++, s = u[1], u = [0];
            continue;
          case 7:
            u = n.ops.pop(), n.trys.pop();
            continue;
          default:
            if (a = n.trys, !(a = a.length > 0 && a[a.length - 1]) && (u[0] === 6 || u[0] === 2)) {
              n = 0;
              continue;
            }
            if (u[0] === 3 && (!a || u[1] > a[0] && u[1] < a[3])) {
              n.label = u[1];
              break;
            }
            if (u[0] === 6 && n.label < a[1]) {
              n.label = a[1], a = u;
              break;
            }
            if (a && n.label < a[2]) {
              n.label = a[2], n.ops.push(u);
              break;
            }
            a[2] && n.ops.pop(), n.trys.pop();
            continue;
        }
        u = t.call(e, n);
      } catch (d) {
        u = [6, d], s = 0;
      } finally {
        r = a = 0;
      }
    if (u[0] & 5)
      throw u[1];
    return { value: u[0] ? u[1] : void 0, done: true };
  }
}
function Rr(e, t) {
  var n = typeof Symbol == "function" && e[Symbol.iterator];
  if (!n)
    return e;
  var r = n.call(e), s, a = [], i;
  try {
    for (; (t === void 0 || t-- > 0) && !(s = r.next()).done; )
      a.push(s.value);
  } catch (o) {
    i = { error: o };
  } finally {
    try {
      s && !s.done && (n = r.return) && n.call(r);
    } finally {
      if (i)
        throw i.error;
    }
  }
  return a;
}
function Ut(e, t, n) {
  if (n || arguments.length === 2)
    for (var r = 0, s = t.length, a; r < s; r++)
      (a || !(r in t)) && (a || (a = Array.prototype.slice.call(t, 0, r)), a[r] = t[r]);
  return e.concat(a || Array.prototype.slice.call(t));
}
var Uh = {
  withStackTrace: false
};
var hu = function(e, t, n) {
  n === void 0 && (n = Uh);
  var r = t.isOk() ? { type: "Ok", value: t.value } : { type: "Err", value: t.error }, s = n.withStackTrace ? new Error().stack : void 0;
  return {
    data: r,
    message: e,
    stack: s
  };
};
var de = (
  /** @class */
  function() {
    function e(t) {
      this._promise = t;
    }
    return e.fromSafePromise = function(t) {
      var n = t.then(function(r) {
        return new yt(r);
      });
      return new e(n);
    }, e.fromPromise = function(t, n) {
      var r = t.then(function(s) {
        return new yt(s);
      }).catch(function(s) {
        return new Mt(n(s));
      });
      return new e(r);
    }, e.combine = function(t) {
      return Bh(t);
    }, e.combineWithAllErrors = function(t) {
      return Wh(t);
    }, e.prototype.map = function(t) {
      var n = this;
      return new e(this._promise.then(function(r) {
        return fs(n, void 0, void 0, function() {
          var s;
          return hs(this, function(a) {
            switch (a.label) {
              case 0:
                return r.isErr() ? [2, new Mt(r.error)] : (s = yt.bind, [4, t(r.value)]);
              case 1:
                return [2, new (s.apply(yt, [void 0, a.sent()]))()];
            }
          });
        });
      }));
    }, e.prototype.mapErr = function(t) {
      var n = this;
      return new e(this._promise.then(function(r) {
        return fs(n, void 0, void 0, function() {
          var s;
          return hs(this, function(a) {
            switch (a.label) {
              case 0:
                return r.isOk() ? [2, new yt(r.value)] : (s = Mt.bind, [4, t(r.error)]);
              case 1:
                return [2, new (s.apply(Mt, [void 0, a.sent()]))()];
            }
          });
        });
      }));
    }, e.prototype.andThen = function(t) {
      return new e(this._promise.then(function(n) {
        if (n.isErr())
          return new Mt(n.error);
        var r = t(n.value);
        return r instanceof e ? r._promise : r;
      }));
    }, e.prototype.orElse = function(t) {
      var n = this;
      return new e(this._promise.then(function(r) {
        return fs(n, void 0, void 0, function() {
          return hs(this, function(s) {
            return r.isErr() ? [2, t(r.error)] : [2, new yt(r.value)];
          });
        });
      }));
    }, e.prototype.match = function(t, n) {
      return this._promise.then(function(r) {
        return r.match(t, n);
      });
    }, e.prototype.unwrapOr = function(t) {
      return this._promise.then(function(n) {
        return n.unwrapOr(t);
      });
    }, e.prototype.then = function(t, n) {
      return this._promise.then(t, n);
    }, e;
  }()
);
var Li = function(e) {
  return new de(Promise.resolve(new yt(e)));
};
var Zi = function(e) {
  return new de(Promise.resolve(new Mt(e)));
};
de.fromPromise;
de.fromSafePromise;
var Vh = function(e) {
  return function(t) {
    return Ut(Ut([], Rr(t), false), [e], false);
  };
};
var pu = function(e) {
  return e.reduce(function(t, n) {
    return t.isOk() ? n.isErr() ? Je(n.error) : t.map(Vh(n.value)) : t;
  }, me([]));
};
var Bh = function(e) {
  return de.fromSafePromise(Promise.all(e)).andThen(pu);
};
var mu = function(e) {
  return e.reduce(function(t, n) {
    return n.isErr() ? t.isErr() ? Je(Ut(Ut([], Rr(t.error), false), [n.error], false)) : Je([n.error]) : t.isErr() ? t : me(Ut(Ut([], Rr(t.value), false), [n.value], false));
  }, me([]));
};
var Wh = function(e) {
  return de.fromSafePromise(Promise.all(e)).andThen(mu);
};
var ra;
(function(e) {
  function t(s, a) {
    return function() {
      for (var i = [], o = 0; o < arguments.length; o++)
        i[o] = arguments[o];
      try {
        var c = s.apply(void 0, Ut([], Rr(i), false));
        return me(c);
      } catch (u) {
        return Je(a ? a(u) : u);
      }
    };
  }
  e.fromThrowable = t;
  function n(s) {
    return pu(s);
  }
  e.combine = n;
  function r(s) {
    return mu(s);
  }
  e.combineWithAllErrors = r;
})(ra || (ra = {}));
var me = function(e) {
  return new yt(e);
};
var Je = function(e) {
  return new Mt(e);
};
var yt = (
  /** @class */
  function() {
    function e(t) {
      this.value = t;
    }
    return e.prototype.isOk = function() {
      return true;
    }, e.prototype.isErr = function() {
      return !this.isOk();
    }, e.prototype.map = function(t) {
      return me(t(this.value));
    }, e.prototype.mapErr = function(t) {
      return me(this.value);
    }, e.prototype.andThen = function(t) {
      return t(this.value);
    }, e.prototype.orElse = function(t) {
      return me(this.value);
    }, e.prototype.asyncAndThen = function(t) {
      return t(this.value);
    }, e.prototype.asyncMap = function(t) {
      return de.fromSafePromise(t(this.value));
    }, e.prototype.unwrapOr = function(t) {
      return this.value;
    }, e.prototype.match = function(t, n) {
      return t(this.value);
    }, e.prototype._unsafeUnwrap = function(t) {
      return this.value;
    }, e.prototype._unsafeUnwrapErr = function(t) {
      throw hu("Called `_unsafeUnwrapErr` on an Ok", this, t);
    }, e;
  }()
);
var Mt = (
  /** @class */
  function() {
    function e(t) {
      this.error = t;
    }
    return e.prototype.isOk = function() {
      return false;
    }, e.prototype.isErr = function() {
      return !this.isOk();
    }, e.prototype.map = function(t) {
      return Je(this.error);
    }, e.prototype.mapErr = function(t) {
      return Je(t(this.error));
    }, e.prototype.andThen = function(t) {
      return Je(this.error);
    }, e.prototype.orElse = function(t) {
      return t(this.error);
    }, e.prototype.asyncAndThen = function(t) {
      return Zi(this.error);
    }, e.prototype.asyncMap = function(t) {
      return Zi(this.error);
    }, e.prototype.unwrapOr = function(t) {
      return t;
    }, e.prototype.match = function(t, n) {
      return n(this.error);
    }, e.prototype._unsafeUnwrap = function(t) {
      throw hu("Called `_unsafeUnwrap` on an Err", this, t);
    }, e.prototype._unsafeUnwrapErr = function(t) {
      return this.error;
    }, e;
  }()
);
ra.fromThrowable;
var ot = (e) => e;
var yu = (e) => {
  try {
    return me(JSON.parse(e));
  } catch (t) {
    return Je(ot(t));
  }
};
var Kh = (e) => {
  try {
    return me(JSON.stringify(e));
  } catch (t) {
    return Je(t);
  }
};
var Gh = (e) => Kh(e).andThen(yu);
var Hh = (e, t, n) => {
  const r = n.logger, s = n.subjects ?? zh(), a = new et(), i = () => t.getData(e).map((h) => (h && (r == null || r.debug("readFromStorage")), h)), o = (h) => t.setData(e, h).map(() => {
    r == null || r.trace("writeToStorage", h);
  }), c = (h) => {
    Gh(h).map((p) => {
      Object.keys(p).length && s.state.next({ ...s.state.value, ...p });
    });
  }, u = () => {
    s.state.next({ walletData: fu, sharedData: {} });
  };
  return (() => i().andThen((h) => de.fromPromise(
    Fh.parseAsync(h),
    (p) => p
  )).mapErr(() => {
    r == null || r.debug("loadedCorruptedStateFromStorage"), u();
  }).map((h) => {
    if (h)
      return r == null || r.debug("initializeStateFromStorage"), s.state.next(h);
    r == null || r.debug("initializeStateFromDefault"), u();
  }))(), a.add(
    s.state.pipe(ct(o)).subscribe()
  ), a.add(
    s.state.pipe(
      rd(1),
      go(),
      ae(() => {
        s.initialized.next(true);
      })
    ).subscribe()
  ), {
    setState: c,
    getState: () => s.state.value,
    state$: s.initialized.pipe(
      xt((h) => h),
      ct(() => s.state)
    ),
    reset: u,
    stateInitialized$: s.initialized.asObservable(),
    destroy: () => {
      u(), a.unsubscribe();
    }
  };
};
var Jh = () => ({
  onConnect: new $e(),
  onDisconnect: new $e(),
  onUpdateSharedData: new $e(),
  loading: new Pe(false),
  connected: new bl(1),
  requestItems: new Pe([]),
  onCancelRequestItem: new $e(),
  accounts: new Pe([]),
  connecting: new Pe(false),
  onShowPopover: new $e(),
  showNotification: new Pe(false),
  personaLabel: new Pe(""),
  personaData: new Pe([]),
  dAppName: new Pe("")
});
var Yh = (e) => {
  import("./connect-button-60b815a3-AITESHBX.js");
  const t = e.subjects || Jh(), n = e.logger, r = (o) => {
    o();
  }, s = e.onConnect || r, a = () => document.querySelector("radix-connect-button"), i = new et();
  return i.add(
    it(document, "onRender").pipe(
      Be(() => a()),
      xt((o) => !!o),
      ct((o) => {
        n == null || n.debug("connectButtonDiscovered"), e.explorer && (o.explorer = e.explorer);
        const c = it(o, "onConnect").pipe(
          ae(() => {
            s((S) => {
              t.onConnect.next(S);
            });
          })
        ), u = it(
          o,
          "onDisconnect"
        ).pipe(
          ae(() => {
            t.onDisconnect.next();
          })
        ), d = it(o, "onDestroy").pipe(
          ae(() => {
            n == null || n.debug("connectButtonRemovedFromDOM");
          })
        ), h = it(
          o,
          "onCancelRequestItem"
        ).pipe(
          ae((S) => {
            const se = S.detail.id;
            n == null || n.debug("onCancelRequestItem", { id: se }), t.onCancelRequestItem.next(se);
          })
        ), p = it(
          o,
          "onUpdateSharedData"
        ).pipe(
          ae(() => {
            n == null || n.debug("onUpdateSharedData"), t.onUpdateSharedData.next();
          })
        ), b = it(
          o,
          "onShowPopover"
        ).pipe(
          ae(() => {
            t.onShowPopover.next();
          })
        ), E = t.loading.pipe(
          ae((S) => o.loading = S)
        ), y = t.connected.pipe(
          ae((S) => {
            o.connected = S;
          })
        ), A = t.requestItems.pipe(
          ae((S) => {
            o.requestItems = S;
          })
        ), O = t.accounts.pipe(
          ae((S) => {
            o.accounts = S;
          })
        ), I = t.personaData.pipe(
          ae((S) => {
            o.personaData = S;
          })
        ), X = t.personaLabel.pipe(
          ae((S) => {
            o.personaLabel = S;
          })
        ), F = t.connecting.pipe(
          ae((S) => {
            o.connecting = S;
          })
        ), ue = t.dAppName.pipe(
          ae((S) => {
            o.dAppName = S;
          })
        ), G = dn(
          t.showNotification,
          t.onShowPopover.pipe(Be(() => false)),
          t.requestItems.pipe(Be((S) => !!S.length))
        ).pipe(
          ae((S) => {
            const se = !o.showPopover && S;
            o.showNotification = se;
          })
        );
        return dn(
          c,
          E,
          y,
          A,
          u,
          h,
          O,
          I,
          X,
          F,
          d,
          p,
          b,
          G,
          ue
        );
      })
    ).subscribe()
  ), {
    onConnect$: t.onConnect.asObservable(),
    onDisconnect$: t.onDisconnect.asObservable(),
    onUpdateSharedData$: t.onUpdateSharedData.asObservable(),
    onCancelRequestItem$: t.onCancelRequestItem.asObservable(),
    setLoading: (o) => t.loading.next(o),
    setConnecting: (o) => t.connecting.next(o),
    setConnected: (o) => t.connected.next(o),
    setRequestItems: (o) => t.requestItems.next(o),
    setAccounts: (o) => t.accounts.next(o),
    setPersonaData: (o) => t.personaData.next(o),
    setPersonaLabel: (o) => t.personaLabel.next(o),
    setDappName: (o) => t.dAppName.next(o),
    destroy: () => {
      i.unsubscribe();
    }
  };
};
var Xh = (e) => {
  const t = e.logger, n = e.requestItemClient, r = e.walletSdk, s = e.gatewayClient, a = (u) => {
    const d = new $e();
    return {
      eventCallback: (h) => {
        d.next(h);
      },
      requestControl: ({ cancelRequest: h }) => {
        vo(
          dn(
            d.pipe(
              xt((p) => p === "receivedByWallet"),
              ae(() => {
                n.patch(u, { showCancel: false });
              })
            ),
            e.onCancelRequestItem$.pipe(
              xt((p) => p === u),
              ct(
                () => h().map(() => n.cancel(u))
              )
            )
          )
        );
      }
    };
  }, i = (u, d) => r.request(u, a(d)).map((h) => (t == null || t.debug("walletSuccessResponse", h), n.updateStatus({ id: d, status: "success" }), h)).mapErr((h) => (t == null || t.debug("walletErrorResponse", h), n.updateStatus({
    id: d,
    status: "fail",
    error: h.error
  }), h)), o = new et();
  return {
    request: i,
    sendTransaction: (u) => {
      const { id: d } = n.add("sendTransaction");
      return r.sendTransaction(u, a(d)).mapErr((h) => (n.updateStatus({
        id: d,
        status: "fail",
        error: h.error
      }), t == null || t.debug("walletErrorResponse", h), h)).andThen(
        ({ transactionIntentHash: h }) => s.pollTransactionStatus(h).map((p) => ({
          transactionIntentHash: h,
          status: p.status
        }))
      ).map((h) => (n.updateStatus({
        id: d,
        status: "success",
        transactionIntentHash: h.transactionIntentHash
      }), t == null || t.debug("walletSuccessResponse", h), h));
    },
    requestItems$: n.items$,
    resetRequestItems: n.reset,
    destroy: () => {
      n.destroy(), r.destroy(), o.unsubscribe();
    }
  };
};
var Qh = Object.defineProperty;
var ep = (e, t, n) => t in e ? Qh(e, t, { enumerable: true, configurable: true, writable: true, value: n }) : e[t] = n;
var Ue = (e, t, n) => (ep(e, typeof t != "symbol" ? t + "" : t, n), n);
var tp = "https://rcnet.radixdlt.com".replace(/\/+$/, "");
var vu = class {
  constructor(t = {}) {
    this.configuration = t;
  }
  set config(t) {
    this.configuration = t;
  }
  get basePath() {
    return this.configuration.basePath != null ? this.configuration.basePath : tp;
  }
  get fetchApi() {
    return this.configuration.fetchApi;
  }
  get middleware() {
    return this.configuration.middleware || [];
  }
  get queryParamsStringify() {
    return this.configuration.queryParamsStringify || gu;
  }
  get username() {
    return this.configuration.username;
  }
  get password() {
    return this.configuration.password;
  }
  get apiKey() {
    const t = this.configuration.apiKey;
    if (t)
      return typeof t == "function" ? t : () => t;
  }
  get accessToken() {
    const t = this.configuration.accessToken;
    if (t)
      return typeof t == "function" ? t : async () => t;
  }
  get headers() {
    return this.configuration.headers;
  }
  get credentials() {
    return this.configuration.credentials;
  }
};
var np = new vu();
var Fr = class {
  constructor(t = np) {
    Ue(this, "middleware"), Ue(this, "fetchApi", async (n, r) => {
      let s = { url: n, init: r };
      for (const i of this.middleware)
        i.pre && (s = await i.pre({
          fetch: this.fetchApi,
          ...s
        }) || s);
      let a;
      try {
        a = await (this.configuration.fetchApi || fetch)(s.url, s.init);
      } catch (i) {
        for (const o of this.middleware)
          o.onError && (a = await o.onError({
            fetch: this.fetchApi,
            url: s.url,
            init: s.init,
            error: i,
            response: a ? a.clone() : void 0
          }) || a);
        if (a === void 0)
          throw i;
      }
      for (const i of this.middleware)
        i.post && (a = await i.post({
          fetch: this.fetchApi,
          url: s.url,
          init: s.init,
          response: a.clone()
        }) || a);
      return a;
    }), this.configuration = t, this.middleware = t.middleware;
  }
  withMiddleware(...t) {
    const n = this.clone();
    return n.middleware = n.middleware.concat(...t), n;
  }
  withPreMiddleware(...t) {
    const n = t.map((r) => ({ pre: r }));
    return this.withMiddleware(...n);
  }
  withPostMiddleware(...t) {
    const n = t.map((r) => ({ post: r }));
    return this.withMiddleware(...n);
  }
  async request(t, n) {
    const { url: r, init: s } = await this.createFetchParams(t, n), a = await this.fetchApi(r, s);
    if (a && a.status >= 200 && a.status < 300)
      return a;
    throw await Ar.from(a);
  }
  async createFetchParams(t, n) {
    let r = this.configuration.basePath + t.path;
    t.query !== void 0 && Object.keys(t.query).length !== 0 && (r += "?" + this.configuration.queryParamsStringify(t.query));
    const s = Object.assign({}, this.configuration.headers, t.headers);
    Object.keys(s).forEach((u) => s[u] === void 0 ? delete s[u] : {});
    const a = typeof n == "function" ? n : async () => n, i = {
      method: t.method,
      headers: s,
      body: t.body,
      credentials: this.configuration.credentials
    }, o = {
      ...i,
      ...await a({
        init: i,
        context: t
      })
    }, c = {
      ...o,
      body: sp(o.body) || o.body instanceof URLSearchParams || rp(o.body) ? o.body : JSON.stringify(o.body)
    };
    return { url: r, init: c };
  }
  clone() {
    const t = this.constructor, n = new t(this.configuration);
    return n.middleware = this.middleware.slice(), n;
  }
};
function rp(e) {
  return typeof Blob < "u" && e instanceof Blob;
}
function sp(e) {
  return typeof FormData < "u" && e instanceof FormData;
}
var Ar = class _Ar extends Error {
  constructor(t, n, r) {
    super(r ? JSON.stringify(r) : "Unknown error occurred"), Ue(this, "name", "ResponseError"), this.fetchResponse = t, this.status = n, this.errorResponse = r;
  }
  static async from(t) {
    const n = t.status;
    try {
      const r = await t.json();
      return new _Ar(t, n, r);
    } catch {
      return new _Ar(t, n, void 0);
    }
  }
};
var ye = class extends Error {
  constructor(t, n) {
    super(n), Ue(this, "name", "RequiredError"), this.field = t;
  }
};
function v(e, t) {
  return e[t] != null;
}
function gu(e, t = "") {
  return Object.keys(e).map((n) => _u(n, e[n], t)).filter((n) => n.length > 0).join("&");
}
function _u(e, t, n = "") {
  const r = n + (n.length ? `[${e}]` : e);
  if (t instanceof Array) {
    const s = t.map((a) => encodeURIComponent(String(a))).join(`&${encodeURIComponent(r)}=`);
    return `${encodeURIComponent(r)}=${s}`;
  }
  if (t instanceof Set) {
    const s = Array.from(t);
    return _u(e, s, n);
  }
  return t instanceof Date ? `${encodeURIComponent(r)}=${encodeURIComponent(t.toISOString())}` : t instanceof Object ? gu(t, r) : `${encodeURIComponent(r)}=${encodeURIComponent(String(t))}`;
}
var le = class {
  constructor(t, n = (r) => r) {
    this.raw = t, this.transformer = n;
  }
  async value() {
    return this.transformer(await this.raw.json());
  }
};
function Ee(e) {
  if (e !== void 0)
    return e === null ? null : {
      state_version: e.state_version,
      timestamp: e.timestamp === void 0 ? void 0 : e.timestamp === null ? null : e.timestamp.toISOString(),
      epoch: e.epoch,
      round: e.round
    };
}
function ap(e) {
  return ip(e);
}
function ip(e, t) {
  return e == null ? e : {
    status: v(e, "status") ? e.status : void 0,
    fee_summary: v(e, "fee_summary") ? e.fee_summary : void 0,
    state_updates: v(e, "state_updates") ? e.state_updates : void 0,
    next_epoch: v(e, "next_epoch") ? e.next_epoch : void 0,
    output: v(e, "output") ? e.output : void 0,
    events: v(e, "events") ? e.events : void 0,
    error_message: v(e, "error_message") ? e.error_message : void 0
  };
}
function Ta(e) {
  return op(e);
}
function op(e, t) {
  return e;
}
function bu(e) {
  return up(e);
}
function up(e, t) {
  return e == null ? e : {
    state_version: e.state_version,
    epoch: e.epoch,
    round: e.round,
    round_timestamp: e.round_timestamp,
    transaction_status: Ta(e.transaction_status),
    payload_hash_hex: v(e, "payload_hash_hex") ? e.payload_hash_hex : void 0,
    intent_hash_hex: v(e, "intent_hash_hex") ? e.intent_hash_hex : void 0,
    fee_paid: v(e, "fee_paid") ? e.fee_paid : void 0,
    affected_global_entities: v(e, "affected_global_entities") ? e.affected_global_entities : void 0,
    confirmed_at: v(e, "confirmed_at") ? e.confirmed_at === null ? null : new Date(e.confirmed_at) : void 0,
    error_message: v(e, "error_message") ? e.error_message : void 0,
    raw_hex: v(e, "raw_hex") ? e.raw_hex : void 0,
    receipt: v(e, "receipt") ? ap(e.receipt) : void 0,
    message_hex: v(e, "message_hex") ? e.message_hex : void 0
  };
}
function Pa(e) {
  return cp(e);
}
function cp(e, t) {
  return e == null ? e : {
    owner: e.owner,
    entries: e.entries
  };
}
function lp(e, t) {
  return e == null ? e : {
    type: e.type,
    values: e.values
  };
}
function dp(e, t) {
  return e == null ? e : {
    type: e.type,
    value: e.value
  };
}
function fp(e, t) {
  return e == null ? e : {
    type: e.type,
    values: e.values
  };
}
function hp(e, t) {
  return e == null ? e : {
    type: e.type,
    value: e.value
  };
}
function pp(e, t) {
  return e == null ? e : {
    type: e.type,
    values: e.values
  };
}
function mp(e, t) {
  return e == null ? e : {
    type: e.type,
    value: e.value
  };
}
function yp(e, t) {
  return e == null ? e : {
    type: e.type,
    values: e.values
  };
}
function vp(e, t) {
  return e == null ? e : {
    type: e.type,
    value: e.value
  };
}
function gp(e, t) {
  return e == null ? e : {
    type: e.type,
    values: e.values
  };
}
function _p(e, t) {
  return e == null ? e : {
    type: e.type,
    value: e.value
  };
}
function bp(e, t) {
  return e == null ? e : {
    type: e.type,
    values: e.values
  };
}
function wp(e, t) {
  return e == null ? e : {
    type: e.type,
    value: e.value
  };
}
function xp(e) {
  return kp(e);
}
function kp(e, t) {
  return e == null ? e : {
    resource_address: e.resource_address,
    non_fungible_id: e.non_fungible_id
  };
}
function Sp(e, t) {
  return e == null ? e : {
    type: e.type,
    values: e.values.map(xp)
  };
}
function Tp(e, t) {
  return e == null ? e : {
    type: e.type,
    resource_address: e.resource_address,
    non_fungible_id: e.non_fungible_id
  };
}
function Pp(e, t) {
  return e == null ? e : {
    type: e.type,
    values: e.values
  };
}
function Op(e, t) {
  return e == null ? e : {
    type: e.type,
    value: e.value
  };
}
function Ep(e, t) {
  return e == null ? e : {
    type: e.type,
    values: e.values
  };
}
function Cp(e, t) {
  return e == null ? e : {
    type: e.type,
    value: e.value
  };
}
function Rp(e, t) {
  return e == null ? e : {
    key_type: e.key_type,
    key_hex: e.key_hex
  };
}
function Ap(e) {
  if (e !== void 0)
    return e === null ? null : {
      key_type: e.key_type,
      key_hex: e.key_hex
    };
}
function Ip(e, t) {
  return e == null ? e : {
    key_type: e.key_type,
    key_hex: e.key_hex
  };
}
function Np(e) {
  if (e !== void 0)
    return e === null ? null : {
      key_type: e.key_type,
      key_hex: e.key_hex
    };
}
function Oa(e) {
  return jp(e);
}
function jp(e, t) {
  if (e == null)
    return e;
  switch (e.key_type) {
    case "EcdsaSecp256k1":
      return { ...Rp(e), key_type: "EcdsaSecp256k1" };
    case "EddsaEd25519":
      return { ...Ip(e), key_type: "EddsaEd25519" };
    default:
      throw new Error(`No variant of PublicKey exists with 'key_type=${e.key_type}'`);
  }
}
function Mi(e) {
  if (e !== void 0) {
    if (e === null)
      return null;
    switch (e.key_type) {
      case "EcdsaSecp256k1":
        return Ap(e);
      case "EddsaEd25519":
        return Np(e);
      default:
        throw new Error(`No variant of PublicKey exists with 'key_type=${e.key_type}'`);
    }
  }
}
function Dp(e, t) {
  return e == null ? e : {
    type: e.type,
    values: e.values.map(Oa)
  };
}
function qp(e, t) {
  return e == null ? e : {
    key_hash_type: e.key_hash_type,
    hash_hex: e.hash_hex
  };
}
function $p(e, t) {
  return e == null ? e : {
    key_hash_type: e.key_hash_type,
    hash_hex: e.hash_hex
  };
}
function wu(e) {
  return Lp(e);
}
function Lp(e, t) {
  if (e == null)
    return e;
  switch (e.key_hash_type) {
    case "EcdsaSecp256k1":
      return { ...qp(e), key_hash_type: "EcdsaSecp256k1" };
    case "EddsaEd25519":
      return { ...$p(e), key_hash_type: "EddsaEd25519" };
    default:
      throw new Error(`No variant of PublicKeyHash exists with 'key_hash_type=${e.key_hash_type}'`);
  }
}
function Zp(e, t) {
  return e == null ? e : {
    type: e.type,
    values: e.values.map(wu)
  };
}
function Mp(e, t) {
  return e == null ? e : {
    type: e.type,
    value: wu(e.value)
  };
}
function Fp(e, t) {
  return e == null ? e : {
    type: e.type,
    value: Oa(e.value)
  };
}
function zp(e, t) {
  return e == null ? e : {
    type: e.type,
    values: e.values
  };
}
function Up(e, t) {
  return e == null ? e : {
    type: e.type,
    value: e.value
  };
}
function Vp(e, t) {
  return e == null ? e : {
    type: e.type,
    values: e.values
  };
}
function Bp(e, t) {
  return e == null ? e : {
    type: e.type,
    value: e.value
  };
}
function Wp(e, t) {
  return e == null ? e : {
    type: e.type,
    values: e.values
  };
}
function Kp(e, t) {
  return e == null ? e : {
    type: e.type,
    value: e.value
  };
}
function Gp(e, t) {
  return e == null ? e : {
    type: e.type,
    value_hex: e.value_hex
  };
}
function Hp(e, t) {
  return e == null ? e : {
    type: e.type,
    value: e.value
  };
}
function Jp(e, t) {
  return e == null ? e : {
    type: e.type,
    values: e.values
  };
}
function Yp(e, t) {
  return e == null ? e : {
    type: e.type,
    value: e.value
  };
}
function Xp(e) {
  return Qp(e);
}
function Qp(e, t) {
  if (e == null)
    return e;
  switch (e.type) {
    case "Bool":
      return { ...dp(e), type: "Bool" };
    case "BoolArray":
      return { ...lp(e), type: "BoolArray" };
    case "Decimal":
      return { ...hp(e), type: "Decimal" };
    case "DecimalArray":
      return { ...fp(e), type: "DecimalArray" };
    case "GlobalAddress":
      return { ...mp(e), type: "GlobalAddress" };
    case "GlobalAddressArray":
      return { ...pp(e), type: "GlobalAddressArray" };
    case "I32":
      return { ...vp(e), type: "I32" };
    case "I32Array":
      return { ...yp(e), type: "I32Array" };
    case "I64":
      return { ..._p(e), type: "I64" };
    case "I64Array":
      return { ...gp(e), type: "I64Array" };
    case "Instant":
      return { ...wp(e), type: "Instant" };
    case "InstantArray":
      return { ...bp(e), type: "InstantArray" };
    case "NonFungibleGlobalId":
      return { ...Tp(e), type: "NonFungibleGlobalId" };
    case "NonFungibleGlobalIdArray":
      return { ...Sp(e), type: "NonFungibleGlobalIdArray" };
    case "NonFungibleLocalId":
      return { ...Op(e), type: "NonFungibleLocalId" };
    case "NonFungibleLocalIdArray":
      return { ...Pp(e), type: "NonFungibleLocalIdArray" };
    case "Origin":
      return { ...Cp(e), type: "Origin" };
    case "OriginArray":
      return { ...Ep(e), type: "OriginArray" };
    case "PublicKey":
      return { ...Fp(e), type: "PublicKey" };
    case "PublicKeyArray":
      return { ...Dp(e), type: "PublicKeyArray" };
    case "PublicKeyHash":
      return { ...Mp(e), type: "PublicKeyHash" };
    case "PublicKeyHashArray":
      return { ...Zp(e), type: "PublicKeyHashArray" };
    case "String":
      return { ...Up(e), type: "String" };
    case "StringArray":
      return { ...zp(e), type: "StringArray" };
    case "U32":
      return { ...Bp(e), type: "U32" };
    case "U32Array":
      return { ...Vp(e), type: "U32Array" };
    case "U64":
      return { ...Kp(e), type: "U64" };
    case "U64Array":
      return { ...Wp(e), type: "U64Array" };
    case "U8":
      return { ...Hp(e), type: "U8" };
    case "U8Array":
      return { ...Gp(e), type: "U8Array" };
    case "Url":
      return { ...Yp(e), type: "Url" };
    case "UrlArray":
      return { ...Jp(e), type: "UrlArray" };
    default:
      throw new Error(`No variant of MetadataTypedValue exists with 'type=${e.type}'`);
  }
}
function em(e) {
  return tm(e);
}
function tm(e, t) {
  return e == null ? e : {
    raw_hex: e.raw_hex,
    raw_json: e.raw_json,
    typed: v(e, "typed") ? Xp(e.typed) : void 0
  };
}
function xu(e) {
  return nm(e);
}
function nm(e, t) {
  return e == null ? e : {
    key: e.key,
    value: em(e.value),
    is_locked: e.is_locked,
    last_updated_at_state_version: e.last_updated_at_state_version
  };
}
function Gt(e) {
  return rm(e);
}
function rm(e, t) {
  return e == null ? e : {
    total_count: v(e, "total_count") ? e.total_count : void 0,
    previous_cursor: v(e, "previous_cursor") ? e.previous_cursor : void 0,
    next_cursor: v(e, "next_cursor") ? e.next_cursor : void 0,
    items: e.items.map(xu)
  };
}
function sm(e, t) {
  return e == null ? e : {
    aggregation_level: e.aggregation_level,
    resource_address: e.resource_address,
    explicit_metadata: v(e, "explicit_metadata") ? Gt(e.explicit_metadata) : void 0,
    amount: e.amount,
    last_updated_at_state_version: e.last_updated_at_state_version
  };
}
function ku(e) {
  return am(e);
}
function am(e, t) {
  return e == null ? e : {
    vault_address: e.vault_address,
    amount: e.amount,
    last_updated_at_state_version: e.last_updated_at_state_version
  };
}
function im(e) {
  return om(e);
}
function om(e, t) {
  return e == null ? e : {
    total_count: v(e, "total_count") ? e.total_count : void 0,
    previous_cursor: v(e, "previous_cursor") ? e.previous_cursor : void 0,
    next_cursor: v(e, "next_cursor") ? e.next_cursor : void 0,
    items: e.items.map(ku)
  };
}
function um(e, t) {
  return e == null ? e : {
    aggregation_level: e.aggregation_level,
    resource_address: e.resource_address,
    explicit_metadata: v(e, "explicit_metadata") ? Gt(e.explicit_metadata) : void 0,
    vaults: im(e.vaults)
  };
}
function Su(e) {
  return cm(e);
}
function cm(e, t) {
  if (e == null)
    return e;
  switch (e.aggregation_level) {
    case "Global":
      return { ...sm(e), aggregation_level: "Global" };
    case "Vault":
      return { ...um(e), aggregation_level: "Vault" };
    default:
      throw new Error(`No variant of FungibleResourcesCollectionItem exists with 'aggregation_level=${e.aggregation_level}'`);
  }
}
function lm(e) {
  return dm(e);
}
function dm(e, t) {
  return e == null ? e : {
    total_count: v(e, "total_count") ? e.total_count : void 0,
    previous_cursor: v(e, "previous_cursor") ? e.previous_cursor : void 0,
    next_cursor: v(e, "next_cursor") ? e.next_cursor : void 0,
    items: e.items.map(Su)
  };
}
var fm = {
  Global: "Global",
  Vault: "Vault"
};
function hm(e) {
  return pm(e);
}
function pm(e, t) {
  return e == null ? e : {
    release_version: e.release_version,
    open_api_schema_version: e.open_api_schema_version,
    image_tag: e.image_tag
  };
}
function _e(e) {
  return mm(e);
}
function mm(e, t) {
  return e == null ? e : {
    network: e.network,
    state_version: e.state_version,
    proposer_round_timestamp: e.proposer_round_timestamp,
    epoch: e.epoch,
    round: e.round
  };
}
function ym(e) {
  return vm(e);
}
function vm(e, t) {
  return e == null ? e : {
    ledger_state: _e(e.ledger_state),
    release_info: hm(e.release_info)
  };
}
function gm(e) {
  return _m(e);
}
function _m(e, t) {
  return e == null ? e : {
    xrd: e.xrd,
    secp256k1_signature_virtual_badge: e.secp256k1_signature_virtual_badge,
    ed25519_signature_virtual_badge: e.ed25519_signature_virtual_badge,
    package_of_direct_caller_virtual_badge: e.package_of_direct_caller_virtual_badge,
    global_caller_virtual_badge: e.global_caller_virtual_badge,
    system_transaction_badge: e.system_transaction_badge,
    package_owner_badge: e.package_owner_badge,
    validator_owner_badge: e.validator_owner_badge,
    account_owner_badge: e.account_owner_badge,
    identity_owner_badge: e.identity_owner_badge,
    package_package: e.package_package,
    resource_package: e.resource_package,
    account_package: e.account_package,
    identity_package: e.identity_package,
    consensus_manager_package: e.consensus_manager_package,
    access_controller_package: e.access_controller_package,
    transaction_processor_package: e.transaction_processor_package,
    metadata_module_package: e.metadata_module_package,
    royalty_module_package: e.royalty_module_package,
    access_rules_package: e.access_rules_package,
    genesis_helper_package: e.genesis_helper_package,
    faucet_package: e.faucet_package,
    consensus_manager: e.consensus_manager,
    genesis_helper: e.genesis_helper,
    faucet: e.faucet
  };
}
function bm(e) {
  return wm(e);
}
function wm(e, t) {
  return e == null ? e : {
    network_id: e.network_id,
    network_name: e.network_name,
    well_known_addresses: gm(e.well_known_addresses)
  };
}
function Tu(e) {
  return xm(e);
}
function xm(e, t) {
  return e;
}
function km(e) {
  return Sm(e);
}
function Sm(e, t) {
  return e == null ? e : {
    total_count: v(e, "total_count") ? e.total_count : void 0,
    previous_cursor: v(e, "previous_cursor") ? e.previous_cursor : void 0,
    next_cursor: v(e, "next_cursor") ? e.next_cursor : void 0,
    items: e.items
  };
}
function Tm(e, t) {
  return e == null ? e : {
    aggregation_level: e.aggregation_level,
    resource_address: e.resource_address,
    explicit_metadata: v(e, "explicit_metadata") ? Gt(e.explicit_metadata) : void 0,
    amount: e.amount,
    last_updated_at_state_version: e.last_updated_at_state_version
  };
}
function Pu(e) {
  return Pm(e);
}
function Pm(e, t) {
  return e == null ? e : {
    total_count: e.total_count,
    previous_cursor: v(e, "previous_cursor") ? e.previous_cursor : void 0,
    next_cursor: v(e, "next_cursor") ? e.next_cursor : void 0,
    items: v(e, "items") ? e.items : void 0,
    vault_address: e.vault_address,
    last_updated_at_state_version: e.last_updated_at_state_version
  };
}
function Om(e) {
  return Em(e);
}
function Em(e, t) {
  return e == null ? e : {
    total_count: v(e, "total_count") ? e.total_count : void 0,
    previous_cursor: v(e, "previous_cursor") ? e.previous_cursor : void 0,
    next_cursor: v(e, "next_cursor") ? e.next_cursor : void 0,
    items: e.items.map(Pu)
  };
}
function Cm(e, t) {
  return e == null ? e : {
    aggregation_level: e.aggregation_level,
    resource_address: e.resource_address,
    explicit_metadata: v(e, "explicit_metadata") ? Gt(e.explicit_metadata) : void 0,
    vaults: Om(e.vaults)
  };
}
function Ou(e) {
  return Rm(e);
}
function Rm(e, t) {
  if (e == null)
    return e;
  switch (e.aggregation_level) {
    case "Global":
      return { ...Tm(e), aggregation_level: "Global" };
    case "Vault":
      return { ...Cm(e), aggregation_level: "Vault" };
    default:
      throw new Error(`No variant of NonFungibleResourcesCollectionItem exists with 'aggregation_level=${e.aggregation_level}'`);
  }
}
function Am(e) {
  return Im(e);
}
function Im(e, t) {
  return e == null ? e : {
    total_count: v(e, "total_count") ? e.total_count : void 0,
    previous_cursor: v(e, "previous_cursor") ? e.previous_cursor : void 0,
    next_cursor: v(e, "next_cursor") ? e.next_cursor : void 0,
    items: e.items.map(Ou)
  };
}
function Nm(e) {
  return jm(e);
}
function jm(e, t) {
  return e;
}
function Dm(e) {
  return qm(e);
}
function qm(e, t) {
  return e == null ? e : {
    raw_hex: e.raw_hex,
    raw_json: e.raw_json
  };
}
function $m(e) {
  if (e !== void 0)
    return e === null ? null : {
      ancestor_identities: e.ancestor_identities,
      component_royalty_vault_balance: e.component_royalty_vault_balance,
      package_royalty_vault_balance: e.package_royalty_vault_balance,
      non_fungible_include_nfids: e.non_fungible_include_nfids,
      explicit_metadata: e.explicit_metadata
    };
}
function Lm(e) {
  if (e !== void 0)
    return e === null ? null : {
      at_ledger_state: Ee(e.at_ledger_state),
      opt_ins: $m(e.opt_ins),
      addresses: e.addresses,
      aggregation_level: e.aggregation_level
    };
}
function Zm(e) {
  return Mm(e);
}
function Mm(e, t) {
  return e == null ? e : {
    parent_address: v(e, "parent_address") ? e.parent_address : void 0,
    owner_address: v(e, "owner_address") ? e.owner_address : void 0,
    global_address: v(e, "global_address") ? e.global_address : void 0
  };
}
function Fm(e, t) {
  return e == null ? e : {
    type: e.type,
    package_address: v(e, "package_address") ? e.package_address : void 0,
    blueprint_name: e.blueprint_name,
    state: v(e, "state") ? e.state : void 0,
    access_rules: Pa(e.access_rules),
    royalty_vault_balance: v(e, "royalty_vault_balance") ? e.royalty_vault_balance : void 0
  };
}
function zm(e, t) {
  return e == null ? e : {
    type: e.type,
    access_rules: Pa(e.access_rules),
    divisibility: e.divisibility,
    total_supply: e.total_supply,
    total_minted: e.total_minted,
    total_burned: e.total_burned
  };
}
function Um(e, t) {
  return e == null ? e : {
    type: e.type
  };
}
function Vm(e, t) {
  return e == null ? e : {
    type: e.type,
    access_rules: Pa(e.access_rules),
    non_fungible_id_type: Tu(e.non_fungible_id_type),
    total_supply: e.total_supply,
    total_minted: e.total_minted,
    total_burned: e.total_burned
  };
}
function Bm(e, t) {
  return e == null ? e : {
    type: e.type
  };
}
function Wm(e) {
  return Km(e);
}
function Km(e, t) {
  return e == null ? e : {
    name: e.name,
    version: e.version,
    definition: e.definition,
    dependant_entities: v(e, "dependant_entities") ? e.dependant_entities : void 0,
    auth_template: v(e, "auth_template") ? e.auth_template : void 0,
    auth_template_is_locked: v(e, "auth_template_is_locked") ? e.auth_template_is_locked : void 0,
    royalty_config: v(e, "royalty_config") ? e.royalty_config : void 0,
    royalty_config_is_locked: v(e, "royalty_config_is_locked") ? e.royalty_config_is_locked : void 0
  };
}
function Gm(e) {
  return Hm(e);
}
function Hm(e, t) {
  return e == null ? e : {
    total_count: v(e, "total_count") ? e.total_count : void 0,
    previous_cursor: v(e, "previous_cursor") ? e.previous_cursor : void 0,
    next_cursor: v(e, "next_cursor") ? e.next_cursor : void 0,
    items: e.items.map(Wm)
  };
}
function Jm(e, t) {
  return e == null ? e : {
    type: e.type,
    vm_type: Nm(e.vm_type),
    code_hash_hex: e.code_hash_hex,
    code_hex: v(e, "code_hex") ? e.code_hex : void 0,
    schema_hash_hex: e.schema_hash_hex,
    schema: v(e, "schema") ? e.schema : void 0,
    royalty_vault_balance: v(e, "royalty_vault_balance") ? e.royalty_vault_balance : void 0,
    blueprints: v(e, "blueprints") ? Gm(e.blueprints) : void 0
  };
}
function Ym(e) {
  return Xm(e);
}
function Xm(e, t) {
  if (e == null)
    return e;
  switch (e.type) {
    case "Component":
      return { ...Fm(e), type: "Component" };
    case "FungibleResource":
      return { ...zm(e), type: "FungibleResource" };
    case "FungibleVault":
      return { ...Um(e), type: "FungibleVault" };
    case "NonFungibleResource":
      return { ...Vm(e), type: "NonFungibleResource" };
    case "NonFungibleVault":
      return { ...Bm(e), type: "NonFungibleVault" };
    case "Package":
      return { ...Jm(e), type: "Package" };
    default:
      throw new Error(`No variant of StateEntityDetailsResponseItemDetails exists with 'type=${e.type}'`);
  }
}
function Qm(e) {
  return ey(e);
}
function ey(e, t) {
  return e == null ? e : {
    address: e.address,
    fungible_resources: v(e, "fungible_resources") ? lm(e.fungible_resources) : void 0,
    non_fungible_resources: v(e, "non_fungible_resources") ? Am(e.non_fungible_resources) : void 0,
    ancestor_identities: v(e, "ancestor_identities") ? Zm(e.ancestor_identities) : void 0,
    metadata: Gt(e.metadata),
    explicit_metadata: v(e, "explicit_metadata") ? Gt(e.explicit_metadata) : void 0,
    details: v(e, "details") ? Ym(e.details) : void 0
  };
}
function ty(e) {
  return ny(e);
}
function ny(e, t) {
  return e == null ? e : {
    ledger_state: _e(e.ledger_state),
    items: e.items.map(Qm)
  };
}
function ry(e) {
  if (e !== void 0)
    return e === null ? null : {
      at_ledger_state: Ee(e.at_ledger_state),
      cursor: e.cursor,
      limit_per_page: e.limit_per_page,
      address: e.address,
      resource_address: e.resource_address
    };
}
function sy(e) {
  return ay(e);
}
function ay(e, t) {
  return e == null ? e : {
    ledger_state: _e(e.ledger_state),
    total_count: v(e, "total_count") ? e.total_count : void 0,
    previous_cursor: v(e, "previous_cursor") ? e.previous_cursor : void 0,
    next_cursor: v(e, "next_cursor") ? e.next_cursor : void 0,
    items: e.items.map(ku),
    address: e.address,
    resource_address: e.resource_address
  };
}
function iy(e) {
  if (e !== void 0)
    return e === null ? null : {
      explicit_metadata: e.explicit_metadata
    };
}
function oy(e) {
  if (e !== void 0)
    return e === null ? null : {
      at_ledger_state: Ee(e.at_ledger_state),
      cursor: e.cursor,
      limit_per_page: e.limit_per_page,
      address: e.address,
      aggregation_level: e.aggregation_level,
      opt_ins: iy(e.opt_ins)
    };
}
function uy(e) {
  return cy(e);
}
function cy(e, t) {
  return e == null ? e : {
    ledger_state: _e(e.ledger_state),
    total_count: v(e, "total_count") ? e.total_count : void 0,
    previous_cursor: v(e, "previous_cursor") ? e.previous_cursor : void 0,
    next_cursor: v(e, "next_cursor") ? e.next_cursor : void 0,
    items: e.items.map(Su),
    address: e.address
  };
}
function ly(e) {
  if (e !== void 0)
    return e === null ? null : {
      at_ledger_state: Ee(e.at_ledger_state),
      cursor: e.cursor,
      limit_per_page: e.limit_per_page,
      address: e.address
    };
}
function dy(e) {
  return fy(e);
}
function fy(e, t) {
  return e == null ? e : {
    ledger_state: _e(e.ledger_state),
    total_count: v(e, "total_count") ? e.total_count : void 0,
    previous_cursor: v(e, "previous_cursor") ? e.previous_cursor : void 0,
    next_cursor: v(e, "next_cursor") ? e.next_cursor : void 0,
    items: e.items.map(xu),
    address: e.address
  };
}
function hy(e) {
  if (e !== void 0)
    return e === null ? null : {
      at_ledger_state: Ee(e.at_ledger_state),
      cursor: e.cursor,
      limit_per_page: e.limit_per_page,
      address: e.address,
      vault_address: e.vault_address,
      resource_address: e.resource_address
    };
}
function py(e) {
  return my(e);
}
function my(e, t) {
  return e == null ? e : {
    ledger_state: _e(e.ledger_state),
    total_count: v(e, "total_count") ? e.total_count : void 0,
    previous_cursor: v(e, "previous_cursor") ? e.previous_cursor : void 0,
    next_cursor: v(e, "next_cursor") ? e.next_cursor : void 0,
    items: e.items,
    address: e.address,
    resource_address: e.resource_address
  };
}
function yy(e) {
  if (e !== void 0)
    return e === null ? null : {
      non_fungible_include_nfids: e.non_fungible_include_nfids
    };
}
function vy(e) {
  if (e !== void 0)
    return e === null ? null : {
      at_ledger_state: Ee(e.at_ledger_state),
      cursor: e.cursor,
      limit_per_page: e.limit_per_page,
      address: e.address,
      resource_address: e.resource_address,
      opt_ins: yy(e.opt_ins)
    };
}
function gy(e) {
  return _y(e);
}
function _y(e, t) {
  return e == null ? e : {
    ledger_state: _e(e.ledger_state),
    total_count: v(e, "total_count") ? e.total_count : void 0,
    previous_cursor: v(e, "previous_cursor") ? e.previous_cursor : void 0,
    next_cursor: v(e, "next_cursor") ? e.next_cursor : void 0,
    items: e.items.map(Pu),
    address: e.address,
    resource_address: e.resource_address
  };
}
function by(e) {
  if (e !== void 0)
    return e === null ? null : {
      non_fungible_include_nfids: e.non_fungible_include_nfids,
      explicit_metadata: e.explicit_metadata
    };
}
function wy(e) {
  if (e !== void 0)
    return e === null ? null : {
      at_ledger_state: Ee(e.at_ledger_state),
      cursor: e.cursor,
      limit_per_page: e.limit_per_page,
      address: e.address,
      aggregation_level: e.aggregation_level,
      opt_ins: by(e.opt_ins)
    };
}
function xy(e) {
  return ky(e);
}
function ky(e, t) {
  return e == null ? e : {
    ledger_state: _e(e.ledger_state),
    total_count: v(e, "total_count") ? e.total_count : void 0,
    previous_cursor: v(e, "previous_cursor") ? e.previous_cursor : void 0,
    next_cursor: v(e, "next_cursor") ? e.next_cursor : void 0,
    items: e.items.map(Ou),
    address: e.address
  };
}
function Sy(e) {
  if (e !== void 0)
    return e === null ? null : {
      at_ledger_state: Ee(e.at_ledger_state),
      resource_address: e.resource_address,
      non_fungible_ids: e.non_fungible_ids
    };
}
function Ty(e) {
  return Py(e);
}
function Py(e, t) {
  return e == null ? e : {
    non_fungible_id: e.non_fungible_id,
    data: Dm(e.data),
    last_updated_at_state_version: e.last_updated_at_state_version
  };
}
function Oy(e) {
  return Ey(e);
}
function Ey(e, t) {
  return e == null ? e : {
    ledger_state: _e(e.ledger_state),
    resource_address: e.resource_address,
    non_fungible_id_type: Tu(e.non_fungible_id_type),
    non_fungible_ids: e.non_fungible_ids.map(Ty)
  };
}
function Cy(e) {
  if (e !== void 0)
    return e === null ? null : {
      at_ledger_state: Ee(e.at_ledger_state),
      cursor: e.cursor,
      limit_per_page: e.limit_per_page,
      resource_address: e.resource_address
    };
}
function Ry(e) {
  return Ay(e);
}
function Ay(e, t) {
  return e == null ? e : {
    ledger_state: _e(e.ledger_state),
    resource_address: e.resource_address,
    non_fungible_ids: km(e.non_fungible_ids)
  };
}
function Iy(e) {
  if (e !== void 0)
    return e === null ? null : {
      at_ledger_state: Ee(e.at_ledger_state),
      cursor: e.cursor
    };
}
function Ny(e) {
  return jy(e);
}
function jy(e, t) {
  return e == null ? e : {
    stake: e.stake,
    stake_percentage: e.stake_percentage,
    key: Oa(e.key)
  };
}
function sr(e) {
  return Dy(e);
}
function Dy(e, t) {
  return e == null ? e : {
    balance: e.balance,
    last_changed_at_state_version: e.last_changed_at_state_version,
    address: e.address
  };
}
function qy(e) {
  return $y(e);
}
function $y(e, t) {
  return e == null ? e : {
    address: e.address,
    stake_vault: sr(e.stake_vault),
    pending_xrd_withdraw_vault: sr(e.pending_xrd_withdraw_vault),
    locked_owner_stake_unit_vault: sr(e.locked_owner_stake_unit_vault),
    pending_owner_stake_unit_unlock_vault: sr(e.pending_owner_stake_unit_unlock_vault),
    state: v(e, "state") ? e.state : void 0,
    active_in_epoch: v(e, "active_in_epoch") ? Ny(e.active_in_epoch) : void 0,
    metadata: Gt(e.metadata)
  };
}
function Ly(e) {
  return Zy(e);
}
function Zy(e, t) {
  return e == null ? e : {
    total_count: v(e, "total_count") ? e.total_count : void 0,
    previous_cursor: v(e, "previous_cursor") ? e.previous_cursor : void 0,
    next_cursor: v(e, "next_cursor") ? e.next_cursor : void 0,
    items: e.items.map(qy)
  };
}
function My(e) {
  return Fy(e);
}
function Fy(e, t) {
  return e == null ? e : {
    ledger_state: _e(e.ledger_state),
    validators: Ly(e.validators)
  };
}
function zy(e) {
  if (e !== void 0)
    return e === null ? null : {
      event: e.event,
      emitter_address: e.emitter_address,
      resource_address: e.resource_address,
      quantity: e.quantity
    };
}
function Eu(e) {
  if (e !== void 0)
    return e === null ? null : {
      raw_hex: e.raw_hex,
      receipt_state_changes: e.receipt_state_changes,
      receipt_fee_summary: e.receipt_fee_summary,
      receipt_events: e.receipt_events,
      affected_global_entities: e.affected_global_entities
    };
}
function Uy(e) {
  if (e !== void 0)
    return e === null ? null : {
      at_ledger_state: Ee(e.at_ledger_state),
      cursor: e.cursor,
      limit_per_page: e.limit_per_page,
      from_ledger_state: Ee(e.from_ledger_state),
      kind_filter: e.kind_filter,
      manifest_accounts_withdrawn_from_filter: e.manifest_accounts_withdrawn_from_filter,
      manifest_accounts_deposited_into_filter: e.manifest_accounts_deposited_into_filter,
      manifest_resources_filter: e.manifest_resources_filter,
      affected_global_entities_filter: e.affected_global_entities_filter,
      events_filter: e.events_filter === void 0 ? void 0 : e.events_filter.map(zy),
      order: e.order,
      opt_ins: Eu(e.opt_ins)
    };
}
function Vy(e) {
  return By(e);
}
function By(e, t) {
  return e == null ? e : {
    ledger_state: _e(e.ledger_state),
    total_count: v(e, "total_count") ? e.total_count : void 0,
    previous_cursor: v(e, "previous_cursor") ? e.previous_cursor : void 0,
    next_cursor: v(e, "next_cursor") ? e.next_cursor : void 0,
    items: e.items.map(bu)
  };
}
function Wy(e) {
  if (e !== void 0)
    return e === null ? null : {
      at_ledger_state: Ee(e.at_ledger_state),
      intent_hash_hex: e.intent_hash_hex,
      opt_ins: Eu(e.opt_ins)
    };
}
function Ky(e) {
  return Gy(e);
}
function Gy(e, t) {
  return e == null ? e : {
    ledger_state: _e(e.ledger_state),
    transaction: bu(e.transaction)
  };
}
function Hy(e) {
  return Jy(e);
}
function Jy(e, t) {
  return e == null ? e : {
    ledger_state: _e(e.ledger_state)
  };
}
function Yy(e) {
  if (e !== void 0)
    return e === null ? null : {
      use_free_credit: e.use_free_credit,
      assume_all_signature_proofs: e.assume_all_signature_proofs,
      skip_epoch_check: e.skip_epoch_check
    };
}
function Xy(e) {
  if (e !== void 0)
    return e === null ? null : {
      manifest: e.manifest,
      blobs_hex: e.blobs_hex,
      start_epoch_inclusive: e.start_epoch_inclusive,
      end_epoch_exclusive: e.end_epoch_exclusive,
      notary_public_key: Mi(e.notary_public_key),
      notary_is_signatory: e.notary_is_signatory,
      tip_percentage: e.tip_percentage,
      nonce: e.nonce,
      signer_public_keys: e.signer_public_keys.map(Mi),
      flags: Yy(e.flags)
    };
}
function Qy(e) {
  return ev(e);
}
function ev(e, t) {
  return e == null ? e : {
    level: e.level,
    message: e.message
  };
}
function tv(e) {
  return nv(e);
}
function nv(e, t) {
  return e == null ? e : {
    encoded_receipt: e.encoded_receipt,
    receipt: e.receipt,
    resource_changes: e.resource_changes,
    logs: e.logs.map(Qy)
  };
}
function rv(e) {
  if (e !== void 0)
    return e === null ? null : {
      intent_hash_hex: e.intent_hash_hex
    };
}
function sv(e) {
  return av(e);
}
function av(e, t) {
  return e == null ? e : {
    payload_hash_hex: e.payload_hash_hex,
    status: Ta(e.status),
    error_message: v(e, "error_message") ? e.error_message : void 0
  };
}
function iv(e) {
  return ov(e);
}
function ov(e, t) {
  return e == null ? e : {
    ledger_state: _e(e.ledger_state),
    status: Ta(e.status),
    known_payloads: e.known_payloads.map(sv),
    error_message: v(e, "error_message") ? e.error_message : void 0
  };
}
function uv(e) {
  if (e !== void 0)
    return e === null ? null : {
      notarized_transaction_hex: e.notarized_transaction_hex
    };
}
function cv(e) {
  return lv(e);
}
function lv(e, t) {
  return e == null ? e : {
    duplicate: e.duplicate
  };
}
var dv = class extends Fr {
  async streamTransactionsRaw(t, n) {
    if (t.streamTransactionsRequest === null || t.streamTransactionsRequest === void 0)
      throw new ye("streamTransactionsRequest", "Required parameter requestParameters.streamTransactionsRequest was null or undefined when calling streamTransactions.");
    const r = {}, s = {};
    s["Content-Type"] = "application/json";
    const a = await this.request({
      path: "/stream/transactions",
      method: "POST",
      headers: s,
      query: r,
      body: Uy(t.streamTransactionsRequest)
    }, n);
    return new le(a, (i) => Vy(i));
  }
  async streamTransactions(t, n) {
    return await (await this.streamTransactionsRaw(t, n)).value();
  }
};
var fv = class extends Fr {
  async entityFungibleResourceVaultPageRaw(t, n) {
    if (t.stateEntityFungibleResourceVaultsPageRequest === null || t.stateEntityFungibleResourceVaultsPageRequest === void 0)
      throw new ye("stateEntityFungibleResourceVaultsPageRequest", "Required parameter requestParameters.stateEntityFungibleResourceVaultsPageRequest was null or undefined when calling entityFungibleResourceVaultPage.");
    const r = {}, s = {};
    s["Content-Type"] = "application/json";
    const a = await this.request({
      path: "/state/entity/page/fungible-vaults/",
      method: "POST",
      headers: s,
      query: r,
      body: ry(t.stateEntityFungibleResourceVaultsPageRequest)
    }, n);
    return new le(a, (i) => sy(i));
  }
  async entityFungibleResourceVaultPage(t, n) {
    return await (await this.entityFungibleResourceVaultPageRaw(t, n)).value();
  }
  async entityFungiblesPageRaw(t, n) {
    if (t.stateEntityFungiblesPageRequest === null || t.stateEntityFungiblesPageRequest === void 0)
      throw new ye("stateEntityFungiblesPageRequest", "Required parameter requestParameters.stateEntityFungiblesPageRequest was null or undefined when calling entityFungiblesPage.");
    const r = {}, s = {};
    s["Content-Type"] = "application/json";
    const a = await this.request({
      path: "/state/entity/page/fungibles/",
      method: "POST",
      headers: s,
      query: r,
      body: oy(t.stateEntityFungiblesPageRequest)
    }, n);
    return new le(a, (i) => uy(i));
  }
  async entityFungiblesPage(t, n) {
    return await (await this.entityFungiblesPageRaw(t, n)).value();
  }
  async entityMetadataPageRaw(t, n) {
    if (t.stateEntityMetadataPageRequest === null || t.stateEntityMetadataPageRequest === void 0)
      throw new ye("stateEntityMetadataPageRequest", "Required parameter requestParameters.stateEntityMetadataPageRequest was null or undefined when calling entityMetadataPage.");
    const r = {}, s = {};
    s["Content-Type"] = "application/json";
    const a = await this.request({
      path: "/state/entity/page/metadata",
      method: "POST",
      headers: s,
      query: r,
      body: ly(t.stateEntityMetadataPageRequest)
    }, n);
    return new le(a, (i) => dy(i));
  }
  async entityMetadataPage(t, n) {
    return await (await this.entityMetadataPageRaw(t, n)).value();
  }
  async entityNonFungibleIdsPageRaw(t, n) {
    if (t.stateEntityNonFungibleIdsPageRequest === null || t.stateEntityNonFungibleIdsPageRequest === void 0)
      throw new ye("stateEntityNonFungibleIdsPageRequest", "Required parameter requestParameters.stateEntityNonFungibleIdsPageRequest was null or undefined when calling entityNonFungibleIdsPage.");
    const r = {}, s = {};
    s["Content-Type"] = "application/json";
    const a = await this.request({
      path: "/state/entity/page/non-fungible-vault/ids",
      method: "POST",
      headers: s,
      query: r,
      body: hy(t.stateEntityNonFungibleIdsPageRequest)
    }, n);
    return new le(a, (i) => py(i));
  }
  async entityNonFungibleIdsPage(t, n) {
    return await (await this.entityNonFungibleIdsPageRaw(t, n)).value();
  }
  async entityNonFungibleResourceVaultPageRaw(t, n) {
    if (t.stateEntityNonFungibleResourceVaultsPageRequest === null || t.stateEntityNonFungibleResourceVaultsPageRequest === void 0)
      throw new ye("stateEntityNonFungibleResourceVaultsPageRequest", "Required parameter requestParameters.stateEntityNonFungibleResourceVaultsPageRequest was null or undefined when calling entityNonFungibleResourceVaultPage.");
    const r = {}, s = {};
    s["Content-Type"] = "application/json";
    const a = await this.request({
      path: "/state/entity/page/non-fungible-vaults/",
      method: "POST",
      headers: s,
      query: r,
      body: vy(t.stateEntityNonFungibleResourceVaultsPageRequest)
    }, n);
    return new le(a, (i) => gy(i));
  }
  async entityNonFungibleResourceVaultPage(t, n) {
    return await (await this.entityNonFungibleResourceVaultPageRaw(t, n)).value();
  }
  async entityNonFungiblesPageRaw(t, n) {
    if (t.stateEntityNonFungiblesPageRequest === null || t.stateEntityNonFungiblesPageRequest === void 0)
      throw new ye("stateEntityNonFungiblesPageRequest", "Required parameter requestParameters.stateEntityNonFungiblesPageRequest was null or undefined when calling entityNonFungiblesPage.");
    const r = {}, s = {};
    s["Content-Type"] = "application/json";
    const a = await this.request({
      path: "/state/entity/page/non-fungibles/",
      method: "POST",
      headers: s,
      query: r,
      body: wy(t.stateEntityNonFungiblesPageRequest)
    }, n);
    return new le(a, (i) => xy(i));
  }
  async entityNonFungiblesPage(t, n) {
    return await (await this.entityNonFungiblesPageRaw(t, n)).value();
  }
  async nonFungibleDataRaw(t, n) {
    if (t.stateNonFungibleDataRequest === null || t.stateNonFungibleDataRequest === void 0)
      throw new ye("stateNonFungibleDataRequest", "Required parameter requestParameters.stateNonFungibleDataRequest was null or undefined when calling nonFungibleData.");
    const r = {}, s = {};
    s["Content-Type"] = "application/json";
    const a = await this.request({
      path: "/state/non-fungible/data",
      method: "POST",
      headers: s,
      query: r,
      body: Sy(t.stateNonFungibleDataRequest)
    }, n);
    return new le(a, (i) => Oy(i));
  }
  async nonFungibleData(t, n) {
    return await (await this.nonFungibleDataRaw(t, n)).value();
  }
  async nonFungibleIdsRaw(t, n) {
    if (t.stateNonFungibleIdsRequest === null || t.stateNonFungibleIdsRequest === void 0)
      throw new ye("stateNonFungibleIdsRequest", "Required parameter requestParameters.stateNonFungibleIdsRequest was null or undefined when calling nonFungibleIds.");
    const r = {}, s = {};
    s["Content-Type"] = "application/json";
    const a = await this.request({
      path: "/state/non-fungible/ids",
      method: "POST",
      headers: s,
      query: r,
      body: Cy(t.stateNonFungibleIdsRequest)
    }, n);
    return new le(a, (i) => Ry(i));
  }
  async nonFungibleIds(t, n) {
    return await (await this.nonFungibleIdsRaw(t, n)).value();
  }
  async stateEntityDetailsRaw(t, n) {
    if (t.stateEntityDetailsRequest === null || t.stateEntityDetailsRequest === void 0)
      throw new ye("stateEntityDetailsRequest", "Required parameter requestParameters.stateEntityDetailsRequest was null or undefined when calling stateEntityDetails.");
    const r = {}, s = {};
    s["Content-Type"] = "application/json";
    const a = await this.request({
      path: "/state/entity/details",
      method: "POST",
      headers: s,
      query: r,
      body: Lm(t.stateEntityDetailsRequest)
    }, n);
    return new le(a, (i) => ty(i));
  }
  async stateEntityDetails(t, n) {
    return await (await this.stateEntityDetailsRaw(t, n)).value();
  }
  async stateValidatorsListRaw(t, n) {
    if (t.stateValidatorsListRequest === null || t.stateValidatorsListRequest === void 0)
      throw new ye("stateValidatorsListRequest", "Required parameter requestParameters.stateValidatorsListRequest was null or undefined when calling stateValidatorsList.");
    const r = {}, s = {};
    s["Content-Type"] = "application/json";
    const a = await this.request({
      path: "/state/validators/list",
      method: "POST",
      headers: s,
      query: r,
      body: Iy(t.stateValidatorsListRequest)
    }, n);
    return new le(a, (i) => My(i));
  }
  async stateValidatorsList(t, n) {
    return await (await this.stateValidatorsListRaw(t, n)).value();
  }
};
var hv = class extends Fr {
  async gatewayStatusRaw(t) {
    const n = {}, r = {}, s = await this.request({
      path: "/status/gateway-status",
      method: "POST",
      headers: r,
      query: n
    }, t);
    return new le(s, (a) => ym(a));
  }
  async gatewayStatus(t) {
    return await (await this.gatewayStatusRaw(t)).value();
  }
  async networkConfigurationRaw(t) {
    const n = {}, r = {}, s = await this.request({
      path: "/status/network-configuration",
      method: "POST",
      headers: r,
      query: n
    }, t);
    return new le(s, (a) => bm(a));
  }
  async networkConfiguration(t) {
    return await (await this.networkConfigurationRaw(t)).value();
  }
};
var pv = class extends Fr {
  async transactionCommittedDetailsRaw(t, n) {
    if (t.transactionCommittedDetailsRequest === null || t.transactionCommittedDetailsRequest === void 0)
      throw new ye("transactionCommittedDetailsRequest", "Required parameter requestParameters.transactionCommittedDetailsRequest was null or undefined when calling transactionCommittedDetails.");
    const r = {}, s = {};
    s["Content-Type"] = "application/json";
    const a = await this.request({
      path: "/transaction/committed-details",
      method: "POST",
      headers: s,
      query: r,
      body: Wy(t.transactionCommittedDetailsRequest)
    }, n);
    return new le(a, (i) => Ky(i));
  }
  async transactionCommittedDetails(t, n) {
    return await (await this.transactionCommittedDetailsRaw(t, n)).value();
  }
  async transactionConstructionRaw(t) {
    const n = {}, r = {}, s = await this.request({
      path: "/transaction/construction",
      method: "POST",
      headers: r,
      query: n
    }, t);
    return new le(s, (a) => Hy(a));
  }
  async transactionConstruction(t) {
    return await (await this.transactionConstructionRaw(t)).value();
  }
  async transactionPreviewRaw(t, n) {
    if (t.transactionPreviewRequest === null || t.transactionPreviewRequest === void 0)
      throw new ye("transactionPreviewRequest", "Required parameter requestParameters.transactionPreviewRequest was null or undefined when calling transactionPreview.");
    const r = {}, s = {};
    s["Content-Type"] = "application/json";
    const a = await this.request({
      path: "/transaction/preview",
      method: "POST",
      headers: s,
      query: r,
      body: Xy(t.transactionPreviewRequest)
    }, n);
    return new le(a, (i) => tv(i));
  }
  async transactionPreview(t, n) {
    return await (await this.transactionPreviewRaw(t, n)).value();
  }
  async transactionStatusRaw(t, n) {
    if (t.transactionStatusRequest === null || t.transactionStatusRequest === void 0)
      throw new ye("transactionStatusRequest", "Required parameter requestParameters.transactionStatusRequest was null or undefined when calling transactionStatus.");
    const r = {}, s = {};
    s["Content-Type"] = "application/json";
    const a = await this.request({
      path: "/transaction/status",
      method: "POST",
      headers: s,
      query: r,
      body: rv(t.transactionStatusRequest)
    }, n);
    return new le(a, (i) => iv(i));
  }
  async transactionStatus(t, n) {
    return await (await this.transactionStatusRaw(t, n)).value();
  }
  async transactionSubmitRaw(t, n) {
    if (t.transactionSubmitRequest === null || t.transactionSubmitRequest === void 0)
      throw new ye("transactionSubmitRequest", "Required parameter requestParameters.transactionSubmitRequest was null or undefined when calling transactionSubmit.");
    const r = {}, s = {};
    s["Content-Type"] = "application/json";
    const a = await this.request({
      path: "/transaction/submit",
      method: "POST",
      headers: s,
      query: r,
      body: uv(t.transactionSubmitRequest)
    }, n);
    return new le(a, (i) => cv(i));
  }
  async transactionSubmit(t, n) {
    return await (await this.transactionSubmitRaw(t, n)).value();
  }
};
var Fi = (e, t) => {
  const n = [];
  for (let r = 0, s = e.length; r < s; r += t)
    n.push(e.slice(r, r + t));
  return n;
};
var ps = async (e, t) => {
  let n = t;
  const r = [];
  do {
    const s = await e(n);
    r.push(...s.items), n = s.next_cursor;
  } while (n);
  return r;
};
var mv = class {
  constructor(t, n) {
    this.innerClient = t, this.configuration = n;
  }
  async getEntityDetailsVaultAggregated(t, n) {
    var r, s, a, i, o;
    const c = Array.isArray(t);
    if (c && t.length === 0)
      return Promise.resolve([]);
    if (c && t.length > this.configuration.maxAddressesCount) {
      const d = Fi(t, this.configuration.maxAddressesCount);
      return Promise.all(
        d.map((h) => this.getEntityDetailsVaultAggregated(h))
      ).then((h) => h.flat());
    }
    const { items: u } = await this.innerClient.stateEntityDetails({
      stateEntityDetailsRequest: {
        addresses: c ? t : [t],
        aggregation_level: fm.Vault,
        opt_ins: {
          ancestor_identities: (r = n == null ? void 0 : n.ancestorIdentities) != null ? r : false,
          component_royalty_vault_balance: (s = n == null ? void 0 : n.componentRoyaltyVaultBalance) != null ? s : false,
          package_royalty_vault_balance: (a = n == null ? void 0 : n.packageRoyaltyVaultBalance) != null ? a : false,
          non_fungible_include_nfids: (i = n == null ? void 0 : n.nonFungibleIncludeNfids) != null ? i : true,
          explicit_metadata: (o = n == null ? void 0 : n.explicitMetadata) != null ? o : []
        }
      }
    });
    return c ? u : u[0];
  }
  async getEntityMetadata(t, n) {
    return this.innerClient.entityMetadataPage({
      stateEntityMetadataPageRequest: {
        address: t,
        cursor: n
      }
    });
  }
  async getAllEntityMetadata(t, n) {
    return ps(
      this.getEntityMetadata.bind(this, t),
      n
    );
  }
  async getValidators(t) {
    return this.innerClient.stateValidatorsList({
      stateValidatorsListRequest: {
        cursor: t || null
      }
    }).then(({ validators: n }) => n);
  }
  async getAllValidators(t) {
    return ps(this.getValidators.bind(this), t);
  }
  async getNonFungibleIds(t, n) {
    return this.innerClient.nonFungibleIds({
      stateNonFungibleIdsRequest: {
        resource_address: t,
        cursor: n
      }
    }).then(({ non_fungible_ids: r }) => r);
  }
  async getAllNonFungibleIds(t, n) {
    return ps(
      this.getNonFungibleIds.bind(this, t),
      n
    );
  }
  async getNonFungibleData(t, n) {
    const r = Array.isArray(n);
    if (r && n.length === 0)
      return Promise.resolve([]);
    if (r && n.length > this.configuration.maxNftIdsCount) {
      const a = Fi(n, this.configuration.maxNftIdsCount);
      return Promise.all(
        a.map((i) => this.getNonFungibleData(t, i))
      ).then((i) => i.flat());
    }
    const { non_fungible_ids: s } = await this.innerClient.nonFungibleData({
      stateNonFungibleDataRequest: {
        resource_address: t,
        non_fungible_ids: r ? n : [n]
      }
    });
    return r ? s : s[0];
  }
};
var yv = class {
  constructor(t) {
    this.innerClient = t;
  }
  getCurrent() {
    return this.innerClient.gatewayStatus();
  }
  getNetworkConfiguration() {
    return this.innerClient.networkConfiguration();
  }
};
var vv = class {
  constructor(t) {
    this.innerClient = t;
  }
  getTransactionsList(t, n) {
    return this.innerClient.streamTransactions({
      streamTransactionsRequest: {
        cursor: n,
        affected_global_entities_filter: t
      }
    });
  }
};
var gv = class {
  constructor(t) {
    this.innerClient = t;
  }
  getStatus(t) {
    return this.innerClient.transactionStatus({
      transactionStatusRequest: {
        intent_hash_hex: t
      }
    });
  }
  getCommittedDetails(t, n) {
    var r, s, a, i, o;
    return this.innerClient.transactionCommittedDetails({
      transactionCommittedDetailsRequest: {
        intent_hash_hex: t,
        opt_ins: {
          raw_hex: (r = n == null ? void 0 : n.rawHex) != null ? r : true,
          receipt_events: (s = n == null ? void 0 : n.receiptEvents) != null ? s : true,
          receipt_fee_summary: (a = n == null ? void 0 : n.receiptFeeSummary) != null ? a : true,
          receipt_state_changes: (i = n == null ? void 0 : n.receiptStateChanges) != null ? i : true,
          affected_global_entities: (o = n == null ? void 0 : n.affectedGlobalEntities) != null ? o : true
        }
      }
    });
  }
};
var _v = 20;
var bv = 29;
var wv = class extends vu {
  constructor(t) {
    super(t), Ue(this, "extendedConfiguration"), this.extendedConfiguration = t;
  }
  get maxAddressesCount() {
    return this.extendedConfiguration.maxAddressesCount || _v;
  }
  get maxNftIdsCount() {
    return this.extendedConfiguration.maxNftIdsCount || bv;
  }
};
var xv = (e) => e ? e.endsWith("/") ? e == null ? void 0 : e.slice(0, -1) : e : "";
var Nt = {
  Mainnet: 1,
  Stokenet: 2,
  Alphanet: 10,
  Betanet: 11,
  Kisharnet: 12,
  Ansharnet: 13,
  Gilganet: 32,
  Enkinet: 33,
  Hammunet: 34,
  Nergalnet: 35,
  Mardunet: 36,
  LocalNet: 240,
  InternalTestNet: 241,
  Simulator: 242,
  RCnetV1: 12,
  RCnetV2: 13
};
var kv = {
  Kisharnet: {
    networkName: "Kisharnet",
    networkId: Nt.Kisharnet,
    gatewayUrl: "https://kisharnet-gateway.radixdlt.com",
    dashboardUrl: "https://kisharnet-dashboard.radixdlt.com"
  },
  Ansharnet: {
    networkName: "Ansharnet",
    networkId: Nt.Ansharnet,
    gatewayUrl: "https://ansharnet-gateway.radixdlt.com",
    dashboardUrl: "https://ansharnet-dashboard.radixdlt.com"
  },
  Gilganet: {
    networkName: "Gilganet",
    networkId: Nt.Gilganet,
    gatewayUrl: "https://gilganet-gateway.radixdlt.com",
    dashboardUrl: ""
  },
  Enkinet: {
    networkName: "Enkinet",
    networkId: Nt.Enkinet,
    gatewayUrl: "https://enkinet-gateway.radixdlt.com",
    dashboardUrl: "https://enkinet-dashboard.rdx-works-main.extratools.works"
  },
  Hammunet: {
    networkName: "Hammunet",
    networkId: Nt.Hammunet,
    gatewayUrl: "https://hammunet-gateway.radixdlt.com:443",
    dashboardUrl: "https://hammunet-dashboard.rdx-works-main.extratools.works"
  },
  RCnetV1: {
    networkName: "RCnetV1",
    networkId: Nt.RCnetV1,
    gatewayUrl: "https://rcnet.radixdlt.com",
    dashboardUrl: "https://rcnet-dashboard.radixdlt.com"
  },
  RCnetV2: {
    networkName: "RCNetV2",
    networkId: Nt.RCnetV2,
    gatewayUrl: "https://ansharnet-gateway.radixdlt.com",
    dashboardUrl: "https://rcnet-v2-dashboard.radixdlt.com"
  }
};
var zi = Object.values(kv).reduce(
  (e, t) => (e[t.networkId] = t, e),
  {}
);
var Ir = class _Ir {
  constructor(t) {
    Ue(this, "state"), Ue(this, "stream"), Ue(this, "status"), Ue(this, "transaction"), Ue(this, "lowLevel"), this.lowLevel = {
      state: new fv(t),
      stream: new dv(t),
      status: new hv(t),
      transaction: new pv(t)
    }, this.state = new mv(this.lowLevel.state, t), this.stream = new vv(this.lowLevel.stream), this.status = new yv(this.lowLevel.status), this.transaction = new gv(this.lowLevel.transaction);
  }
  static initialize(t) {
    const n = _Ir.constructConfiguration(t);
    return new _Ir(n);
  }
  static constructConfiguration(t) {
    var n;
    const r = xv(t == null ? void 0 : t.basePath);
    return new wv({
      ...t,
      basePath: r,
      headers: {
        ...(n = t == null ? void 0 : t.headers) != null ? n : {},
        ...t != null && t.dAppDefinitionAddress ? { "dapp-definition-address": t.dAppDefinitionAddress } : {}
      }
    });
  }
};
var Sv = ({
  basePath: e
}) => {
  const { transaction: t, state: n, status: r } = Ir.initialize({
    basePath: e
  });
  return {
    getTransactionStatus: (d) => de.fromPromise(
      t.getStatus(d),
      ot
    ),
    getTransactionDetails: (d) => de.fromPromise(
      t.getCommittedDetails(d),
      ot
    ),
    getEntityDetails: (d) => de.fromPromise(
      n.getEntityDetailsVaultAggregated(d),
      ot
    ),
    getEntitiesDetails: (d) => de.fromPromise(
      n.getEntityDetailsVaultAggregated(d),
      ot
    ),
    getEntityNonFungibleIds: ({
      accountAddress: d,
      nftAddress: h,
      vaultAddress: p
    }) => de.fromPromise(
      n.innerClient.entityNonFungibleIdsPage({
        stateEntityNonFungibleIdsPageRequest: {
          address: d,
          vault_address: p,
          resource_address: h
        }
      }),
      ot
    ),
    getNetworkConfiguration: () => de.fromPromise(r.getNetworkConfiguration(), ot),
    transactionApi: t,
    stateApi: n,
    statusApi: r
  };
};
var Tv = ({
  maxDelayTime: e = 1e4,
  multiplier: t = 3,
  timeout: n,
  interval: r = 1e3
} = {}) => {
  const s = new $e();
  let a = 0;
  const i = dn(
    Ml(0),
    s.pipe(
      Be(() => (a = a + 1, a))
    )
  ).pipe(
    ct((c) => {
      const u = c * r * t, d = u > e ? e : u;
      return ii(d).pipe(Be(() => me(c)));
    })
  ), o = n ? dn(
    i,
    ii(n).pipe(
      Be(() => Je(mn("failedToPollSubmittedTransaction", "")))
    )
  ) : i;
  return { trigger: s, withBackoff$: o };
};
var Pv = (e) => {
  var n;
  const t = (n = e == null ? void 0 : e.value) == null ? void 0 : n.typed;
  return {
    stringified: t != null && t.value ? (t == null ? void 0 : t.value) || "" : t == null ? void 0 : t.values.join(", ")
  };
};
var Ov = ({
  gatewayApi: e,
  logger: t,
  retryConfig: n
}) => ({ pollTransactionStatus: (s) => {
  const a = Tv(n), i = /* @__PURE__ */ new Set([
    "CommittedSuccess",
    "CommittedFailure",
    "Rejected"
  ]);
  return de.fromPromise(
    vo(
      a.withBackoff$.pipe(
        ct((o) => o.isErr() ? [o] : (t == null || t.debug(`pollingTxStatus retry #${o.value + 1}`), e.getTransactionStatus(s).map((c) => {
          if (i.has(c.status))
            return c;
          a.trigger.next();
        }).mapErr((c) => (t == null || t.debug(c), mn("failedToPollSubmittedTransaction", ""))))),
        xt(
          (o) => o.isOk() && !!o.value || o.isErr()
        ),
        go()
      )
    ),
    (o) => o
  ).andThen((o) => o);
}, gatewayApi: e });
var Ev = () => ({
  onChange: new $e(),
  items: new Pe([])
});
var Cv = (e) => {
  const t = e.logger, n = /* @__PURE__ */ new Map(), r = /* @__PURE__ */ new Set(), s = new et(), a = e.subjects || Ev(), i = (y) => ({
    type: y,
    status: "pending",
    id: crypto.randomUUID(),
    showCancel: true
  }), o = (y) => {
    const A = i(y);
    return n.set(A.id, A), r.add(A.id), a.onChange.next(), t == null || t.trace("addRequestItem", {
      id: A.id,
      status: A.status
    }), A;
  }, c = (y) => {
    n.has(y) && (n.delete(y), r.delete(y), a.onChange.next(), t == null || t.trace("removeRequestItem", y));
  }, u = (y, A) => {
    const O = n.get(y);
    if (O) {
      const I = {
        ...O,
        ...A
      };
      n.set(y, I), a.onChange.next(), t == null || t.trace("patchRequestItemStatus", I);
    }
  }, d = (y) => {
    n.has(y) && (u(y, { status: "fail", error: Nn.canceledByUser }), t == null || t.trace("cancelRequestItem", y));
  }, h = () => {
    n.clear(), r.clear(), a.onChange.next(), t == null || t.trace("resetRequestItems");
  }, p = ({
    id: y,
    status: A,
    error: O,
    transactionIntentHash: I
  }) => {
    const X = n.get(y);
    if (X) {
      const F = {
        ...X,
        status: A
      };
      F.status === "fail" && (F.error = O), F.status === "success" && F.type === "sendTransaction" && (F.transactionIntentHash = I), n.set(y, F), a.onChange.next(), t == null || t.trace("updateRequestItemStatus", F);
    }
  }, b = () => [...r], E = () => b().map((y) => ({ id: y, ...n.get(y) })).filter((y) => !!y);
  return s.add(
    a.onChange.pipe(
      Be(() => E()),
      ae((y) => a.items.next(y))
    ).subscribe()
  ), {
    add: o,
    remove: c,
    cancel: d,
    updateStatus: p,
    patch: u,
    reset: h,
    destroy: () => {
      s.unsubscribe();
    },
    items$: a.items.asObservable(),
    subjects: a
  };
};
var Rv = () => {
  const e = (n) => new Promise((r, s) => {
    try {
      const a = localStorage.getItem(n);
      return r(a || void 0);
    } catch (a) {
      return s(a);
    }
  }), t = (n, r) => new Promise((s, a) => {
    try {
      return localStorage.setItem(n, JSON.stringify(r)), s();
    } catch (i) {
      return a(i);
    }
  });
  return {
    getData: (n) => de.fromPromise(e(n), ot).andThen(
      (r) => r ? yu(r) : me(void 0)
    ),
    setData: (n, r) => de.fromPromise(t(n, r), ot)
  };
};
var Cu = Symbol.for("immer-nothing");
var Ui = Symbol.for("immer-draftable");
var Ce = Symbol.for("immer-state");
var Av = true ? [
  // All error codes, starting by 0:
  function(e) {
    return `The plugin for '${e}' has not been loaded into Immer. To enable the plugin, import and call \`enable${e}()\` when initializing your application.`;
  },
  function(e) {
    return `produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '${e}'`;
  },
  "This object has been frozen and should not be mutated",
  function(e) {
    return "Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? " + e;
  },
  "An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.",
  "Immer forbids circular references",
  "The first or second argument to `produce` must be a function",
  "The third argument to `produce` must be a function or undefined",
  "First argument to `createDraft` must be a plain object, an array, or an immerable object",
  "First argument to `finishDraft` must be a draft returned by `createDraft`",
  function(e) {
    return `'current' expects a draft, got: ${e}`;
  },
  "Object.defineProperty() cannot be used on an Immer draft",
  "Object.setPrototypeOf() cannot be used on an Immer draft",
  "Immer only supports deleting array indices",
  "Immer only supports setting array indices and the 'length' property",
  function(e) {
    return `'original' expects a draft, got: ${e}`;
  }
  // Note: if more errors are added, the errorOffset in Patches.ts should be increased
  // See Patches.ts for additional errors
] : [];
function we(e, ...t) {
  if (true) {
    const n = Av[e], r = typeof n == "function" ? n.apply(null, t) : n;
    throw new Error(`[Immer] ${r}`);
  }
  throw new Error(
    `[Immer] minified error nr: ${e}. Full error at: https://bit.ly/3cXEKWf`
  );
}
var Sn = Object.getPrototypeOf;
function Tn(e) {
  return !!e && !!e[Ce];
}
function Ht(e) {
  var t;
  return e ? Ru(e) || Array.isArray(e) || !!e[Ui] || !!((t = e.constructor) != null && t[Ui]) || Ur(e) || Vr(e) : false;
}
var Iv = Object.prototype.constructor.toString();
function Ru(e) {
  if (!e || typeof e != "object")
    return false;
  const t = Sn(e);
  if (t === null)
    return true;
  const n = Object.hasOwnProperty.call(t, "constructor") && t.constructor;
  return n === Object ? true : typeof n == "function" && Function.toString.call(n) === Iv;
}
function Zn(e, t) {
  zr(e) === 0 ? Object.entries(e).forEach(([n, r]) => {
    t(n, r, e);
  }) : e.forEach((n, r) => t(r, n, e));
}
function zr(e) {
  const t = e[Ce];
  return t ? t.type_ : Array.isArray(e) ? 1 : Ur(e) ? 2 : Vr(e) ? 3 : 0;
}
function sa(e, t) {
  return zr(e) === 2 ? e.has(t) : Object.prototype.hasOwnProperty.call(e, t);
}
function Au(e, t, n) {
  const r = zr(e);
  r === 2 ? e.set(t, n) : r === 3 ? e.add(n) : e[t] = n;
}
function Nv(e, t) {
  return e === t ? e !== 0 || 1 / e === 1 / t : e !== e && t !== t;
}
function Ur(e) {
  return e instanceof Map;
}
function Vr(e) {
  return e instanceof Set;
}
function qt(e) {
  return e.copy_ || e.base_;
}
function aa(e, t) {
  if (Ur(e))
    return new Map(e);
  if (Vr(e))
    return new Set(e);
  if (Array.isArray(e))
    return Array.prototype.slice.call(e);
  if (!t && Ru(e))
    return Sn(e) ? { ...e } : Object.assign(/* @__PURE__ */ Object.create(null), e);
  const n = Object.getOwnPropertyDescriptors(e);
  delete n[Ce];
  let r = Reflect.ownKeys(n);
  for (let s = 0; s < r.length; s++) {
    const a = r[s], i = n[a];
    i.writable === false && (i.writable = true, i.configurable = true), (i.get || i.set) && (n[a] = {
      configurable: true,
      writable: true,
      // could live with !!desc.set as well here...
      enumerable: i.enumerable,
      value: e[a]
    });
  }
  return Object.create(Sn(e), n);
}
function Ea(e, t = false) {
  return Br(e) || Tn(e) || !Ht(e) || (zr(e) > 1 && (e.set = e.add = e.clear = e.delete = jv), Object.freeze(e), t && Zn(e, (n, r) => Ea(r, true))), e;
}
function jv() {
  we(2);
}
function Br(e) {
  return Object.isFrozen(e);
}
var Dv = {};
function Jt(e) {
  const t = Dv[e];
  return t || we(0, e), t;
}
var Mn;
function Iu() {
  return Mn;
}
function qv(e, t) {
  return {
    drafts_: [],
    parent_: e,
    immer_: t,
    // Whenever the modified draft contains a draft from another scope, we
    // need to prevent auto-freezing so the unowned draft can be finalized.
    canAutoFreeze_: true,
    unfinalizedDrafts_: 0
  };
}
function Vi(e, t) {
  t && (Jt("Patches"), e.patches_ = [], e.inversePatches_ = [], e.patchListener_ = t);
}
function ia(e) {
  oa(e), e.drafts_.forEach($v), e.drafts_ = null;
}
function oa(e) {
  e === Mn && (Mn = e.parent_);
}
function Bi(e) {
  return Mn = qv(Mn, e);
}
function $v(e) {
  const t = e[Ce];
  t.type_ === 0 || t.type_ === 1 ? t.revoke_() : t.revoked_ = true;
}
function Wi(e, t) {
  t.unfinalizedDrafts_ = t.drafts_.length;
  const n = t.drafts_[0];
  return e !== void 0 && e !== n ? (n[Ce].modified_ && (ia(t), we(4)), Ht(e) && (e = Nr(t, e), t.parent_ || jr(t, e)), t.patches_ && Jt("Patches").generateReplacementPatches_(
    n[Ce].base_,
    e,
    t.patches_,
    t.inversePatches_
  )) : e = Nr(t, n, []), ia(t), t.patches_ && t.patchListener_(t.patches_, t.inversePatches_), e !== Cu ? e : void 0;
}
function Nr(e, t, n) {
  if (Br(t))
    return t;
  const r = t[Ce];
  if (!r)
    return Zn(
      t,
      (s, a) => Ki(e, r, t, s, a, n)
    ), t;
  if (r.scope_ !== e)
    return t;
  if (!r.modified_)
    return jr(e, r.base_, true), r.base_;
  if (!r.finalized_) {
    r.finalized_ = true, r.scope_.unfinalizedDrafts_--;
    const s = r.copy_;
    let a = s, i = false;
    r.type_ === 3 && (a = new Set(s), s.clear(), i = true), Zn(
      a,
      (o, c) => Ki(e, r, s, o, c, n, i)
    ), jr(e, s, false), n && e.patches_ && Jt("Patches").generatePatches_(
      r,
      n,
      e.patches_,
      e.inversePatches_
    );
  }
  return r.copy_;
}
function Ki(e, t, n, r, s, a, i) {
  if (s === n && we(5), Tn(s)) {
    const o = a && t && t.type_ !== 3 && // Set objects are atomic since they have no keys.
    !sa(t.assigned_, r) ? a.concat(r) : void 0, c = Nr(e, s, o);
    if (Au(n, r, c), Tn(c))
      e.canAutoFreeze_ = false;
    else
      return;
  } else
    i && n.add(s);
  if (Ht(s) && !Br(s)) {
    if (!e.immer_.autoFreeze_ && e.unfinalizedDrafts_ < 1)
      return;
    Nr(e, s), (!t || !t.scope_.parent_) && jr(e, s);
  }
}
function jr(e, t, n = false) {
  !e.parent_ && e.immer_.autoFreeze_ && e.canAutoFreeze_ && Ea(t, n);
}
function Lv(e, t) {
  const n = Array.isArray(e), r = {
    type_: n ? 1 : 0,
    // Track which produce call this is associated with.
    scope_: t ? t.scope_ : Iu(),
    // True for both shallow and deep changes.
    modified_: false,
    // Used during finalization.
    finalized_: false,
    // Track which properties have been assigned (true) or deleted (false).
    assigned_: {},
    // The parent draft state.
    parent_: t,
    // The base state.
    base_: e,
    // The base proxy.
    draft_: null,
    // set below
    // The base copy with any updated values.
    copy_: null,
    // Called by the `produce` function.
    revoke_: null,
    isManual_: false
  };
  let s = r, a = Ca;
  n && (s = [r], a = Fn);
  const { revoke: i, proxy: o } = Proxy.revocable(s, a);
  return r.draft_ = o, r.revoke_ = i, o;
}
var Ca = {
  get(e, t) {
    if (t === Ce)
      return e;
    const n = qt(e);
    if (!sa(n, t))
      return Zv(e, n, t);
    const r = n[t];
    return e.finalized_ || !Ht(r) ? r : r === ms(e.base_, t) ? (ys(e), e.copy_[t] = ca(r, e)) : r;
  },
  has(e, t) {
    return t in qt(e);
  },
  ownKeys(e) {
    return Reflect.ownKeys(qt(e));
  },
  set(e, t, n) {
    const r = Nu(qt(e), t);
    if (r != null && r.set)
      return r.set.call(e.draft_, n), true;
    if (!e.modified_) {
      const s = ms(qt(e), t), a = s == null ? void 0 : s[Ce];
      if (a && a.base_ === n)
        return e.copy_[t] = n, e.assigned_[t] = false, true;
      if (Nv(n, s) && (n !== void 0 || sa(e.base_, t)))
        return true;
      ys(e), ua(e);
    }
    return e.copy_[t] === n && // special case: handle new props with value 'undefined'
    (n !== void 0 || t in e.copy_) || // special case: NaN
    Number.isNaN(n) && Number.isNaN(e.copy_[t]) || (e.copy_[t] = n, e.assigned_[t] = true), true;
  },
  deleteProperty(e, t) {
    return ms(e.base_, t) !== void 0 || t in e.base_ ? (e.assigned_[t] = false, ys(e), ua(e)) : delete e.assigned_[t], e.copy_ && delete e.copy_[t], true;
  },
  // Note: We never coerce `desc.value` into an Immer draft, because we can't make
  // the same guarantee in ES5 mode.
  getOwnPropertyDescriptor(e, t) {
    const n = qt(e), r = Reflect.getOwnPropertyDescriptor(n, t);
    return r && {
      writable: true,
      configurable: e.type_ !== 1 || t !== "length",
      enumerable: r.enumerable,
      value: n[t]
    };
  },
  defineProperty() {
    we(11);
  },
  getPrototypeOf(e) {
    return Sn(e.base_);
  },
  setPrototypeOf() {
    we(12);
  }
};
var Fn = {};
Zn(Ca, (e, t) => {
  Fn[e] = function() {
    return arguments[0] = arguments[0][0], t.apply(this, arguments);
  };
});
Fn.deleteProperty = function(e, t) {
  return isNaN(parseInt(t)) && we(13), Fn.set.call(this, e, t, void 0);
};
Fn.set = function(e, t, n) {
  return t !== "length" && isNaN(parseInt(t)) && we(14), Ca.set.call(this, e[0], t, n, e[0]);
};
function ms(e, t) {
  const n = e[Ce];
  return (n ? qt(n) : e)[t];
}
function Zv(e, t, n) {
  var s;
  const r = Nu(t, n);
  return r ? "value" in r ? r.value : (
    // This is a very special case, if the prop is a getter defined by the
    // prototype, we should invoke it with the draft as context!
    (s = r.get) == null ? void 0 : s.call(e.draft_)
  ) : void 0;
}
function Nu(e, t) {
  if (!(t in e))
    return;
  let n = Sn(e);
  for (; n; ) {
    const r = Object.getOwnPropertyDescriptor(n, t);
    if (r)
      return r;
    n = Sn(n);
  }
}
function ua(e) {
  e.modified_ || (e.modified_ = true, e.parent_ && ua(e.parent_));
}
function ys(e) {
  e.copy_ || (e.copy_ = aa(
    e.base_,
    e.scope_.immer_.useStrictShallowCopy_
  ));
}
var Mv = class {
  constructor(e) {
    this.autoFreeze_ = true, this.useStrictShallowCopy_ = false, this.produce = (t, n, r) => {
      if (typeof t == "function" && typeof n != "function") {
        const a = n;
        n = t;
        const i = this;
        return function(c = a, ...u) {
          return i.produce(c, (d) => n.call(this, d, ...u));
        };
      }
      typeof n != "function" && we(6), r !== void 0 && typeof r != "function" && we(7);
      let s;
      if (Ht(t)) {
        const a = Bi(this), i = ca(t, void 0);
        let o = true;
        try {
          s = n(i), o = false;
        } finally {
          o ? ia(a) : oa(a);
        }
        return Vi(a, r), Wi(s, a);
      } else if (!t || typeof t != "object") {
        if (s = n(t), s === void 0 && (s = t), s === Cu && (s = void 0), this.autoFreeze_ && Ea(s, true), r) {
          const a = [], i = [];
          Jt("Patches").generateReplacementPatches_(t, s, a, i), r(a, i);
        }
        return s;
      } else
        we(1, t);
    }, this.produceWithPatches = (t, n) => {
      if (typeof t == "function")
        return (i, ...o) => this.produceWithPatches(i, (c) => t(c, ...o));
      let r, s;
      return [this.produce(t, n, (i, o) => {
        r = i, s = o;
      }), r, s];
    }, typeof (e == null ? void 0 : e.autoFreeze) == "boolean" && this.setAutoFreeze(e.autoFreeze), typeof (e == null ? void 0 : e.useStrictShallowCopy) == "boolean" && this.setUseStrictShallowCopy(e.useStrictShallowCopy);
  }
  createDraft(e) {
    Ht(e) || we(8), Tn(e) && (e = Fv(e));
    const t = Bi(this), n = ca(e, void 0);
    return n[Ce].isManual_ = true, oa(t), n;
  }
  finishDraft(e, t) {
    const n = e && e[Ce];
    (!n || !n.isManual_) && we(9);
    const { scope_: r } = n;
    return Vi(r, t), Wi(void 0, r);
  }
  /**
   * Pass true to automatically freeze all copies created by Immer.
   *
   * By default, auto-freezing is enabled.
   */
  setAutoFreeze(e) {
    this.autoFreeze_ = e;
  }
  /**
   * Pass true to enable strict shallow copy.
   *
   * By default, immer does not copy the object descriptors such as getter, setter and non-enumrable properties.
   */
  setUseStrictShallowCopy(e) {
    this.useStrictShallowCopy_ = e;
  }
  applyPatches(e, t) {
    let n;
    for (n = t.length - 1; n >= 0; n--) {
      const s = t[n];
      if (s.path.length === 0 && s.op === "replace") {
        e = s.value;
        break;
      }
    }
    n > -1 && (t = t.slice(n + 1));
    const r = Jt("Patches").applyPatches_;
    return Tn(e) ? r(e, t) : this.produce(
      e,
      (s) => r(s, t)
    );
  }
};
function ca(e, t) {
  const n = Ur(e) ? Jt("MapSet").proxyMap_(e, t) : Vr(e) ? Jt("MapSet").proxySet_(e, t) : Lv(e, t);
  return (t ? t.scope_ : Iu()).drafts_.push(n), n;
}
function Fv(e) {
  return Tn(e) || we(10, e), ju(e);
}
function ju(e) {
  if (!Ht(e) || Br(e))
    return e;
  const t = e[Ce];
  let n;
  if (t) {
    if (!t.modified_)
      return t.base_;
    t.finalized_ = true, n = aa(e, t.scope_.immer_.useStrictShallowCopy_);
  } else
    n = aa(e, true);
  return Zn(n, (r, s) => {
    Au(n, r, ju(s));
  }), t && (t.finalized_ = false), n;
}
var Re = new Mv();
var ie = Re.produce;
Re.produceWithPatches.bind(
  Re
);
Re.setAutoFreeze.bind(Re);
Re.setUseStrictShallowCopy.bind(Re);
Re.applyPatches.bind(Re);
Re.createDraft.bind(Re);
Re.finishDraft.bind(Re);
var zv = (e) => (t) => {
  var r, s, a;
  let n = [];
  if (e.discriminator === "authorizedRequest") {
    const i = ((r = e.oneTimeAccounts) == null ? void 0 : r.accounts) ?? [], o = ((s = e.ongoingAccounts) == null ? void 0 : s.accounts) ?? [];
    n = [...i, ...o];
  } else
    e.discriminator === "unauthorizedRequest" && (n = ((a = e.oneTimeAccounts) == null ? void 0 : a.accounts) ?? []);
  return ie(t, (i) => {
    i.accounts = n;
  });
};
var vs = (e) => {
  const t = [];
  return e.name && t.push({
    entry: "fullName",
    fields: e.name
  }), e.emailAddresses && t.push({
    entry: "emailAddresses",
    fields: e.emailAddresses
  }), e.phoneNumbers && t.push({
    entry: "phoneNumbers",
    fields: e.phoneNumbers
  }), t;
};
var Uv = (e) => (t) => ie(t, (n) => {
  e.discriminator === "authorizedRequest" ? (e.oneTimePersonaData && (n.personaData = vs(e.oneTimePersonaData)), e.ongoingPersonaData && (n.personaData = vs(e.ongoingPersonaData))) : e.discriminator === "unauthorizedRequest" && e.oneTimePersonaData && (n.personaData = vs(e.oneTimePersonaData));
});
var Vv = (e) => (t) => ie(t, (n) => {
  var r;
  e.discriminator === "authorizedRequest" && (n.persona = (r = e.auth) == null ? void 0 : r.persona);
});
var Bv = (e) => (t) => ie(t, (n) => {
  var r, s, a, i, o, c;
  if (n.proofs = [], e.discriminator === "authorizedRequest") {
    if (e.auth.discriminator === "loginWithChallenge" && n.proofs.push({
      challenge: e.auth.challenge,
      proof: e.auth.proof,
      address: e.auth.persona.identityAddress,
      type: an.persona
    }), (r = e.ongoingAccounts) != null && r.challenge && ((s = e.ongoingAccounts.proofs) != null && s.length)) {
      const u = e.ongoingAccounts.challenge, d = e.ongoingAccounts.proofs.map(
        ({ accountAddress: h, proof: p }) => ({
          proof: p,
          address: h,
          challenge: u,
          type: an.account
        })
      );
      n.proofs.push(...d);
    }
    if ((a = e.oneTimeAccounts) != null && a.challenge && ((i = e.oneTimeAccounts.proofs) != null && i.length)) {
      const u = e.oneTimeAccounts.challenge, d = e.oneTimeAccounts.proofs.map(
        ({ accountAddress: h, proof: p }) => ({
          proof: p,
          address: h,
          challenge: u,
          type: an.account
        })
      );
      n.proofs.push(...d);
    }
  }
  if (e.discriminator === "unauthorizedRequest" && (o = e.oneTimeAccounts) != null && o.challenge && (c = e.oneTimeAccounts.proofs) != null && c.length) {
    const u = e.oneTimeAccounts.challenge, d = e.oneTimeAccounts.proofs.map(
      ({ accountAddress: h, proof: p }) => ({
        proof: p,
        address: h,
        challenge: u,
        type: an.account
      })
    );
    n.proofs.push(...d);
  }
});
var Wv = (e) => me({
  accounts: [],
  personaData: [],
  proofs: [],
  persona: void 0
}).map(zv(e)).map(Uv(e)).map(Vv(e)).map(Bv(e));
ve({
  accounts: ve({
    numberOfAccounts: Ke,
    reset: ze(),
    oneTime: ze(),
    challenge: Ve().optional()
  }).optional(),
  personaData: ve({
    fullName: ze().optional(),
    phoneNumbers: Ke.optional(),
    emailAddresses: Ke.optional(),
    reset: ze(),
    oneTime: ze().optional()
  }).optional(),
  persona: ve({
    identityAddress: Ve().optional(),
    label: Ve().optional(),
    challenge: Ve().optional()
  }).optional()
});
var Kv = (e) => {
  const { persona: t, accounts: n, personaData: r } = e, s = !!t, a = (n == null ? void 0 : n.reset) || (r == null ? void 0 : r.reset), i = n && !(n != null && n.oneTime), o = r && !(r != null && r.oneTime);
  return !!(a || i || o || s);
};
var Gv = (e) => {
  var t, n, r;
  return (t = e.persona) != null && t.challenge ? {
    discriminator: "loginWithChallenge",
    challenge: e.persona.challenge
  } : (n = e.persona) != null && n.identityAddress ? {
    discriminator: "usePersona",
    identityAddress: (r = e.persona) == null ? void 0 : r.identityAddress
  } : {
    discriminator: "loginWithoutChallenge"
  };
};
var Du = (e) => (t) => {
  var s, a;
  const n = { ...t }, { accounts: r } = e;
  if (r) {
    const i = {
      challenge: r.challenge,
      numberOfAccounts: r.numberOfAccounts
    }, o = n.discriminator === "authorizedRequest" && !((s = e.accounts) != null && s.oneTime), c = n.discriminator === "authorizedRequest";
    (a = e.accounts) != null && a.oneTime ? n.oneTimeAccounts = i : (o || c) && (n.ongoingAccounts = i);
  }
  return n;
};
var qu = (e) => (t) => {
  var r, s;
  const n = { ...t };
  if (e.personaData) {
    const {
      fullName: a,
      phoneNumbers: i,
      emailAddresses: o
    } = e.personaData;
    (r = e.personaData) != null && r.oneTime && (n.oneTimePersonaData = {
      isRequestingName: a,
      numberOfRequestedPhoneNumbers: i,
      numberOfRequestedEmailAddresses: o
    });
    const c = n.discriminator === "authorizedRequest" && !((s = e.personaData) != null && s.oneTime), u = n.discriminator === "authorizedRequest";
    (c || u) && (n.ongoingPersonaData = {
      isRequestingName: a,
      numberOfRequestedPhoneNumbers: i,
      numberOfRequestedEmailAddresses: o
    });
  }
  return n;
};
var Hv = (e) => (t) => {
  const { accounts: n, personaData: r } = e;
  return {
    ...t,
    reset: { accounts: !!(n != null && n.reset), personaData: !!(r != null && r.reset) }
  };
};
var Jv = (e) => me({
  discriminator: "unauthorizedRequest"
}).map(Du(e)).map(qu(e));
var Yv = (e) => me({
  discriminator: "authorizedRequest",
  auth: Gv(e)
}).map(Du(e)).map(qu(e)).map(Hv(e));
var Xv = (e, t) => me(
  e ? ie(t, (n) => {
    n.accounts && (n.accounts.oneTime = false, n.accounts.reset = false), n.personaData && (n.personaData.oneTime = false, n.personaData.reset = false);
  }) : t
);
var Qv = (e, t) => Xv(e, t).andThen(
  (n) => Kv(n) ? Yv(n) : Jv(n)
);
var eg = ({
  dataRequestState: e,
  isConnect: t,
  challenge: n,
  oneTime: r,
  stateClient: s
}) => Qv(
  t,
  ie({}, (a) => {
    var i;
    if (e.accounts && (a.accounts = {
      numberOfAccounts: e.accounts.numberOfAccounts || {
        quantifier: "atLeast",
        quantity: 1
      },
      oneTime: r,
      reset: !!e.accounts.reset,
      challenge: e.accounts.withProof ? n : void 0
    }), e.personaData && (a.personaData = {
      ...e.personaData,
      reset: !!e.personaData.reset,
      oneTime: r
    }), !r) {
      const o = s.getState().walletData.persona;
      s.getState().walletData.persona && (a.persona = o), (i = e.persona) != null && i.withProof && (a.persona = { ...a.persona ?? {}, challenge: n }), Object.values(e).length === 0 && (a.persona = { challenge: void 0 });
    }
  })
);
var ar = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function tg(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var Dr = { exports: {} };
Dr.exports;
(function(e, t) {
  var n = 200, r = "__lodash_hash_undefined__", s = 1, a = 2, i = 9007199254740991, o = "[object Arguments]", c = "[object Array]", u = "[object AsyncFunction]", d = "[object Boolean]", h = "[object Date]", p = "[object Error]", b = "[object Function]", E = "[object GeneratorFunction]", y = "[object Map]", A = "[object Number]", O = "[object Null]", I = "[object Object]", X = "[object Promise]", F = "[object Proxy]", ue = "[object RegExp]", G = "[object Set]", S = "[object String]", se = "[object Symbol]", Q = "[object Undefined]", he = "[object WeakMap]", Yt = "[object ArrayBuffer]", Xt = "[object DataView]", Wr = "[object Float32Array]", Zu = "[object Float64Array]", Mu = "[object Int8Array]", Fu = "[object Int16Array]", zu = "[object Int32Array]", Uu = "[object Uint8Array]", Vu = "[object Uint8ClampedArray]", Bu = "[object Uint16Array]", Wu = "[object Uint32Array]", Ku = /[\\^$.*+?()[\]{}|]/g, Gu = /^\[object .+?Constructor\]$/, Hu = /^(?:0|[1-9]\d*)$/, J = {};
  J[Wr] = J[Zu] = J[Mu] = J[Fu] = J[zu] = J[Uu] = J[Vu] = J[Bu] = J[Wu] = true, J[o] = J[c] = J[Yt] = J[d] = J[Xt] = J[h] = J[p] = J[b] = J[y] = J[A] = J[I] = J[ue] = J[G] = J[S] = J[he] = false;
  var Ra = typeof ar == "object" && ar && ar.Object === Object && ar, Ju = typeof self == "object" && self && self.Object === Object && self, rt = Ra || Ju || Function("return this")(), Aa = t && !t.nodeType && t, Ia = Aa && true && e && !e.nodeType && e, Na = Ia && Ia.exports === Aa, Kr = Na && Ra.process, ja = function() {
    try {
      return Kr && Kr.binding && Kr.binding("util");
    } catch {
    }
  }(), Da = ja && ja.isTypedArray;
  function Yu(l, f) {
    for (var m = -1, x = l == null ? 0 : l.length, Y = 0, q = []; ++m < x; ) {
      var te = l[m];
      f(te, m, l) && (q[Y++] = te);
    }
    return q;
  }
  function Xu(l, f) {
    for (var m = -1, x = f.length, Y = l.length; ++m < x; )
      l[Y + m] = f[m];
    return l;
  }
  function Qu(l, f) {
    for (var m = -1, x = l == null ? 0 : l.length; ++m < x; )
      if (f(l[m], m, l))
        return true;
    return false;
  }
  function ec(l, f) {
    for (var m = -1, x = Array(l); ++m < l; )
      x[m] = f(m);
    return x;
  }
  function tc(l) {
    return function(f) {
      return l(f);
    };
  }
  function nc(l, f) {
    return l.has(f);
  }
  function rc(l, f) {
    return l == null ? void 0 : l[f];
  }
  function sc(l) {
    var f = -1, m = Array(l.size);
    return l.forEach(function(x, Y) {
      m[++f] = [Y, x];
    }), m;
  }
  function ac(l, f) {
    return function(m) {
      return l(f(m));
    };
  }
  function ic(l) {
    var f = -1, m = Array(l.size);
    return l.forEach(function(x) {
      m[++f] = x;
    }), m;
  }
  var oc = Array.prototype, uc = Function.prototype, Bn = Object.prototype, Gr = rt["__core-js_shared__"], qa = uc.toString, Fe = Bn.hasOwnProperty, $a = function() {
    var l = /[^.]+$/.exec(Gr && Gr.keys && Gr.keys.IE_PROTO || "");
    return l ? "Symbol(src)_1." + l : "";
  }(), La = Bn.toString, cc = RegExp(
    "^" + qa.call(Fe).replace(Ku, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
  ), Za = Na ? rt.Buffer : void 0, Wn = rt.Symbol, Ma = rt.Uint8Array, Fa = Bn.propertyIsEnumerable, lc = oc.splice, Et = Wn ? Wn.toStringTag : void 0, za = Object.getOwnPropertySymbols, dc = Za ? Za.isBuffer : void 0, fc = ac(Object.keys, Object), Hr = Qt(rt, "DataView"), On = Qt(rt, "Map"), Jr = Qt(rt, "Promise"), Yr = Qt(rt, "Set"), Xr = Qt(rt, "WeakMap"), En = Qt(Object, "create"), hc = At(Hr), pc = At(On), mc = At(Jr), yc = At(Yr), vc = At(Xr), Ua = Wn ? Wn.prototype : void 0, Qr = Ua ? Ua.valueOf : void 0;
  function Ct(l) {
    var f = -1, m = l == null ? 0 : l.length;
    for (this.clear(); ++f < m; ) {
      var x = l[f];
      this.set(x[0], x[1]);
    }
  }
  function gc() {
    this.__data__ = En ? En(null) : {}, this.size = 0;
  }
  function _c(l) {
    var f = this.has(l) && delete this.__data__[l];
    return this.size -= f ? 1 : 0, f;
  }
  function bc(l) {
    var f = this.__data__;
    if (En) {
      var m = f[l];
      return m === r ? void 0 : m;
    }
    return Fe.call(f, l) ? f[l] : void 0;
  }
  function wc(l) {
    var f = this.__data__;
    return En ? f[l] !== void 0 : Fe.call(f, l);
  }
  function xc(l, f) {
    var m = this.__data__;
    return this.size += this.has(l) ? 0 : 1, m[l] = En && f === void 0 ? r : f, this;
  }
  Ct.prototype.clear = gc, Ct.prototype.delete = _c, Ct.prototype.get = bc, Ct.prototype.has = wc, Ct.prototype.set = xc;
  function st(l) {
    var f = -1, m = l == null ? 0 : l.length;
    for (this.clear(); ++f < m; ) {
      var x = l[f];
      this.set(x[0], x[1]);
    }
  }
  function kc() {
    this.__data__ = [], this.size = 0;
  }
  function Sc(l) {
    var f = this.__data__, m = Gn(f, l);
    if (m < 0)
      return false;
    var x = f.length - 1;
    return m == x ? f.pop() : lc.call(f, m, 1), --this.size, true;
  }
  function Tc(l) {
    var f = this.__data__, m = Gn(f, l);
    return m < 0 ? void 0 : f[m][1];
  }
  function Pc(l) {
    return Gn(this.__data__, l) > -1;
  }
  function Oc(l, f) {
    var m = this.__data__, x = Gn(m, l);
    return x < 0 ? (++this.size, m.push([l, f])) : m[x][1] = f, this;
  }
  st.prototype.clear = kc, st.prototype.delete = Sc, st.prototype.get = Tc, st.prototype.has = Pc, st.prototype.set = Oc;
  function Rt(l) {
    var f = -1, m = l == null ? 0 : l.length;
    for (this.clear(); ++f < m; ) {
      var x = l[f];
      this.set(x[0], x[1]);
    }
  }
  function Ec() {
    this.size = 0, this.__data__ = {
      hash: new Ct(),
      map: new (On || st)(),
      string: new Ct()
    };
  }
  function Cc(l) {
    var f = Hn(this, l).delete(l);
    return this.size -= f ? 1 : 0, f;
  }
  function Rc(l) {
    return Hn(this, l).get(l);
  }
  function Ac(l) {
    return Hn(this, l).has(l);
  }
  function Ic(l, f) {
    var m = Hn(this, l), x = m.size;
    return m.set(l, f), this.size += m.size == x ? 0 : 1, this;
  }
  Rt.prototype.clear = Ec, Rt.prototype.delete = Cc, Rt.prototype.get = Rc, Rt.prototype.has = Ac, Rt.prototype.set = Ic;
  function Kn(l) {
    var f = -1, m = l == null ? 0 : l.length;
    for (this.__data__ = new Rt(); ++f < m; )
      this.add(l[f]);
  }
  function Nc(l) {
    return this.__data__.set(l, r), this;
  }
  function jc(l) {
    return this.__data__.has(l);
  }
  Kn.prototype.add = Kn.prototype.push = Nc, Kn.prototype.has = jc;
  function ht(l) {
    var f = this.__data__ = new st(l);
    this.size = f.size;
  }
  function Dc() {
    this.__data__ = new st(), this.size = 0;
  }
  function qc(l) {
    var f = this.__data__, m = f.delete(l);
    return this.size = f.size, m;
  }
  function $c(l) {
    return this.__data__.get(l);
  }
  function Lc(l) {
    return this.__data__.has(l);
  }
  function Zc(l, f) {
    var m = this.__data__;
    if (m instanceof st) {
      var x = m.__data__;
      if (!On || x.length < n - 1)
        return x.push([l, f]), this.size = ++m.size, this;
      m = this.__data__ = new Rt(x);
    }
    return m.set(l, f), this.size = m.size, this;
  }
  ht.prototype.clear = Dc, ht.prototype.delete = qc, ht.prototype.get = $c, ht.prototype.has = Lc, ht.prototype.set = Zc;
  function Mc(l, f) {
    var m = Jn(l), x = !m && tl(l), Y = !m && !x && es(l), q = !m && !x && !Y && Xa(l), te = m || x || Y || q, ce = te ? ec(l.length, String) : [], fe = ce.length;
    for (var ee in l)
      (f || Fe.call(l, ee)) && !(te && // Safari 9 has enumerable `arguments.length` in strict mode.
      (ee == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
      Y && (ee == "offset" || ee == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
      q && (ee == "buffer" || ee == "byteLength" || ee == "byteOffset") || // Skip index properties.
      Jc(ee, fe))) && ce.push(ee);
    return ce;
  }
  function Gn(l, f) {
    for (var m = l.length; m--; )
      if (Ga(l[m][0], f))
        return m;
    return -1;
  }
  function Fc(l, f, m) {
    var x = f(l);
    return Jn(l) ? x : Xu(x, m(l));
  }
  function Cn(l) {
    return l == null ? l === void 0 ? Q : O : Et && Et in Object(l) ? Gc(l) : el(l);
  }
  function Va(l) {
    return Rn(l) && Cn(l) == o;
  }
  function Ba(l, f, m, x, Y) {
    return l === f ? true : l == null || f == null || !Rn(l) && !Rn(f) ? l !== l && f !== f : zc(l, f, m, x, Ba, Y);
  }
  function zc(l, f, m, x, Y, q) {
    var te = Jn(l), ce = Jn(f), fe = te ? c : pt(l), ee = ce ? c : pt(f);
    fe = fe == o ? I : fe, ee = ee == o ? I : ee;
    var Te = fe == I, qe = ee == I, pe = fe == ee;
    if (pe && es(l)) {
      if (!es(f))
        return false;
      te = true, Te = false;
    }
    if (pe && !Te)
      return q || (q = new ht()), te || Xa(l) ? Wa(l, f, m, x, Y, q) : Wc(l, f, fe, m, x, Y, q);
    if (!(m & s)) {
      var Ae = Te && Fe.call(l, "__wrapped__"), Ie = qe && Fe.call(f, "__wrapped__");
      if (Ae || Ie) {
        var mt = Ae ? l.value() : l, at = Ie ? f.value() : f;
        return q || (q = new ht()), Y(mt, at, m, x, q);
      }
    }
    return pe ? (q || (q = new ht()), Kc(l, f, m, x, Y, q)) : false;
  }
  function Uc(l) {
    if (!Ya(l) || Xc(l))
      return false;
    var f = Ha(l) ? cc : Gu;
    return f.test(At(l));
  }
  function Vc(l) {
    return Rn(l) && Ja(l.length) && !!J[Cn(l)];
  }
  function Bc(l) {
    if (!Qc(l))
      return fc(l);
    var f = [];
    for (var m in Object(l))
      Fe.call(l, m) && m != "constructor" && f.push(m);
    return f;
  }
  function Wa(l, f, m, x, Y, q) {
    var te = m & s, ce = l.length, fe = f.length;
    if (ce != fe && !(te && fe > ce))
      return false;
    var ee = q.get(l);
    if (ee && q.get(f))
      return ee == f;
    var Te = -1, qe = true, pe = m & a ? new Kn() : void 0;
    for (q.set(l, f), q.set(f, l); ++Te < ce; ) {
      var Ae = l[Te], Ie = f[Te];
      if (x)
        var mt = te ? x(Ie, Ae, Te, f, l, q) : x(Ae, Ie, Te, l, f, q);
      if (mt !== void 0) {
        if (mt)
          continue;
        qe = false;
        break;
      }
      if (pe) {
        if (!Qu(f, function(at, It) {
          if (!nc(pe, It) && (Ae === at || Y(Ae, at, m, x, q)))
            return pe.push(It);
        })) {
          qe = false;
          break;
        }
      } else if (!(Ae === Ie || Y(Ae, Ie, m, x, q))) {
        qe = false;
        break;
      }
    }
    return q.delete(l), q.delete(f), qe;
  }
  function Wc(l, f, m, x, Y, q, te) {
    switch (m) {
      case Xt:
        if (l.byteLength != f.byteLength || l.byteOffset != f.byteOffset)
          return false;
        l = l.buffer, f = f.buffer;
      case Yt:
        return !(l.byteLength != f.byteLength || !q(new Ma(l), new Ma(f)));
      case d:
      case h:
      case A:
        return Ga(+l, +f);
      case p:
        return l.name == f.name && l.message == f.message;
      case ue:
      case S:
        return l == f + "";
      case y:
        var ce = sc;
      case G:
        var fe = x & s;
        if (ce || (ce = ic), l.size != f.size && !fe)
          return false;
        var ee = te.get(l);
        if (ee)
          return ee == f;
        x |= a, te.set(l, f);
        var Te = Wa(ce(l), ce(f), x, Y, q, te);
        return te.delete(l), Te;
      case se:
        if (Qr)
          return Qr.call(l) == Qr.call(f);
    }
    return false;
  }
  function Kc(l, f, m, x, Y, q) {
    var te = m & s, ce = Ka(l), fe = ce.length, ee = Ka(f), Te = ee.length;
    if (fe != Te && !te)
      return false;
    for (var qe = fe; qe--; ) {
      var pe = ce[qe];
      if (!(te ? pe in f : Fe.call(f, pe)))
        return false;
    }
    var Ae = q.get(l);
    if (Ae && q.get(f))
      return Ae == f;
    var Ie = true;
    q.set(l, f), q.set(f, l);
    for (var mt = te; ++qe < fe; ) {
      pe = ce[qe];
      var at = l[pe], It = f[pe];
      if (x)
        var Qa = te ? x(It, at, pe, f, l, q) : x(at, It, pe, l, f, q);
      if (!(Qa === void 0 ? at === It || Y(at, It, m, x, q) : Qa)) {
        Ie = false;
        break;
      }
      mt || (mt = pe == "constructor");
    }
    if (Ie && !mt) {
      var Yn = l.constructor, Xn = f.constructor;
      Yn != Xn && "constructor" in l && "constructor" in f && !(typeof Yn == "function" && Yn instanceof Yn && typeof Xn == "function" && Xn instanceof Xn) && (Ie = false);
    }
    return q.delete(l), q.delete(f), Ie;
  }
  function Ka(l) {
    return Fc(l, sl, Hc);
  }
  function Hn(l, f) {
    var m = l.__data__;
    return Yc(f) ? m[typeof f == "string" ? "string" : "hash"] : m.map;
  }
  function Qt(l, f) {
    var m = rc(l, f);
    return Uc(m) ? m : void 0;
  }
  function Gc(l) {
    var f = Fe.call(l, Et), m = l[Et];
    try {
      l[Et] = void 0;
      var x = true;
    } catch {
    }
    var Y = La.call(l);
    return x && (f ? l[Et] = m : delete l[Et]), Y;
  }
  var Hc = za ? function(l) {
    return l == null ? [] : (l = Object(l), Yu(za(l), function(f) {
      return Fa.call(l, f);
    }));
  } : al, pt = Cn;
  (Hr && pt(new Hr(new ArrayBuffer(1))) != Xt || On && pt(new On()) != y || Jr && pt(Jr.resolve()) != X || Yr && pt(new Yr()) != G || Xr && pt(new Xr()) != he) && (pt = function(l) {
    var f = Cn(l), m = f == I ? l.constructor : void 0, x = m ? At(m) : "";
    if (x)
      switch (x) {
        case hc:
          return Xt;
        case pc:
          return y;
        case mc:
          return X;
        case yc:
          return G;
        case vc:
          return he;
      }
    return f;
  });
  function Jc(l, f) {
    return f = f ?? i, !!f && (typeof l == "number" || Hu.test(l)) && l > -1 && l % 1 == 0 && l < f;
  }
  function Yc(l) {
    var f = typeof l;
    return f == "string" || f == "number" || f == "symbol" || f == "boolean" ? l !== "__proto__" : l === null;
  }
  function Xc(l) {
    return !!$a && $a in l;
  }
  function Qc(l) {
    var f = l && l.constructor, m = typeof f == "function" && f.prototype || Bn;
    return l === m;
  }
  function el(l) {
    return La.call(l);
  }
  function At(l) {
    if (l != null) {
      try {
        return qa.call(l);
      } catch {
      }
      try {
        return l + "";
      } catch {
      }
    }
    return "";
  }
  function Ga(l, f) {
    return l === f || l !== l && f !== f;
  }
  var tl = Va(function() {
    return arguments;
  }()) ? Va : function(l) {
    return Rn(l) && Fe.call(l, "callee") && !Fa.call(l, "callee");
  }, Jn = Array.isArray;
  function nl(l) {
    return l != null && Ja(l.length) && !Ha(l);
  }
  var es = dc || il;
  function rl(l, f) {
    return Ba(l, f);
  }
  function Ha(l) {
    if (!Ya(l))
      return false;
    var f = Cn(l);
    return f == b || f == E || f == u || f == F;
  }
  function Ja(l) {
    return typeof l == "number" && l > -1 && l % 1 == 0 && l <= i;
  }
  function Ya(l) {
    var f = typeof l;
    return l != null && (f == "object" || f == "function");
  }
  function Rn(l) {
    return l != null && typeof l == "object";
  }
  var Xa = Da ? tc(Da) : Vc;
  function sl(l) {
    return nl(l) ? Mc(l) : Bc(l);
  }
  function al() {
    return [];
  }
  function il() {
    return false;
  }
  e.exports = rl;
})(Dr, Dr.exports);
var ng = Dr.exports;
var rg = tg(ng);
var sg = (e, t) => {
  var n, r, s, a, i, o, c, u, d;
  if (e.discriminator === "authorizedRequest") {
    const h = ((n = e.reset) == null ? void 0 : n.accounts) || ((r = e.reset) == null ? void 0 : r.personaData), p = !!(e.oneTimeAccounts || e.oneTimePersonaData), b = e.auth.discriminator === "loginWithChallenge" || !!((s = e.oneTimeAccounts) != null && s.challenge) || !!((a = e.ongoingAccounts) != null && a.challenge);
    if (h || p || b)
      return false;
    let E = false;
    if (e.ongoingAccounts) {
      const { quantifier: y, quantity: A } = e.ongoingAccounts.numberOfAccounts;
      E = ((o = (i = t.sharedData) == null ? void 0 : i.ongoingAccounts) == null ? void 0 : o.quantifier) === y && ((u = (c = t.sharedData) == null ? void 0 : c.ongoingAccounts) == null ? void 0 : u.quantity) === A;
    }
    return e.ongoingPersonaData && (E = rg(
      e.ongoingPersonaData,
      (d = t.sharedData) == null ? void 0 : d.ongoingPersonaData
    )), E;
  }
  return false;
};
var ag = (e, t) => e.discriminator === "authorizedRequest" ? ie({}, (n) => {
  e.ongoingAccounts && (n.ongoingAccounts = e.ongoingAccounts.numberOfAccounts), e.ongoingPersonaData && (n.ongoingPersonaData = e.ongoingPersonaData);
}) : t;
var ig = (e) => ie({}, (t) => {
  e.ongoingAccounts && (t.accounts = {
    numberOfAccounts: e.ongoingAccounts,
    withProof: false,
    reset: true
  }), e.ongoingPersonaData && (t.personaData = {
    ...e.ongoingPersonaData,
    reset: true
  });
});
var og = ({
  stateClient: e,
  requestItemClient: t,
  walletClient: n,
  useCache: r,
  dataRequestStateClient: s
}) => {
  let a;
  const i = (b) => {
    var E, y;
    return ((E = b.accounts) == null ? void 0 : E.withProof) || ((y = b.persona) == null ? void 0 : y.withProof);
  }, o = (b) => {
    if (!i(b))
      return Li(void 0);
    if (!a)
      throw new Error("Expected proof but no challenge generator provided");
    return a();
  }, c = (b) => {
    a = () => de.fromPromise(b(), () => ({
      error: "GenerateChallengeError",
      message: "Failed to generate challenge"
    }));
  }, u = (...b) => d({
    dataRequestState: s.toDataRequestState(...b),
    isConnect: false,
    oneTime: true
  }), d = ({
    isConnect: b,
    oneTime: E,
    dataRequestState: y
  }) => me(y).asyncAndThen(
    (A) => o(A).andThen(
      (O) => eg({
        dataRequestState: A,
        isConnect: b,
        challenge: O,
        oneTime: E,
        stateClient: e
      })
    )
  ).andThen((A) => {
    const O = e.getState();
    if (sg(A, O) && r)
      return Li(O.walletData);
    const I = !e.getState().walletData.persona && A.discriminator === "authorizedRequest", { id: X } = t.add(
      I ? "loginRequest" : "dataRequest"
    );
    return n.request(A, X).mapErr(
      ({ error: F, message: ue }) => ({
        error: F,
        message: ue
      })
    ).andThen(Wv).map((F) => (E || e.setState({
      walletData: F,
      sharedData: ag(
        A,
        e.getState().sharedData
      )
    }), F));
  });
  return {
    provideChallengeGenerator: c,
    sendOneTimeRequest: u,
    setState: (...b) => (s.setState(...b), {
      sendRequest: () => d({
        dataRequestState: s.getState(),
        isConnect: false,
        oneTime: false
      })
    }),
    sendRequest: ({
      isConnect: b,
      oneTime: E
    }) => d({
      isConnect: b,
      oneTime: E,
      dataRequestState: s.getState()
    }),
    updateSharedData: () => d({
      dataRequestState: ig(
        e.getState().sharedData
      ),
      isConnect: false,
      oneTime: false
    })
  };
};
var ug = (e) => {
  var a;
  const t = e.accounts ?? [], n = ((a = e == null ? void 0 : e.persona) == null ? void 0 : a.label) ?? "", r = !!(e != null && e.persona), s = e.personaData.map((i) => {
    if (i.entry === "fullName") {
      const { variant: o, givenNames: c, familyName: u, nickname: d } = i.fields;
      return {
        value: o === "western" ? `${c} "${d}" ${u}` : `${u} "${d}" ${c}`,
        field: "fullName"
      };
    } else {
      if (i.entry === "emailAddresses")
        return {
          // currently only one email address is supported
          value: i.fields[0],
          field: "emailAddress"
        };
      if (i.entry === "phoneNumbers")
        return {
          // currently only one phone number is supported
          value: i.fields[0],
          field: "phoneNumber"
        };
    }
  }).filter(
    (i) => !!i
  );
  return { accounts: t, personaLabel: n, connected: r, personaData: s };
};
var cg = (e) => {
  const t = new Pe(e), n = () => t.next(e), r = (u) => t.next(u), s = () => t.getValue(), a = (...u) => u.filter((d) => typeof d._toObject == "function").reduce(
    (d, h) => ({
      ...d,
      ...h._toObject()
    }),
    {}
  );
  return {
    reset: n,
    setState: (...u) => {
      u.length === 0 ? n() : r(a(...u));
    },
    getState: s,
    patchState: (...u) => {
      u.length !== 0 && r({ ...s(), ...a(...u) });
    },
    removeState: (...u) => {
      r(
        ie(s(), (d) => {
          u.forEach((h) => {
            delete d[h];
          });
        })
      );
    },
    toDataRequestState: a,
    state$: t.asObservable()
  };
};
var Ag = (e) => {
  const {
    dAppDefinitionAddress: t,
    networkId: n,
    providers: r,
    logger: s,
    onDisconnect: a,
    explorer: i,
    gatewayBaseUrl: o,
    useCache: c = true
  } = e || {}, u = `rdt:${t}:${n}`, d = new Pe(
    t
  ), h = new et(), p = (r == null ? void 0 : r.connectButton) ?? Yh({
    logger: s,
    explorer: i ?? {
      baseUrl: zi[n].dashboardUrl,
      transactionPath: "/transaction/",
      accountsPath: "/account/"
    }
  }), b = (r == null ? void 0 : r.gatewayClient) ?? Ov({
    logger: s,
    gatewayApi: Sv({
      basePath: o ?? zi[n].gatewayUrl,
      dAppDefinitionAddress: t
    })
  }), E = (r == null ? void 0 : r.walletSdk) ?? vh({
    logger: s,
    networkId: n,
    dAppDefinitionAddress: t
  }), y = (r == null ? void 0 : r.requestItemClient) ?? Cv({
    logger: s
  }), A = (r == null ? void 0 : r.walletClient) ?? Xh({
    logger: s,
    onCancelRequestItem$: p.onCancelRequestItem$,
    walletSdk: E,
    gatewayClient: b,
    requestItemClient: y
  }), O = (r == null ? void 0 : r.storageClient) ?? Rv(), I = (r == null ? void 0 : r.stateClient) ?? Hh(u, O, {
    logger: s
  }), X = (r == null ? void 0 : r.dataRequestStateClient) ?? cg({}), F = (r == null ? void 0 : r.dataRequestClient) ?? og({
    stateClient: I,
    requestItemClient: y,
    walletClient: A,
    useCache: c,
    dataRequestStateClient: X
  });
  h.add(
    d.pipe(
      xt((Q) => !!Q),
      ct(
        (Q) => b.gatewayApi.getEntityDetails(Q).map(
          (he) => Pv(
            he == null ? void 0 : he.metadata.items.find((Yt) => Yt.key === "name")
          ).stringified
        ).map((he) => {
          p.setDappName(he ?? "Unnamed dApp");
        })
      )
    ).subscribe()
  ), h.add(
    p.onConnect$.pipe(
      ct(() => (I.reset(), F.sendRequest({
        isConnect: true,
        oneTime: false
      })))
    ).subscribe()
  ), h.add(
    p.onDisconnect$.pipe(
      ae(() => {
        I.reset(), A.resetRequestItems(), a && a();
      })
    ).subscribe()
  ), h.add(
    I.state$.pipe(
      ae((Q) => {
        const { personaData: he, accounts: Yt, personaLabel: Xt, connected: Wr } = ug(Q.walletData);
        p.setAccounts(Yt), p.setPersonaData(he), p.setPersonaLabel(Xt), p.setConnected(Wr);
      })
    ).subscribe()
  ), h.add(
    A.requestItems$.pipe(
      ae((Q) => {
        p.setRequestItems(Q), p.setConnecting(
          Q.some(
            (he) => he.status === "pending" && he.type === "loginRequest"
          )
        ), p.setLoading(
          Q.some((he) => he.status === "pending")
        );
      })
    ).subscribe()
  ), h.add(
    dn(p.onUpdateSharedData$).pipe(ct(() => F.updateSharedData())).subscribe()
  );
  const ue = {
    state: b.gatewayApi.stateApi,
    status: b.gatewayApi.statusApi,
    transaction: b.gatewayApi.transactionApi
  };
  return {
    walletApi: {
      setRequestData: F.setState,
      sendRequest: () => F.sendRequest({
        isConnect: false,
        oneTime: false
      }),
      provideChallengeGenerator: (Q) => F.provideChallengeGenerator(Q),
      updateSharedData: () => F.updateSharedData(),
      sendOneTimeRequest: F.sendOneTimeRequest,
      sendTransaction: A.sendTransaction,
      walletData$: I.state$.pipe(Be((Q) => Q.walletData)),
      getWalletData: () => I.getState().walletData
    },
    gatewayApi: ue,
    disconnect: () => {
      A.resetRequestItems(), I.reset();
    },
    destroy: () => {
      I.destroy(), A.destroy(), h.unsubscribe(), p.destroy();
    }
  };
};
ve({
  numberOfAccounts: Ke,
  withProof: ze().optional(),
  reset: ze().optional()
});
var $u = () => {
  let t = ie({
    numberOfAccounts: { quantifier: "atLeast", quantity: 1 }
  }, () => {
  });
  const o = {
    atLeast: (c) => (t = ie(t, (u) => {
      u.numberOfAccounts.quantifier = "atLeast", u.numberOfAccounts.quantity = c;
    }), o),
    exactly: (c) => (t = ie(t, (u) => {
      u.numberOfAccounts.quantifier = "exactly", u.numberOfAccounts.quantity = c;
    }), o),
    withProof: (c = true) => (t = ie(t, (u) => {
      u.withProof = c;
    }), o),
    reset: (c = true) => (t = ie(t, (u) => {
      u.reset = c;
    }), o),
    _toObject: () => ({
      accounts: t
    })
  };
  return o;
};
ve({
  withProof: ze().optional()
});
var lg = (e = {
  withProof: false
}) => {
  let t = ie(e, () => {
  });
  const s = {
    withProof: (a = true) => (t = ie(t, (i) => {
      i.withProof = a;
    }), s),
    _toObject: () => ({
      persona: t
    })
  };
  return s;
};
ve({
  fullName: ze(),
  emailAddresses: Ke,
  phoneNumbers: Ke,
  reset: ze()
}).partial();
var Lu = (e = {}) => {
  let t = ie(e, () => {
  });
  const n = (u = true) => (t = ie(t, (d) => {
    d.fullName = u;
  }), c), r = (u) => ({
    atLeast: (d) => (t = ie(t, (h) => {
      h[u] = { quantifier: "atLeast", quantity: d };
    }), c),
    exactly: (d) => (t = ie(t, (h) => {
      h[u] = { quantifier: "exactly", quantity: d };
    }), c)
  }), c = {
    fullName: n,
    emailAddresses: (u = true) => (r("emailAddresses").exactly(u ? 1 : 0), c),
    phoneNumbers: (u = true) => (r("phoneNumbers").exactly(u ? 1 : 0), c),
    reset: (u = true) => (t = ie(t, (d) => {
      d.reset = u;
    }), c),
    _toObject: () => ({
      personaData: t
    })
  };
  return c;
};
var dg = (e) => ({
  _toObject: () => ({ ...e })
});
var Ig = {
  accounts: $u,
  personaData: Lu,
  persona: lg,
  config: dg
};
var Ng = {
  accounts: $u,
  personaData: Lu
};
export {
  Po as Account,
  Sd as AccountProof,
  Ds as AccountsRequestItem,
  qs as AccountsRequestResponseItem,
  Ad as AuthLoginRequestItem,
  Bd as AuthLoginRequestResponseItem,
  Rd as AuthLoginWithChallengeRequestItem,
  Vd as AuthLoginWithChallengeRequestResponseItem,
  Cd as AuthLoginWithoutChallengeRequestItem,
  Ud as AuthLoginWithoutChallengeRequestResponseItem,
  Id as AuthRequestItem,
  Kd as AuthRequestResponseItem,
  Ed as AuthUsePersonaRequestItem,
  Zd as CancelRequest,
  Ig as DataRequestBuilder,
  cg as DataRequestStateClient,
  Eg as LoginRequestResponseItem,
  Qd as MessageLifeCycleEvent,
  Eo as Metadata,
  Ke as NumberOfValues,
  Ng as OneTimeDataRequestBuilder,
  Un as Persona,
  Oo as PersonaDataName,
  Td as PersonaDataNameVariant,
  vr as PersonaDataRequestItem,
  $s as PersonaDataRequestResponseItem,
  zn as Proof,
  Ag as RadixDappToolkit,
  Fh as RdtState,
  Pd as ResetRequestItem,
  Dd as SendTransactionItem,
  $d as SendTransactionResponseItem,
  Mh as SharedData,
  jh as SignedChallenge,
  Nh as SignedChallengeAccount,
  Ih as SignedChallengePersona,
  Nd as WalletAuthorizedRequestItems,
  Gd as WalletAuthorizedRequestResponseItems,
  Zh as WalletData,
  Lh as WalletDataPersonaData,
  qh as WalletDataPersonaDataEmailAddresses,
  Dh as WalletDataPersonaDataFullName,
  $h as WalletDataPersonaDataPhoneNumbersAddresses,
  Fd as WalletInteraction,
  Xd as WalletInteractionFailureResponse,
  Md as WalletInteractionItems,
  Co as WalletInteractionResponse,
  Yd as WalletInteractionSuccessResponse,
  jd as WalletRequestItems,
  Hd as WalletRequestResponseItems,
  vh as WalletSdk,
  qd as WalletTransactionItems,
  Od as WalletUnauthorizedRequestItems,
  dg as config,
  Rg as createLogger,
  mn as createSdkError,
  Nn as errorType,
  as as eventType,
  er as messageLifeCycleEventType,
  Ti as personaDataFullNameVariant,
  an as proofType,
  tf as sdkError,
  fu as walletDataDefault,
  Cg as walletInteractionFactoryV2
};
//# sourceMappingURL=@radixdlt_radix-dapp-toolkit.js.map
